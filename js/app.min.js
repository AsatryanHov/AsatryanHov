/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_three_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/three.min.js */ \"./src/js/modules/three.min.js\");\n/* harmony import */ var _modules_vanta_waves_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/vanta.waves.min.js */ \"./src/js/modules/vanta.waves.min.js\");\n\r\n\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", () => {\r\n  (0,_modules_three_min_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n  (0,_modules_vanta_waves_min_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\n\r\n  VANTA.WAVES({\r\n    el: \"#element2\",\r\n    color: 0xc072d,\r\n    waveHeight: 30,\r\n    shininess: 15,\r\n    waveSpeed: 1,\r\n    zoom: 1,\r\n  });\r\n});\r\n\n\n//# sourceURL=webpack://gulp-2022/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/three.min.js":
/*!*************************************!*\
  !*** ./src/js/modules/three.min.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n\nconst three = () => {\n  !(function (t, e) {\n    \"object\" == typeof exports && \"undefined\" != typeof module\n      ? e(exports)\n      : \"function\" == typeof define && define.amd\n      ? define([\"exports\"], e)\n      : e(\n          ((t =\n            \"undefined\" != typeof globalThis ? globalThis : t || self).THREE =\n            {})\n        );\n  })(undefined, function (t) {\n    \"use strict\";\n    const e = \"134\",\n      n = 100,\n      i = 300,\n      r = 301,\n      s = 302,\n      a = 303,\n      o = 304,\n      l = 306,\n      c = 307,\n      h = 1e3,\n      u = 1001,\n      d = 1002,\n      p = 1003,\n      m = 1004,\n      f = 1005,\n      g = 1006,\n      v = 1007,\n      y = 1008,\n      x = 1009,\n      _ = 1012,\n      M = 1014,\n      b = 1015,\n      w = 1016,\n      S = 1020,\n      T = 1022,\n      E = 1023,\n      A = 1026,\n      L = 1027,\n      R = 33776,\n      C = 33777,\n      P = 33778,\n      I = 33779,\n      D = 35840,\n      N = 35841,\n      z = 35842,\n      B = 35843,\n      F = 37492,\n      O = 37496,\n      U = 2300,\n      H = 2301,\n      G = 2302,\n      k = 2400,\n      V = 2401,\n      W = 2402,\n      j = 2500,\n      q = 2501,\n      X = 3e3,\n      Y = 3001,\n      J = 3007,\n      Z = 3002,\n      Q = 3004,\n      K = 3005,\n      $ = 3006,\n      tt = 7680,\n      et = 35044,\n      nt = 35048,\n      it = \"300 es\";\n    class rt {\n      addEventListener(t, e) {\n        void 0 === this._listeners && (this._listeners = {});\n        const n = this._listeners;\n        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);\n      }\n      hasEventListener(t, e) {\n        if (void 0 === this._listeners) return !1;\n        const n = this._listeners;\n        return void 0 !== n[t] && -1 !== n[t].indexOf(e);\n      }\n      removeEventListener(t, e) {\n        if (void 0 === this._listeners) return;\n        const n = this._listeners[t];\n        if (void 0 !== n) {\n          const t = n.indexOf(e);\n          -1 !== t && n.splice(t, 1);\n        }\n      }\n      dispatchEvent(t) {\n        if (void 0 === this._listeners) return;\n        const e = this._listeners[t.type];\n        if (void 0 !== e) {\n          t.target = this;\n          const n = e.slice(0);\n          for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);\n          t.target = null;\n        }\n      }\n    }\n    let st = 1234567;\n    const at = Math.PI / 180,\n      ot = 180 / Math.PI,\n      lt = [];\n    for (let t = 0; t < 256; t++) lt[t] = (t < 16 ? \"0\" : \"\") + t.toString(16);\n    const ct = \"undefined\" != typeof crypto && \"randomUUID\" in crypto;\n    function ht() {\n      if (ct) return crypto.randomUUID().toUpperCase();\n      const t = (4294967295 * Math.random()) | 0,\n        e = (4294967295 * Math.random()) | 0,\n        n = (4294967295 * Math.random()) | 0,\n        i = (4294967295 * Math.random()) | 0;\n      return (\n        lt[255 & t] +\n        lt[(t >> 8) & 255] +\n        lt[(t >> 16) & 255] +\n        lt[(t >> 24) & 255] +\n        \"-\" +\n        lt[255 & e] +\n        lt[(e >> 8) & 255] +\n        \"-\" +\n        lt[((e >> 16) & 15) | 64] +\n        lt[(e >> 24) & 255] +\n        \"-\" +\n        lt[(63 & n) | 128] +\n        lt[(n >> 8) & 255] +\n        \"-\" +\n        lt[(n >> 16) & 255] +\n        lt[(n >> 24) & 255] +\n        lt[255 & i] +\n        lt[(i >> 8) & 255] +\n        lt[(i >> 16) & 255] +\n        lt[(i >> 24) & 255]\n      ).toUpperCase();\n    }\n    function ut(t, e, n) {\n      return Math.max(e, Math.min(n, t));\n    }\n    function dt(t, e) {\n      return ((t % e) + e) % e;\n    }\n    function pt(t, e, n) {\n      return (1 - n) * t + n * e;\n    }\n    function mt(t) {\n      return 0 == (t & (t - 1)) && 0 !== t;\n    }\n    function ft(t) {\n      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }\n    function gt(t) {\n      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));\n    }\n    var vt = Object.freeze({\n      __proto__: null,\n      DEG2RAD: at,\n      RAD2DEG: ot,\n      generateUUID: ht,\n      clamp: ut,\n      euclideanModulo: dt,\n      mapLinear: function (t, e, n, i, r) {\n        return i + ((t - e) * (r - i)) / (n - e);\n      },\n      inverseLerp: function (t, e, n) {\n        return t !== e ? (n - t) / (e - t) : 0;\n      },\n      lerp: pt,\n      damp: function (t, e, n, i) {\n        return pt(t, e, 1 - Math.exp(-n * i));\n      },\n      pingpong: function (t, e = 1) {\n        return e - Math.abs(dt(t, 2 * e) - e);\n      },\n      smoothstep: function (t, e, n) {\n        return t <= e\n          ? 0\n          : t >= n\n          ? 1\n          : (t = (t - e) / (n - e)) * t * (3 - 2 * t);\n      },\n      smootherstep: function (t, e, n) {\n        return t <= e\n          ? 0\n          : t >= n\n          ? 1\n          : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);\n      },\n      randInt: function (t, e) {\n        return t + Math.floor(Math.random() * (e - t + 1));\n      },\n      randFloat: function (t, e) {\n        return t + Math.random() * (e - t);\n      },\n      randFloatSpread: function (t) {\n        return t * (0.5 - Math.random());\n      },\n      seededRandom: function (t) {\n        return (\n          void 0 !== t && (st = t % 2147483647),\n          (st = (16807 * st) % 2147483647),\n          (st - 1) / 2147483646\n        );\n      },\n      degToRad: function (t) {\n        return t * at;\n      },\n      radToDeg: function (t) {\n        return t * ot;\n      },\n      isPowerOfTwo: mt,\n      ceilPowerOfTwo: ft,\n      floorPowerOfTwo: gt,\n      setQuaternionFromProperEuler: function (t, e, n, i, r) {\n        const s = Math.cos,\n          a = Math.sin,\n          o = s(n / 2),\n          l = a(n / 2),\n          c = s((e + i) / 2),\n          h = a((e + i) / 2),\n          u = s((e - i) / 2),\n          d = a((e - i) / 2),\n          p = s((i - e) / 2),\n          m = a((i - e) / 2);\n        switch (r) {\n          case \"XYX\":\n            t.set(o * h, l * u, l * d, o * c);\n            break;\n          case \"YZY\":\n            t.set(l * d, o * h, l * u, o * c);\n            break;\n          case \"ZXZ\":\n            t.set(l * u, l * d, o * h, o * c);\n            break;\n          case \"XZX\":\n            t.set(o * h, l * m, l * p, o * c);\n            break;\n          case \"YXY\":\n            t.set(l * p, o * h, l * m, o * c);\n            break;\n          case \"ZYZ\":\n            t.set(l * m, l * p, o * h, o * c);\n            break;\n          default:\n            console.warn(\n              \"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \" +\n                r\n            );\n        }\n      },\n    });\n    class yt {\n      constructor(t = 0, e = 0) {\n        (this.x = t), (this.y = e);\n      }\n      get width() {\n        return this.x;\n      }\n      set width(t) {\n        this.x = t;\n      }\n      get height() {\n        return this.y;\n      }\n      set height(t) {\n        this.y = t;\n      }\n      set(t, e) {\n        return (this.x = t), (this.y = e), this;\n      }\n      setScalar(t) {\n        return (this.x = t), (this.y = t), this;\n      }\n      setX(t) {\n        return (this.x = t), this;\n      }\n      setY(t) {\n        return (this.y = t), this;\n      }\n      setComponent(t, e) {\n        switch (t) {\n          case 0:\n            this.x = e;\n            break;\n          case 1:\n            this.y = e;\n            break;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n        return this;\n      }\n      getComponent(t) {\n        switch (t) {\n          case 0:\n            return this.x;\n          case 1:\n            return this.y;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n      }\n      clone() {\n        return new this.constructor(this.x, this.y);\n      }\n      copy(t) {\n        return (this.x = t.x), (this.y = t.y), this;\n      }\n      add(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"\n            ),\n            this.addVectors(t, e))\n          : ((this.x += t.x), (this.y += t.y), this);\n      }\n      addScalar(t) {\n        return (this.x += t), (this.y += t), this;\n      }\n      addVectors(t, e) {\n        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;\n      }\n      addScaledVector(t, e) {\n        return (this.x += t.x * e), (this.y += t.y * e), this;\n      }\n      sub(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"\n            ),\n            this.subVectors(t, e))\n          : ((this.x -= t.x), (this.y -= t.y), this);\n      }\n      subScalar(t) {\n        return (this.x -= t), (this.y -= t), this;\n      }\n      subVectors(t, e) {\n        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;\n      }\n      multiply(t) {\n        return (this.x *= t.x), (this.y *= t.y), this;\n      }\n      multiplyScalar(t) {\n        return (this.x *= t), (this.y *= t), this;\n      }\n      divide(t) {\n        return (this.x /= t.x), (this.y /= t.y), this;\n      }\n      divideScalar(t) {\n        return this.multiplyScalar(1 / t);\n      }\n      applyMatrix3(t) {\n        const e = this.x,\n          n = this.y,\n          i = t.elements;\n        return (\n          (this.x = i[0] * e + i[3] * n + i[6]),\n          (this.y = i[1] * e + i[4] * n + i[7]),\n          this\n        );\n      }\n      min(t) {\n        return (\n          (this.x = Math.min(this.x, t.x)),\n          (this.y = Math.min(this.y, t.y)),\n          this\n        );\n      }\n      max(t) {\n        return (\n          (this.x = Math.max(this.x, t.x)),\n          (this.y = Math.max(this.y, t.y)),\n          this\n        );\n      }\n      clamp(t, e) {\n        return (\n          (this.x = Math.max(t.x, Math.min(e.x, this.x))),\n          (this.y = Math.max(t.y, Math.min(e.y, this.y))),\n          this\n        );\n      }\n      clampScalar(t, e) {\n        return (\n          (this.x = Math.max(t, Math.min(e, this.x))),\n          (this.y = Math.max(t, Math.min(e, this.y))),\n          this\n        );\n      }\n      clampLength(t, e) {\n        const n = this.length();\n        return this.divideScalar(n || 1).multiplyScalar(\n          Math.max(t, Math.min(e, n))\n        );\n      }\n      floor() {\n        return (\n          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this\n        );\n      }\n      ceil() {\n        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;\n      }\n      round() {\n        return (\n          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this\n        );\n      }\n      roundToZero() {\n        return (\n          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),\n          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),\n          this\n        );\n      }\n      negate() {\n        return (this.x = -this.x), (this.y = -this.y), this;\n      }\n      dot(t) {\n        return this.x * t.x + this.y * t.y;\n      }\n      cross(t) {\n        return this.x * t.y - this.y * t.x;\n      }\n      lengthSq() {\n        return this.x * this.x + this.y * this.y;\n      }\n      length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      }\n      manhattanLength() {\n        return Math.abs(this.x) + Math.abs(this.y);\n      }\n      normalize() {\n        return this.divideScalar(this.length() || 1);\n      }\n      angle() {\n        return Math.atan2(-this.y, -this.x) + Math.PI;\n      }\n      distanceTo(t) {\n        return Math.sqrt(this.distanceToSquared(t));\n      }\n      distanceToSquared(t) {\n        const e = this.x - t.x,\n          n = this.y - t.y;\n        return e * e + n * n;\n      }\n      manhattanDistanceTo(t) {\n        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);\n      }\n      setLength(t) {\n        return this.normalize().multiplyScalar(t);\n      }\n      lerp(t, e) {\n        return (\n          (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this\n        );\n      }\n      lerpVectors(t, e, n) {\n        return (\n          (this.x = t.x + (e.x - t.x) * n),\n          (this.y = t.y + (e.y - t.y) * n),\n          this\n        );\n      }\n      equals(t) {\n        return t.x === this.x && t.y === this.y;\n      }\n      fromArray(t, e = 0) {\n        return (this.x = t[e]), (this.y = t[e + 1]), this;\n      }\n      toArray(t = [], e = 0) {\n        return (t[e] = this.x), (t[e + 1] = this.y), t;\n      }\n      fromBufferAttribute(t, e, n) {\n        return (\n          void 0 !== n &&\n            console.warn(\n              \"THREE.Vector2: offset has been removed from .fromBufferAttribute().\"\n            ),\n          (this.x = t.getX(e)),\n          (this.y = t.getY(e)),\n          this\n        );\n      }\n      rotateAround(t, e) {\n        const n = Math.cos(e),\n          i = Math.sin(e),\n          r = this.x - t.x,\n          s = this.y - t.y;\n        return (\n          (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this\n        );\n      }\n      random() {\n        return (this.x = Math.random()), (this.y = Math.random()), this;\n      }\n      *[Symbol.iterator]() {\n        yield this.x, yield this.y;\n      }\n    }\n    yt.prototype.isVector2 = !0;\n    class xt {\n      constructor() {\n        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),\n          arguments.length > 0 &&\n            console.error(\n              \"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\"\n            );\n      }\n      set(t, e, n, i, r, s, a, o, l) {\n        const c = this.elements;\n        return (\n          (c[0] = t),\n          (c[1] = i),\n          (c[2] = a),\n          (c[3] = e),\n          (c[4] = r),\n          (c[5] = o),\n          (c[6] = n),\n          (c[7] = s),\n          (c[8] = l),\n          this\n        );\n      }\n      identity() {\n        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;\n      }\n      copy(t) {\n        const e = this.elements,\n          n = t.elements;\n        return (\n          (e[0] = n[0]),\n          (e[1] = n[1]),\n          (e[2] = n[2]),\n          (e[3] = n[3]),\n          (e[4] = n[4]),\n          (e[5] = n[5]),\n          (e[6] = n[6]),\n          (e[7] = n[7]),\n          (e[8] = n[8]),\n          this\n        );\n      }\n      extractBasis(t, e, n) {\n        return (\n          t.setFromMatrix3Column(this, 0),\n          e.setFromMatrix3Column(this, 1),\n          n.setFromMatrix3Column(this, 2),\n          this\n        );\n      }\n      setFromMatrix4(t) {\n        const e = t.elements;\n        return (\n          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this\n        );\n      }\n      multiply(t) {\n        return this.multiplyMatrices(this, t);\n      }\n      premultiply(t) {\n        return this.multiplyMatrices(t, this);\n      }\n      multiplyMatrices(t, e) {\n        const n = t.elements,\n          i = e.elements,\n          r = this.elements,\n          s = n[0],\n          a = n[3],\n          o = n[6],\n          l = n[1],\n          c = n[4],\n          h = n[7],\n          u = n[2],\n          d = n[5],\n          p = n[8],\n          m = i[0],\n          f = i[3],\n          g = i[6],\n          v = i[1],\n          y = i[4],\n          x = i[7],\n          _ = i[2],\n          M = i[5],\n          b = i[8];\n        return (\n          (r[0] = s * m + a * v + o * _),\n          (r[3] = s * f + a * y + o * M),\n          (r[6] = s * g + a * x + o * b),\n          (r[1] = l * m + c * v + h * _),\n          (r[4] = l * f + c * y + h * M),\n          (r[7] = l * g + c * x + h * b),\n          (r[2] = u * m + d * v + p * _),\n          (r[5] = u * f + d * y + p * M),\n          (r[8] = u * g + d * x + p * b),\n          this\n        );\n      }\n      multiplyScalar(t) {\n        const e = this.elements;\n        return (\n          (e[0] *= t),\n          (e[3] *= t),\n          (e[6] *= t),\n          (e[1] *= t),\n          (e[4] *= t),\n          (e[7] *= t),\n          (e[2] *= t),\n          (e[5] *= t),\n          (e[8] *= t),\n          this\n        );\n      }\n      determinant() {\n        const t = this.elements,\n          e = t[0],\n          n = t[1],\n          i = t[2],\n          r = t[3],\n          s = t[4],\n          a = t[5],\n          o = t[6],\n          l = t[7],\n          c = t[8];\n        return (\n          e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o\n        );\n      }\n      invert() {\n        const t = this.elements,\n          e = t[0],\n          n = t[1],\n          i = t[2],\n          r = t[3],\n          s = t[4],\n          a = t[5],\n          o = t[6],\n          l = t[7],\n          c = t[8],\n          h = c * s - a * l,\n          u = a * o - c * r,\n          d = l * r - s * o,\n          p = e * h + n * u + i * d;\n        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        const m = 1 / p;\n        return (\n          (t[0] = h * m),\n          (t[1] = (i * l - c * n) * m),\n          (t[2] = (a * n - i * s) * m),\n          (t[3] = u * m),\n          (t[4] = (c * e - i * o) * m),\n          (t[5] = (i * r - a * e) * m),\n          (t[6] = d * m),\n          (t[7] = (n * o - l * e) * m),\n          (t[8] = (s * e - n * r) * m),\n          this\n        );\n      }\n      transpose() {\n        let t;\n        const e = this.elements;\n        return (\n          (t = e[1]),\n          (e[1] = e[3]),\n          (e[3] = t),\n          (t = e[2]),\n          (e[2] = e[6]),\n          (e[6] = t),\n          (t = e[5]),\n          (e[5] = e[7]),\n          (e[7] = t),\n          this\n        );\n      }\n      getNormalMatrix(t) {\n        return this.setFromMatrix4(t).invert().transpose();\n      }\n      transposeIntoArray(t) {\n        const e = this.elements;\n        return (\n          (t[0] = e[0]),\n          (t[1] = e[3]),\n          (t[2] = e[6]),\n          (t[3] = e[1]),\n          (t[4] = e[4]),\n          (t[5] = e[7]),\n          (t[6] = e[2]),\n          (t[7] = e[5]),\n          (t[8] = e[8]),\n          this\n        );\n      }\n      setUvTransform(t, e, n, i, r, s, a) {\n        const o = Math.cos(r),\n          l = Math.sin(r);\n        return (\n          this.set(\n            n * o,\n            n * l,\n            -n * (o * s + l * a) + s + t,\n            -i * l,\n            i * o,\n            -i * (-l * s + o * a) + a + e,\n            0,\n            0,\n            1\n          ),\n          this\n        );\n      }\n      scale(t, e) {\n        const n = this.elements;\n        return (\n          (n[0] *= t),\n          (n[3] *= t),\n          (n[6] *= t),\n          (n[1] *= e),\n          (n[4] *= e),\n          (n[7] *= e),\n          this\n        );\n      }\n      rotate(t) {\n        const e = Math.cos(t),\n          n = Math.sin(t),\n          i = this.elements,\n          r = i[0],\n          s = i[3],\n          a = i[6],\n          o = i[1],\n          l = i[4],\n          c = i[7];\n        return (\n          (i[0] = e * r + n * o),\n          (i[3] = e * s + n * l),\n          (i[6] = e * a + n * c),\n          (i[1] = -n * r + e * o),\n          (i[4] = -n * s + e * l),\n          (i[7] = -n * a + e * c),\n          this\n        );\n      }\n      translate(t, e) {\n        const n = this.elements;\n        return (\n          (n[0] += t * n[2]),\n          (n[3] += t * n[5]),\n          (n[6] += t * n[8]),\n          (n[1] += e * n[2]),\n          (n[4] += e * n[5]),\n          (n[7] += e * n[8]),\n          this\n        );\n      }\n      equals(t) {\n        const e = this.elements,\n          n = t.elements;\n        for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;\n        return !0;\n      }\n      fromArray(t, e = 0) {\n        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];\n        return this;\n      }\n      toArray(t = [], e = 0) {\n        const n = this.elements;\n        return (\n          (t[e] = n[0]),\n          (t[e + 1] = n[1]),\n          (t[e + 2] = n[2]),\n          (t[e + 3] = n[3]),\n          (t[e + 4] = n[4]),\n          (t[e + 5] = n[5]),\n          (t[e + 6] = n[6]),\n          (t[e + 7] = n[7]),\n          (t[e + 8] = n[8]),\n          t\n        );\n      }\n      clone() {\n        return new this.constructor().fromArray(this.elements);\n      }\n    }\n    function _t(t) {\n      if (0 === t.length) return -1 / 0;\n      let e = t[0];\n      for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);\n      return e;\n    }\n    xt.prototype.isMatrix3 = !0;\n    const Mt = {\n      Int8Array: Int8Array,\n      Uint8Array: Uint8Array,\n      Uint8ClampedArray: Uint8ClampedArray,\n      Int16Array: Int16Array,\n      Uint16Array: Uint16Array,\n      Int32Array: Int32Array,\n      Uint32Array: Uint32Array,\n      Float32Array: Float32Array,\n      Float64Array: Float64Array,\n    };\n    function bt(t, e) {\n      return new Mt[t](e);\n    }\n    function wt(t) {\n      return document.createElementNS(\"http://www.w3.org/1999/xhtml\", t);\n    }\n    function St(t, e = 0) {\n      let n = 3735928559 ^ e,\n        i = 1103547991 ^ e;\n      for (let e, r = 0; r < t.length; r++)\n        (e = t.charCodeAt(r)),\n          (n = Math.imul(n ^ e, 2654435761)),\n          (i = Math.imul(i ^ e, 1597334677));\n      return (\n        (n =\n          Math.imul(n ^ (n >>> 16), 2246822507) ^\n          Math.imul(i ^ (i >>> 13), 3266489909)),\n        (i =\n          Math.imul(i ^ (i >>> 16), 2246822507) ^\n          Math.imul(n ^ (n >>> 13), 3266489909)),\n        4294967296 * (2097151 & i) + (n >>> 0)\n      );\n    }\n    let Tt;\n    class Et {\n      static getDataURL(t) {\n        if (/^data:/i.test(t.src)) return t.src;\n        if (\"undefined\" == typeof HTMLCanvasElement) return t.src;\n        let e;\n        if (t instanceof HTMLCanvasElement) e = t;\n        else {\n          void 0 === Tt && (Tt = wt(\"canvas\")),\n            (Tt.width = t.width),\n            (Tt.height = t.height);\n          const n = Tt.getContext(\"2d\");\n          t instanceof ImageData\n            ? n.putImageData(t, 0, 0)\n            : n.drawImage(t, 0, 0, t.width, t.height),\n            (e = Tt);\n        }\n        return e.width > 2048 || e.height > 2048\n          ? (console.warn(\n              \"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\",\n              t\n            ),\n            e.toDataURL(\"image/jpeg\", 0.6))\n          : e.toDataURL(\"image/png\");\n      }\n    }\n    let At = 0;\n    class Lt extends rt {\n      constructor(\n        t = Lt.DEFAULT_IMAGE,\n        e = Lt.DEFAULT_MAPPING,\n        n = 1001,\n        i = 1001,\n        r = 1006,\n        s = 1008,\n        a = 1023,\n        o = 1009,\n        l = 1,\n        c = 3e3\n      ) {\n        super(),\n          Object.defineProperty(this, \"id\", { value: At++ }),\n          (this.uuid = ht()),\n          (this.name = \"\"),\n          (this.image = t),\n          (this.mipmaps = []),\n          (this.mapping = e),\n          (this.wrapS = n),\n          (this.wrapT = i),\n          (this.magFilter = r),\n          (this.minFilter = s),\n          (this.anisotropy = l),\n          (this.format = a),\n          (this.internalFormat = null),\n          (this.type = o),\n          (this.offset = new yt(0, 0)),\n          (this.repeat = new yt(1, 1)),\n          (this.center = new yt(0, 0)),\n          (this.rotation = 0),\n          (this.matrixAutoUpdate = !0),\n          (this.matrix = new xt()),\n          (this.generateMipmaps = !0),\n          (this.premultiplyAlpha = !1),\n          (this.flipY = !0),\n          (this.unpackAlignment = 4),\n          (this.encoding = c),\n          (this.userData = {}),\n          (this.version = 0),\n          (this.onUpdate = null),\n          (this.isRenderTargetTexture = !1);\n      }\n      updateMatrix() {\n        this.matrix.setUvTransform(\n          this.offset.x,\n          this.offset.y,\n          this.repeat.x,\n          this.repeat.y,\n          this.rotation,\n          this.center.x,\n          this.center.y\n        );\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return (\n          (this.name = t.name),\n          (this.image = t.image),\n          (this.mipmaps = t.mipmaps.slice(0)),\n          (this.mapping = t.mapping),\n          (this.wrapS = t.wrapS),\n          (this.wrapT = t.wrapT),\n          (this.magFilter = t.magFilter),\n          (this.minFilter = t.minFilter),\n          (this.anisotropy = t.anisotropy),\n          (this.format = t.format),\n          (this.internalFormat = t.internalFormat),\n          (this.type = t.type),\n          this.offset.copy(t.offset),\n          this.repeat.copy(t.repeat),\n          this.center.copy(t.center),\n          (this.rotation = t.rotation),\n          (this.matrixAutoUpdate = t.matrixAutoUpdate),\n          this.matrix.copy(t.matrix),\n          (this.generateMipmaps = t.generateMipmaps),\n          (this.premultiplyAlpha = t.premultiplyAlpha),\n          (this.flipY = t.flipY),\n          (this.unpackAlignment = t.unpackAlignment),\n          (this.encoding = t.encoding),\n          (this.userData = JSON.parse(JSON.stringify(t.userData))),\n          this\n        );\n      }\n      toJSON(t) {\n        const e = void 0 === t || \"string\" == typeof t;\n        if (!e && void 0 !== t.textures[this.uuid])\n          return t.textures[this.uuid];\n        const n = {\n          metadata: {\n            version: 4.5,\n            type: \"Texture\",\n            generator: \"Texture.toJSON\",\n          },\n          uuid: this.uuid,\n          name: this.name,\n          mapping: this.mapping,\n          repeat: [this.repeat.x, this.repeat.y],\n          offset: [this.offset.x, this.offset.y],\n          center: [this.center.x, this.center.y],\n          rotation: this.rotation,\n          wrap: [this.wrapS, this.wrapT],\n          format: this.format,\n          type: this.type,\n          encoding: this.encoding,\n          minFilter: this.minFilter,\n          magFilter: this.magFilter,\n          anisotropy: this.anisotropy,\n          flipY: this.flipY,\n          premultiplyAlpha: this.premultiplyAlpha,\n          unpackAlignment: this.unpackAlignment,\n        };\n        if (void 0 !== this.image) {\n          const i = this.image;\n          if (\n            (void 0 === i.uuid && (i.uuid = ht()),\n            !e && void 0 === t.images[i.uuid])\n          ) {\n            let e;\n            if (Array.isArray(i)) {\n              e = [];\n              for (let t = 0, n = i.length; t < n; t++)\n                i[t].isDataTexture ? e.push(Rt(i[t].image)) : e.push(Rt(i[t]));\n            } else e = Rt(i);\n            t.images[i.uuid] = { uuid: i.uuid, url: e };\n          }\n          n.image = i.uuid;\n        }\n        return (\n          \"{}\" !== JSON.stringify(this.userData) &&\n            (n.userData = this.userData),\n          e || (t.textures[this.uuid] = n),\n          n\n        );\n      }\n      dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n      transformUv(t) {\n        if (this.mapping !== i) return t;\n        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))\n          switch (this.wrapS) {\n            case h:\n              t.x = t.x - Math.floor(t.x);\n              break;\n            case u:\n              t.x = t.x < 0 ? 0 : 1;\n              break;\n            case d:\n              1 === Math.abs(Math.floor(t.x) % 2)\n                ? (t.x = Math.ceil(t.x) - t.x)\n                : (t.x = t.x - Math.floor(t.x));\n          }\n        if (t.y < 0 || t.y > 1)\n          switch (this.wrapT) {\n            case h:\n              t.y = t.y - Math.floor(t.y);\n              break;\n            case u:\n              t.y = t.y < 0 ? 0 : 1;\n              break;\n            case d:\n              1 === Math.abs(Math.floor(t.y) % 2)\n                ? (t.y = Math.ceil(t.y) - t.y)\n                : (t.y = t.y - Math.floor(t.y));\n          }\n        return this.flipY && (t.y = 1 - t.y), t;\n      }\n      set needsUpdate(t) {\n        !0 === t && this.version++;\n      }\n    }\n    function Rt(t) {\n      return (\"undefined\" != typeof HTMLImageElement &&\n        t instanceof HTMLImageElement) ||\n        (\"undefined\" != typeof HTMLCanvasElement &&\n          t instanceof HTMLCanvasElement) ||\n        (\"undefined\" != typeof ImageBitmap && t instanceof ImageBitmap)\n        ? Et.getDataURL(t)\n        : t.data\n        ? {\n            data: Array.prototype.slice.call(t.data),\n            width: t.width,\n            height: t.height,\n            type: t.data.constructor.name,\n          }\n        : (console.warn(\"THREE.Texture: Unable to serialize Texture.\"), {});\n    }\n    (Lt.DEFAULT_IMAGE = void 0),\n      (Lt.DEFAULT_MAPPING = i),\n      (Lt.prototype.isTexture = !0);\n    class Ct {\n      constructor(t = 0, e = 0, n = 0, i = 1) {\n        (this.x = t), (this.y = e), (this.z = n), (this.w = i);\n      }\n      get width() {\n        return this.z;\n      }\n      set width(t) {\n        this.z = t;\n      }\n      get height() {\n        return this.w;\n      }\n      set height(t) {\n        this.w = t;\n      }\n      set(t, e, n, i) {\n        return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;\n      }\n      setScalar(t) {\n        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;\n      }\n      setX(t) {\n        return (this.x = t), this;\n      }\n      setY(t) {\n        return (this.y = t), this;\n      }\n      setZ(t) {\n        return (this.z = t), this;\n      }\n      setW(t) {\n        return (this.w = t), this;\n      }\n      setComponent(t, e) {\n        switch (t) {\n          case 0:\n            this.x = e;\n            break;\n          case 1:\n            this.y = e;\n            break;\n          case 2:\n            this.z = e;\n            break;\n          case 3:\n            this.w = e;\n            break;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n        return this;\n      }\n      getComponent(t) {\n        switch (t) {\n          case 0:\n            return this.x;\n          case 1:\n            return this.y;\n          case 2:\n            return this.z;\n          case 3:\n            return this.w;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n      }\n      clone() {\n        return new this.constructor(this.x, this.y, this.z, this.w);\n      }\n      copy(t) {\n        return (\n          (this.x = t.x),\n          (this.y = t.y),\n          (this.z = t.z),\n          (this.w = void 0 !== t.w ? t.w : 1),\n          this\n        );\n      }\n      add(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"\n            ),\n            this.addVectors(t, e))\n          : ((this.x += t.x),\n            (this.y += t.y),\n            (this.z += t.z),\n            (this.w += t.w),\n            this);\n      }\n      addScalar(t) {\n        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;\n      }\n      addVectors(t, e) {\n        return (\n          (this.x = t.x + e.x),\n          (this.y = t.y + e.y),\n          (this.z = t.z + e.z),\n          (this.w = t.w + e.w),\n          this\n        );\n      }\n      addScaledVector(t, e) {\n        return (\n          (this.x += t.x * e),\n          (this.y += t.y * e),\n          (this.z += t.z * e),\n          (this.w += t.w * e),\n          this\n        );\n      }\n      sub(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"\n            ),\n            this.subVectors(t, e))\n          : ((this.x -= t.x),\n            (this.y -= t.y),\n            (this.z -= t.z),\n            (this.w -= t.w),\n            this);\n      }\n      subScalar(t) {\n        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;\n      }\n      subVectors(t, e) {\n        return (\n          (this.x = t.x - e.x),\n          (this.y = t.y - e.y),\n          (this.z = t.z - e.z),\n          (this.w = t.w - e.w),\n          this\n        );\n      }\n      multiply(t) {\n        return (\n          (this.x *= t.x),\n          (this.y *= t.y),\n          (this.z *= t.z),\n          (this.w *= t.w),\n          this\n        );\n      }\n      multiplyScalar(t) {\n        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;\n      }\n      applyMatrix4(t) {\n        const e = this.x,\n          n = this.y,\n          i = this.z,\n          r = this.w,\n          s = t.elements;\n        return (\n          (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),\n          (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),\n          (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),\n          (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),\n          this\n        );\n      }\n      divideScalar(t) {\n        return this.multiplyScalar(1 / t);\n      }\n      setAxisAngleFromQuaternion(t) {\n        this.w = 2 * Math.acos(t.w);\n        const e = Math.sqrt(1 - t.w * t.w);\n        return (\n          e < 1e-4\n            ? ((this.x = 1), (this.y = 0), (this.z = 0))\n            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),\n          this\n        );\n      }\n      setAxisAngleFromRotationMatrix(t) {\n        let e, n, i, r;\n        const s = 0.01,\n          a = 0.1,\n          o = t.elements,\n          l = o[0],\n          c = o[4],\n          h = o[8],\n          u = o[1],\n          d = o[5],\n          p = o[9],\n          m = o[2],\n          f = o[6],\n          g = o[10];\n        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {\n          if (\n            Math.abs(c + u) < a &&\n            Math.abs(h + m) < a &&\n            Math.abs(p + f) < a &&\n            Math.abs(l + d + g - 3) < a\n          )\n            return this.set(1, 0, 0, 0), this;\n          e = Math.PI;\n          const t = (l + 1) / 2,\n            o = (d + 1) / 2,\n            v = (g + 1) / 2,\n            y = (c + u) / 4,\n            x = (h + m) / 4,\n            _ = (p + f) / 4;\n          return (\n            t > o && t > v\n              ? t < s\n                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))\n                : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))\n              : o > v\n              ? o < s\n                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))\n                : ((i = Math.sqrt(o)), (n = y / i), (r = _ / i))\n              : v < s\n              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))\n              : ((r = Math.sqrt(v)), (n = x / r), (i = _ / r)),\n            this.set(n, i, r, e),\n            this\n          );\n        }\n        let v = Math.sqrt(\n          (f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c)\n        );\n        return (\n          Math.abs(v) < 0.001 && (v = 1),\n          (this.x = (f - p) / v),\n          (this.y = (h - m) / v),\n          (this.z = (u - c) / v),\n          (this.w = Math.acos((l + d + g - 1) / 2)),\n          this\n        );\n      }\n      min(t) {\n        return (\n          (this.x = Math.min(this.x, t.x)),\n          (this.y = Math.min(this.y, t.y)),\n          (this.z = Math.min(this.z, t.z)),\n          (this.w = Math.min(this.w, t.w)),\n          this\n        );\n      }\n      max(t) {\n        return (\n          (this.x = Math.max(this.x, t.x)),\n          (this.y = Math.max(this.y, t.y)),\n          (this.z = Math.max(this.z, t.z)),\n          (this.w = Math.max(this.w, t.w)),\n          this\n        );\n      }\n      clamp(t, e) {\n        return (\n          (this.x = Math.max(t.x, Math.min(e.x, this.x))),\n          (this.y = Math.max(t.y, Math.min(e.y, this.y))),\n          (this.z = Math.max(t.z, Math.min(e.z, this.z))),\n          (this.w = Math.max(t.w, Math.min(e.w, this.w))),\n          this\n        );\n      }\n      clampScalar(t, e) {\n        return (\n          (this.x = Math.max(t, Math.min(e, this.x))),\n          (this.y = Math.max(t, Math.min(e, this.y))),\n          (this.z = Math.max(t, Math.min(e, this.z))),\n          (this.w = Math.max(t, Math.min(e, this.w))),\n          this\n        );\n      }\n      clampLength(t, e) {\n        const n = this.length();\n        return this.divideScalar(n || 1).multiplyScalar(\n          Math.max(t, Math.min(e, n))\n        );\n      }\n      floor() {\n        return (\n          (this.x = Math.floor(this.x)),\n          (this.y = Math.floor(this.y)),\n          (this.z = Math.floor(this.z)),\n          (this.w = Math.floor(this.w)),\n          this\n        );\n      }\n      ceil() {\n        return (\n          (this.x = Math.ceil(this.x)),\n          (this.y = Math.ceil(this.y)),\n          (this.z = Math.ceil(this.z)),\n          (this.w = Math.ceil(this.w)),\n          this\n        );\n      }\n      round() {\n        return (\n          (this.x = Math.round(this.x)),\n          (this.y = Math.round(this.y)),\n          (this.z = Math.round(this.z)),\n          (this.w = Math.round(this.w)),\n          this\n        );\n      }\n      roundToZero() {\n        return (\n          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),\n          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),\n          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),\n          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),\n          this\n        );\n      }\n      negate() {\n        return (\n          (this.x = -this.x),\n          (this.y = -this.y),\n          (this.z = -this.z),\n          (this.w = -this.w),\n          this\n        );\n      }\n      dot(t) {\n        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;\n      }\n      lengthSq() {\n        return (\n          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w\n        );\n      }\n      length() {\n        return Math.sqrt(\n          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w\n        );\n      }\n      manhattanLength() {\n        return (\n          Math.abs(this.x) +\n          Math.abs(this.y) +\n          Math.abs(this.z) +\n          Math.abs(this.w)\n        );\n      }\n      normalize() {\n        return this.divideScalar(this.length() || 1);\n      }\n      setLength(t) {\n        return this.normalize().multiplyScalar(t);\n      }\n      lerp(t, e) {\n        return (\n          (this.x += (t.x - this.x) * e),\n          (this.y += (t.y - this.y) * e),\n          (this.z += (t.z - this.z) * e),\n          (this.w += (t.w - this.w) * e),\n          this\n        );\n      }\n      lerpVectors(t, e, n) {\n        return (\n          (this.x = t.x + (e.x - t.x) * n),\n          (this.y = t.y + (e.y - t.y) * n),\n          (this.z = t.z + (e.z - t.z) * n),\n          (this.w = t.w + (e.w - t.w) * n),\n          this\n        );\n      }\n      equals(t) {\n        return (\n          t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w\n        );\n      }\n      fromArray(t, e = 0) {\n        return (\n          (this.x = t[e]),\n          (this.y = t[e + 1]),\n          (this.z = t[e + 2]),\n          (this.w = t[e + 3]),\n          this\n        );\n      }\n      toArray(t = [], e = 0) {\n        return (\n          (t[e] = this.x),\n          (t[e + 1] = this.y),\n          (t[e + 2] = this.z),\n          (t[e + 3] = this.w),\n          t\n        );\n      }\n      fromBufferAttribute(t, e, n) {\n        return (\n          void 0 !== n &&\n            console.warn(\n              \"THREE.Vector4: offset has been removed from .fromBufferAttribute().\"\n            ),\n          (this.x = t.getX(e)),\n          (this.y = t.getY(e)),\n          (this.z = t.getZ(e)),\n          (this.w = t.getW(e)),\n          this\n        );\n      }\n      random() {\n        return (\n          (this.x = Math.random()),\n          (this.y = Math.random()),\n          (this.z = Math.random()),\n          (this.w = Math.random()),\n          this\n        );\n      }\n      *[Symbol.iterator]() {\n        yield this.x, yield this.y, yield this.z, yield this.w;\n      }\n    }\n    Ct.prototype.isVector4 = !0;\n    class Pt extends rt {\n      constructor(t, e, n = {}) {\n        super(),\n          (this.width = t),\n          (this.height = e),\n          (this.depth = 1),\n          (this.scissor = new Ct(0, 0, t, e)),\n          (this.scissorTest = !1),\n          (this.viewport = new Ct(0, 0, t, e)),\n          (this.texture = new Lt(\n            void 0,\n            n.mapping,\n            n.wrapS,\n            n.wrapT,\n            n.magFilter,\n            n.minFilter,\n            n.format,\n            n.type,\n            n.anisotropy,\n            n.encoding\n          )),\n          (this.texture.isRenderTargetTexture = !0),\n          (this.texture.image = { width: t, height: e, depth: 1 }),\n          (this.texture.generateMipmaps =\n            void 0 !== n.generateMipmaps && n.generateMipmaps),\n          (this.texture.internalFormat =\n            void 0 !== n.internalFormat ? n.internalFormat : null),\n          (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : g),\n          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),\n          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),\n          (this.depthTexture =\n            void 0 !== n.depthTexture ? n.depthTexture : null);\n      }\n      setTexture(t) {\n        (t.image = {\n          width: this.width,\n          height: this.height,\n          depth: this.depth,\n        }),\n          (this.texture = t);\n      }\n      setSize(t, e, n = 1) {\n        (this.width === t && this.height === e && this.depth === n) ||\n          ((this.width = t),\n          (this.height = e),\n          (this.depth = n),\n          (this.texture.image.width = t),\n          (this.texture.image.height = e),\n          (this.texture.image.depth = n),\n          this.dispose()),\n          this.viewport.set(0, 0, t, e),\n          this.scissor.set(0, 0, t, e);\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return (\n          (this.width = t.width),\n          (this.height = t.height),\n          (this.depth = t.depth),\n          this.viewport.copy(t.viewport),\n          (this.texture = t.texture.clone()),\n          (this.texture.image = { ...this.texture.image }),\n          (this.depthBuffer = t.depthBuffer),\n          (this.stencilBuffer = t.stencilBuffer),\n          (this.depthTexture = t.depthTexture),\n          this\n        );\n      }\n      dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n    }\n    Pt.prototype.isWebGLRenderTarget = !0;\n    class It extends Pt {\n      constructor(t, e, n) {\n        super(t, e);\n        const i = this.texture;\n        this.texture = [];\n        for (let t = 0; t < n; t++) this.texture[t] = i.clone();\n      }\n      setSize(t, e, n = 1) {\n        if (this.width !== t || this.height !== e || this.depth !== n) {\n          (this.width = t), (this.height = e), (this.depth = n);\n          for (let i = 0, r = this.texture.length; i < r; i++)\n            (this.texture[i].image.width = t),\n              (this.texture[i].image.height = e),\n              (this.texture[i].image.depth = n);\n          this.dispose();\n        }\n        return (\n          this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this\n        );\n      }\n      copy(t) {\n        this.dispose(),\n          (this.width = t.width),\n          (this.height = t.height),\n          (this.depth = t.depth),\n          this.viewport.set(0, 0, this.width, this.height),\n          this.scissor.set(0, 0, this.width, this.height),\n          (this.depthBuffer = t.depthBuffer),\n          (this.stencilBuffer = t.stencilBuffer),\n          (this.depthTexture = t.depthTexture),\n          (this.texture.length = 0);\n        for (let e = 0, n = t.texture.length; e < n; e++)\n          this.texture[e] = t.texture[e].clone();\n        return this;\n      }\n    }\n    It.prototype.isWebGLMultipleRenderTargets = !0;\n    class Dt extends Pt {\n      constructor(t, e, n) {\n        super(t, e, n), (this.samples = 4);\n      }\n      copy(t) {\n        return super.copy.call(this, t), (this.samples = t.samples), this;\n      }\n    }\n    Dt.prototype.isWebGLMultisampleRenderTarget = !0;\n    class Nt {\n      constructor(t = 0, e = 0, n = 0, i = 1) {\n        (this._x = t), (this._y = e), (this._z = n), (this._w = i);\n      }\n      static slerp(t, e, n, i) {\n        return (\n          console.warn(\n            \"THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.\"\n          ),\n          n.slerpQuaternions(t, e, i)\n        );\n      }\n      static slerpFlat(t, e, n, i, r, s, a) {\n        let o = n[i + 0],\n          l = n[i + 1],\n          c = n[i + 2],\n          h = n[i + 3];\n        const u = r[s + 0],\n          d = r[s + 1],\n          p = r[s + 2],\n          m = r[s + 3];\n        if (0 === a)\n          return (\n            (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h)\n          );\n        if (1 === a)\n          return (\n            (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = m)\n          );\n        if (h !== m || o !== u || l !== d || c !== p) {\n          let t = 1 - a;\n          const e = o * u + l * d + c * p + h * m,\n            n = e >= 0 ? 1 : -1,\n            i = 1 - e * e;\n          if (i > Number.EPSILON) {\n            const r = Math.sqrt(i),\n              s = Math.atan2(r, e * n);\n            (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);\n          }\n          const r = a * n;\n          if (\n            ((o = o * t + u * r),\n            (l = l * t + d * r),\n            (c = c * t + p * r),\n            (h = h * t + m * r),\n            t === 1 - a)\n          ) {\n            const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);\n            (o *= t), (l *= t), (c *= t), (h *= t);\n          }\n        }\n        (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);\n      }\n      static multiplyQuaternionsFlat(t, e, n, i, r, s) {\n        const a = n[i],\n          o = n[i + 1],\n          l = n[i + 2],\n          c = n[i + 3],\n          h = r[s],\n          u = r[s + 1],\n          d = r[s + 2],\n          p = r[s + 3];\n        return (\n          (t[e] = a * p + c * h + o * d - l * u),\n          (t[e + 1] = o * p + c * u + l * h - a * d),\n          (t[e + 2] = l * p + c * d + a * u - o * h),\n          (t[e + 3] = c * p - a * h - o * u - l * d),\n          t\n        );\n      }\n      get x() {\n        return this._x;\n      }\n      set x(t) {\n        (this._x = t), this._onChangeCallback();\n      }\n      get y() {\n        return this._y;\n      }\n      set y(t) {\n        (this._y = t), this._onChangeCallback();\n      }\n      get z() {\n        return this._z;\n      }\n      set z(t) {\n        (this._z = t), this._onChangeCallback();\n      }\n      get w() {\n        return this._w;\n      }\n      set w(t) {\n        (this._w = t), this._onChangeCallback();\n      }\n      set(t, e, n, i) {\n        return (\n          (this._x = t),\n          (this._y = e),\n          (this._z = n),\n          (this._w = i),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      clone() {\n        return new this.constructor(this._x, this._y, this._z, this._w);\n      }\n      copy(t) {\n        return (\n          (this._x = t.x),\n          (this._y = t.y),\n          (this._z = t.z),\n          (this._w = t.w),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      setFromEuler(t, e) {\n        if (!t || !t.isEuler)\n          throw new Error(\n            \"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\"\n          );\n        const n = t._x,\n          i = t._y,\n          r = t._z,\n          s = t._order,\n          a = Math.cos,\n          o = Math.sin,\n          l = a(n / 2),\n          c = a(i / 2),\n          h = a(r / 2),\n          u = o(n / 2),\n          d = o(i / 2),\n          p = o(r / 2);\n        switch (s) {\n          case \"XYZ\":\n            (this._x = u * c * h + l * d * p),\n              (this._y = l * d * h - u * c * p),\n              (this._z = l * c * p + u * d * h),\n              (this._w = l * c * h - u * d * p);\n            break;\n          case \"YXZ\":\n            (this._x = u * c * h + l * d * p),\n              (this._y = l * d * h - u * c * p),\n              (this._z = l * c * p - u * d * h),\n              (this._w = l * c * h + u * d * p);\n            break;\n          case \"ZXY\":\n            (this._x = u * c * h - l * d * p),\n              (this._y = l * d * h + u * c * p),\n              (this._z = l * c * p + u * d * h),\n              (this._w = l * c * h - u * d * p);\n            break;\n          case \"ZYX\":\n            (this._x = u * c * h - l * d * p),\n              (this._y = l * d * h + u * c * p),\n              (this._z = l * c * p - u * d * h),\n              (this._w = l * c * h + u * d * p);\n            break;\n          case \"YZX\":\n            (this._x = u * c * h + l * d * p),\n              (this._y = l * d * h + u * c * p),\n              (this._z = l * c * p - u * d * h),\n              (this._w = l * c * h - u * d * p);\n            break;\n          case \"XZY\":\n            (this._x = u * c * h - l * d * p),\n              (this._y = l * d * h - u * c * p),\n              (this._z = l * c * p + u * d * h),\n              (this._w = l * c * h + u * d * p);\n            break;\n          default:\n            console.warn(\n              \"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" +\n                s\n            );\n        }\n        return !1 !== e && this._onChangeCallback(), this;\n      }\n      setFromAxisAngle(t, e) {\n        const n = e / 2,\n          i = Math.sin(n);\n        return (\n          (this._x = t.x * i),\n          (this._y = t.y * i),\n          (this._z = t.z * i),\n          (this._w = Math.cos(n)),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      setFromRotationMatrix(t) {\n        const e = t.elements,\n          n = e[0],\n          i = e[4],\n          r = e[8],\n          s = e[1],\n          a = e[5],\n          o = e[9],\n          l = e[2],\n          c = e[6],\n          h = e[10],\n          u = n + a + h;\n        if (u > 0) {\n          const t = 0.5 / Math.sqrt(u + 1);\n          (this._w = 0.25 / t),\n            (this._x = (c - o) * t),\n            (this._y = (r - l) * t),\n            (this._z = (s - i) * t);\n        } else if (n > a && n > h) {\n          const t = 2 * Math.sqrt(1 + n - a - h);\n          (this._w = (c - o) / t),\n            (this._x = 0.25 * t),\n            (this._y = (i + s) / t),\n            (this._z = (r + l) / t);\n        } else if (a > h) {\n          const t = 2 * Math.sqrt(1 + a - n - h);\n          (this._w = (r - l) / t),\n            (this._x = (i + s) / t),\n            (this._y = 0.25 * t),\n            (this._z = (o + c) / t);\n        } else {\n          const t = 2 * Math.sqrt(1 + h - n - a);\n          (this._w = (s - i) / t),\n            (this._x = (r + l) / t),\n            (this._y = (o + c) / t),\n            (this._z = 0.25 * t);\n        }\n        return this._onChangeCallback(), this;\n      }\n      setFromUnitVectors(t, e) {\n        let n = t.dot(e) + 1;\n        return (\n          n < Number.EPSILON\n            ? ((n = 0),\n              Math.abs(t.x) > Math.abs(t.z)\n                ? ((this._x = -t.y),\n                  (this._y = t.x),\n                  (this._z = 0),\n                  (this._w = n))\n                : ((this._x = 0),\n                  (this._y = -t.z),\n                  (this._z = t.y),\n                  (this._w = n)))\n            : ((this._x = t.y * e.z - t.z * e.y),\n              (this._y = t.z * e.x - t.x * e.z),\n              (this._z = t.x * e.y - t.y * e.x),\n              (this._w = n)),\n          this.normalize()\n        );\n      }\n      angleTo(t) {\n        return 2 * Math.acos(Math.abs(ut(this.dot(t), -1, 1)));\n      }\n      rotateTowards(t, e) {\n        const n = this.angleTo(t);\n        if (0 === n) return this;\n        const i = Math.min(1, e / n);\n        return this.slerp(t, i), this;\n      }\n      identity() {\n        return this.set(0, 0, 0, 1);\n      }\n      invert() {\n        return this.conjugate();\n      }\n      conjugate() {\n        return (\n          (this._x *= -1),\n          (this._y *= -1),\n          (this._z *= -1),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      dot(t) {\n        return (\n          this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w\n        );\n      }\n      lengthSq() {\n        return (\n          this._x * this._x +\n          this._y * this._y +\n          this._z * this._z +\n          this._w * this._w\n        );\n      }\n      length() {\n        return Math.sqrt(\n          this._x * this._x +\n            this._y * this._y +\n            this._z * this._z +\n            this._w * this._w\n        );\n      }\n      normalize() {\n        let t = this.length();\n        return (\n          0 === t\n            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))\n            : ((t = 1 / t),\n              (this._x = this._x * t),\n              (this._y = this._y * t),\n              (this._z = this._z * t),\n              (this._w = this._w * t)),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      multiply(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"\n            ),\n            this.multiplyQuaternions(t, e))\n          : this.multiplyQuaternions(this, t);\n      }\n      premultiply(t) {\n        return this.multiplyQuaternions(t, this);\n      }\n      multiplyQuaternions(t, e) {\n        const n = t._x,\n          i = t._y,\n          r = t._z,\n          s = t._w,\n          a = e._x,\n          o = e._y,\n          l = e._z,\n          c = e._w;\n        return (\n          (this._x = n * c + s * a + i * l - r * o),\n          (this._y = i * c + s * o + r * a - n * l),\n          (this._z = r * c + s * l + n * o - i * a),\n          (this._w = s * c - n * a - i * o - r * l),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      slerp(t, e) {\n        if (0 === e) return this;\n        if (1 === e) return this.copy(t);\n        const n = this._x,\n          i = this._y,\n          r = this._z,\n          s = this._w;\n        let a = s * t._w + n * t._x + i * t._y + r * t._z;\n        if (\n          (a < 0\n            ? ((this._w = -t._w),\n              (this._x = -t._x),\n              (this._y = -t._y),\n              (this._z = -t._z),\n              (a = -a))\n            : this.copy(t),\n          a >= 1)\n        )\n          return (\n            (this._w = s), (this._x = n), (this._y = i), (this._z = r), this\n          );\n        const o = 1 - a * a;\n        if (o <= Number.EPSILON) {\n          const t = 1 - e;\n          return (\n            (this._w = t * s + e * this._w),\n            (this._x = t * n + e * this._x),\n            (this._y = t * i + e * this._y),\n            (this._z = t * r + e * this._z),\n            this.normalize(),\n            this._onChangeCallback(),\n            this\n          );\n        }\n        const l = Math.sqrt(o),\n          c = Math.atan2(l, a),\n          h = Math.sin((1 - e) * c) / l,\n          u = Math.sin(e * c) / l;\n        return (\n          (this._w = s * h + this._w * u),\n          (this._x = n * h + this._x * u),\n          (this._y = i * h + this._y * u),\n          (this._z = r * h + this._z * u),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      slerpQuaternions(t, e, n) {\n        this.copy(t).slerp(e, n);\n      }\n      random() {\n        const t = Math.random(),\n          e = Math.sqrt(1 - t),\n          n = Math.sqrt(t),\n          i = 2 * Math.PI * Math.random(),\n          r = 2 * Math.PI * Math.random();\n        return this.set(\n          e * Math.cos(i),\n          n * Math.sin(r),\n          n * Math.cos(r),\n          e * Math.sin(i)\n        );\n      }\n      equals(t) {\n        return (\n          t._x === this._x &&\n          t._y === this._y &&\n          t._z === this._z &&\n          t._w === this._w\n        );\n      }\n      fromArray(t, e = 0) {\n        return (\n          (this._x = t[e]),\n          (this._y = t[e + 1]),\n          (this._z = t[e + 2]),\n          (this._w = t[e + 3]),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      toArray(t = [], e = 0) {\n        return (\n          (t[e] = this._x),\n          (t[e + 1] = this._y),\n          (t[e + 2] = this._z),\n          (t[e + 3] = this._w),\n          t\n        );\n      }\n      fromBufferAttribute(t, e) {\n        return (\n          (this._x = t.getX(e)),\n          (this._y = t.getY(e)),\n          (this._z = t.getZ(e)),\n          (this._w = t.getW(e)),\n          this\n        );\n      }\n      _onChange(t) {\n        return (this._onChangeCallback = t), this;\n      }\n      _onChangeCallback() {}\n    }\n    Nt.prototype.isQuaternion = !0;\n    class zt {\n      constructor(t = 0, e = 0, n = 0) {\n        (this.x = t), (this.y = e), (this.z = n);\n      }\n      set(t, e, n) {\n        return (\n          void 0 === n && (n = this.z),\n          (this.x = t),\n          (this.y = e),\n          (this.z = n),\n          this\n        );\n      }\n      setScalar(t) {\n        return (this.x = t), (this.y = t), (this.z = t), this;\n      }\n      setX(t) {\n        return (this.x = t), this;\n      }\n      setY(t) {\n        return (this.y = t), this;\n      }\n      setZ(t) {\n        return (this.z = t), this;\n      }\n      setComponent(t, e) {\n        switch (t) {\n          case 0:\n            this.x = e;\n            break;\n          case 1:\n            this.y = e;\n            break;\n          case 2:\n            this.z = e;\n            break;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n        return this;\n      }\n      getComponent(t) {\n        switch (t) {\n          case 0:\n            return this.x;\n          case 1:\n            return this.y;\n          case 2:\n            return this.z;\n          default:\n            throw new Error(\"index is out of range: \" + t);\n        }\n      }\n      clone() {\n        return new this.constructor(this.x, this.y, this.z);\n      }\n      copy(t) {\n        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;\n      }\n      add(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"\n            ),\n            this.addVectors(t, e))\n          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);\n      }\n      addScalar(t) {\n        return (this.x += t), (this.y += t), (this.z += t), this;\n      }\n      addVectors(t, e) {\n        return (\n          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this\n        );\n      }\n      addScaledVector(t, e) {\n        return (\n          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this\n        );\n      }\n      sub(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"\n            ),\n            this.subVectors(t, e))\n          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);\n      }\n      subScalar(t) {\n        return (this.x -= t), (this.y -= t), (this.z -= t), this;\n      }\n      subVectors(t, e) {\n        return (\n          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this\n        );\n      }\n      multiply(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"\n            ),\n            this.multiplyVectors(t, e))\n          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);\n      }\n      multiplyScalar(t) {\n        return (this.x *= t), (this.y *= t), (this.z *= t), this;\n      }\n      multiplyVectors(t, e) {\n        return (\n          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this\n        );\n      }\n      applyEuler(t) {\n        return (\n          (t && t.isEuler) ||\n            console.error(\n              \"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\"\n            ),\n          this.applyQuaternion(Ft.setFromEuler(t))\n        );\n      }\n      applyAxisAngle(t, e) {\n        return this.applyQuaternion(Ft.setFromAxisAngle(t, e));\n      }\n      applyMatrix3(t) {\n        const e = this.x,\n          n = this.y,\n          i = this.z,\n          r = t.elements;\n        return (\n          (this.x = r[0] * e + r[3] * n + r[6] * i),\n          (this.y = r[1] * e + r[4] * n + r[7] * i),\n          (this.z = r[2] * e + r[5] * n + r[8] * i),\n          this\n        );\n      }\n      applyNormalMatrix(t) {\n        return this.applyMatrix3(t).normalize();\n      }\n      applyMatrix4(t) {\n        const e = this.x,\n          n = this.y,\n          i = this.z,\n          r = t.elements,\n          s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);\n        return (\n          (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),\n          (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),\n          (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),\n          this\n        );\n      }\n      applyQuaternion(t) {\n        const e = this.x,\n          n = this.y,\n          i = this.z,\n          r = t.x,\n          s = t.y,\n          a = t.z,\n          o = t.w,\n          l = o * e + s * i - a * n,\n          c = o * n + a * e - r * i,\n          h = o * i + r * n - s * e,\n          u = -r * e - s * n - a * i;\n        return (\n          (this.x = l * o + u * -r + c * -a - h * -s),\n          (this.y = c * o + u * -s + h * -r - l * -a),\n          (this.z = h * o + u * -a + l * -s - c * -r),\n          this\n        );\n      }\n      project(t) {\n        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(\n          t.projectionMatrix\n        );\n      }\n      unproject(t) {\n        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(\n          t.matrixWorld\n        );\n      }\n      transformDirection(t) {\n        const e = this.x,\n          n = this.y,\n          i = this.z,\n          r = t.elements;\n        return (\n          (this.x = r[0] * e + r[4] * n + r[8] * i),\n          (this.y = r[1] * e + r[5] * n + r[9] * i),\n          (this.z = r[2] * e + r[6] * n + r[10] * i),\n          this.normalize()\n        );\n      }\n      divide(t) {\n        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;\n      }\n      divideScalar(t) {\n        return this.multiplyScalar(1 / t);\n      }\n      min(t) {\n        return (\n          (this.x = Math.min(this.x, t.x)),\n          (this.y = Math.min(this.y, t.y)),\n          (this.z = Math.min(this.z, t.z)),\n          this\n        );\n      }\n      max(t) {\n        return (\n          (this.x = Math.max(this.x, t.x)),\n          (this.y = Math.max(this.y, t.y)),\n          (this.z = Math.max(this.z, t.z)),\n          this\n        );\n      }\n      clamp(t, e) {\n        return (\n          (this.x = Math.max(t.x, Math.min(e.x, this.x))),\n          (this.y = Math.max(t.y, Math.min(e.y, this.y))),\n          (this.z = Math.max(t.z, Math.min(e.z, this.z))),\n          this\n        );\n      }\n      clampScalar(t, e) {\n        return (\n          (this.x = Math.max(t, Math.min(e, this.x))),\n          (this.y = Math.max(t, Math.min(e, this.y))),\n          (this.z = Math.max(t, Math.min(e, this.z))),\n          this\n        );\n      }\n      clampLength(t, e) {\n        const n = this.length();\n        return this.divideScalar(n || 1).multiplyScalar(\n          Math.max(t, Math.min(e, n))\n        );\n      }\n      floor() {\n        return (\n          (this.x = Math.floor(this.x)),\n          (this.y = Math.floor(this.y)),\n          (this.z = Math.floor(this.z)),\n          this\n        );\n      }\n      ceil() {\n        return (\n          (this.x = Math.ceil(this.x)),\n          (this.y = Math.ceil(this.y)),\n          (this.z = Math.ceil(this.z)),\n          this\n        );\n      }\n      round() {\n        return (\n          (this.x = Math.round(this.x)),\n          (this.y = Math.round(this.y)),\n          (this.z = Math.round(this.z)),\n          this\n        );\n      }\n      roundToZero() {\n        return (\n          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),\n          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),\n          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),\n          this\n        );\n      }\n      negate() {\n        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;\n      }\n      dot(t) {\n        return this.x * t.x + this.y * t.y + this.z * t.z;\n      }\n      lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n      }\n      length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n      }\n      manhattanLength() {\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n      }\n      normalize() {\n        return this.divideScalar(this.length() || 1);\n      }\n      setLength(t) {\n        return this.normalize().multiplyScalar(t);\n      }\n      lerp(t, e) {\n        return (\n          (this.x += (t.x - this.x) * e),\n          (this.y += (t.y - this.y) * e),\n          (this.z += (t.z - this.z) * e),\n          this\n        );\n      }\n      lerpVectors(t, e, n) {\n        return (\n          (this.x = t.x + (e.x - t.x) * n),\n          (this.y = t.y + (e.y - t.y) * n),\n          (this.z = t.z + (e.z - t.z) * n),\n          this\n        );\n      }\n      cross(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"\n            ),\n            this.crossVectors(t, e))\n          : this.crossVectors(this, t);\n      }\n      crossVectors(t, e) {\n        const n = t.x,\n          i = t.y,\n          r = t.z,\n          s = e.x,\n          a = e.y,\n          o = e.z;\n        return (\n          (this.x = i * o - r * a),\n          (this.y = r * s - n * o),\n          (this.z = n * a - i * s),\n          this\n        );\n      }\n      projectOnVector(t) {\n        const e = t.lengthSq();\n        if (0 === e) return this.set(0, 0, 0);\n        const n = t.dot(this) / e;\n        return this.copy(t).multiplyScalar(n);\n      }\n      projectOnPlane(t) {\n        return Bt.copy(this).projectOnVector(t), this.sub(Bt);\n      }\n      reflect(t) {\n        return this.sub(Bt.copy(t).multiplyScalar(2 * this.dot(t)));\n      }\n      angleTo(t) {\n        const e = Math.sqrt(this.lengthSq() * t.lengthSq());\n        if (0 === e) return Math.PI / 2;\n        const n = this.dot(t) / e;\n        return Math.acos(ut(n, -1, 1));\n      }\n      distanceTo(t) {\n        return Math.sqrt(this.distanceToSquared(t));\n      }\n      distanceToSquared(t) {\n        const e = this.x - t.x,\n          n = this.y - t.y,\n          i = this.z - t.z;\n        return e * e + n * n + i * i;\n      }\n      manhattanDistanceTo(t) {\n        return (\n          Math.abs(this.x - t.x) +\n          Math.abs(this.y - t.y) +\n          Math.abs(this.z - t.z)\n        );\n      }\n      setFromSpherical(t) {\n        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);\n      }\n      setFromSphericalCoords(t, e, n) {\n        const i = Math.sin(e) * t;\n        return (\n          (this.x = i * Math.sin(n)),\n          (this.y = Math.cos(e) * t),\n          (this.z = i * Math.cos(n)),\n          this\n        );\n      }\n      setFromCylindrical(t) {\n        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);\n      }\n      setFromCylindricalCoords(t, e, n) {\n        return (\n          (this.x = t * Math.sin(e)),\n          (this.y = n),\n          (this.z = t * Math.cos(e)),\n          this\n        );\n      }\n      setFromMatrixPosition(t) {\n        const e = t.elements;\n        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;\n      }\n      setFromMatrixScale(t) {\n        const e = this.setFromMatrixColumn(t, 0).length(),\n          n = this.setFromMatrixColumn(t, 1).length(),\n          i = this.setFromMatrixColumn(t, 2).length();\n        return (this.x = e), (this.y = n), (this.z = i), this;\n      }\n      setFromMatrixColumn(t, e) {\n        return this.fromArray(t.elements, 4 * e);\n      }\n      setFromMatrix3Column(t, e) {\n        return this.fromArray(t.elements, 3 * e);\n      }\n      equals(t) {\n        return t.x === this.x && t.y === this.y && t.z === this.z;\n      }\n      fromArray(t, e = 0) {\n        return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;\n      }\n      toArray(t = [], e = 0) {\n        return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;\n      }\n      fromBufferAttribute(t, e, n) {\n        return (\n          void 0 !== n &&\n            console.warn(\n              \"THREE.Vector3: offset has been removed from .fromBufferAttribute().\"\n            ),\n          (this.x = t.getX(e)),\n          (this.y = t.getY(e)),\n          (this.z = t.getZ(e)),\n          this\n        );\n      }\n      random() {\n        return (\n          (this.x = Math.random()),\n          (this.y = Math.random()),\n          (this.z = Math.random()),\n          this\n        );\n      }\n      randomDirection() {\n        const t = 2 * (Math.random() - 0.5),\n          e = Math.random() * Math.PI * 2,\n          n = Math.sqrt(1 - t ** 2);\n        return (\n          (this.x = n * Math.cos(e)),\n          (this.y = n * Math.sin(e)),\n          (this.z = t),\n          this\n        );\n      }\n      *[Symbol.iterator]() {\n        yield this.x, yield this.y, yield this.z;\n      }\n    }\n    zt.prototype.isVector3 = !0;\n    const Bt = new zt(),\n      Ft = new Nt();\n    class Ot {\n      constructor(\n        t = new zt(1 / 0, 1 / 0, 1 / 0),\n        e = new zt(-1 / 0, -1 / 0, -1 / 0)\n      ) {\n        (this.min = t), (this.max = e);\n      }\n      set(t, e) {\n        return this.min.copy(t), this.max.copy(e), this;\n      }\n      setFromArray(t) {\n        let e = 1 / 0,\n          n = 1 / 0,\n          i = 1 / 0,\n          r = -1 / 0,\n          s = -1 / 0,\n          a = -1 / 0;\n        for (let o = 0, l = t.length; o < l; o += 3) {\n          const l = t[o],\n            c = t[o + 1],\n            h = t[o + 2];\n          l < e && (e = l),\n            c < n && (n = c),\n            h < i && (i = h),\n            l > r && (r = l),\n            c > s && (s = c),\n            h > a && (a = h);\n        }\n        return this.min.set(e, n, i), this.max.set(r, s, a), this;\n      }\n      setFromBufferAttribute(t) {\n        let e = 1 / 0,\n          n = 1 / 0,\n          i = 1 / 0,\n          r = -1 / 0,\n          s = -1 / 0,\n          a = -1 / 0;\n        for (let o = 0, l = t.count; o < l; o++) {\n          const l = t.getX(o),\n            c = t.getY(o),\n            h = t.getZ(o);\n          l < e && (e = l),\n            c < n && (n = c),\n            h < i && (i = h),\n            l > r && (r = l),\n            c > s && (s = c),\n            h > a && (a = h);\n        }\n        return this.min.set(e, n, i), this.max.set(r, s, a), this;\n      }\n      setFromPoints(t) {\n        this.makeEmpty();\n        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);\n        return this;\n      }\n      setFromCenterAndSize(t, e) {\n        const n = Ht.copy(e).multiplyScalar(0.5);\n        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;\n      }\n      setFromObject(t) {\n        return this.makeEmpty(), this.expandByObject(t);\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return this.min.copy(t.min), this.max.copy(t.max), this;\n      }\n      makeEmpty() {\n        return (\n          (this.min.x = this.min.y = this.min.z = 1 / 0),\n          (this.max.x = this.max.y = this.max.z = -1 / 0),\n          this\n        );\n      }\n      isEmpty() {\n        return (\n          this.max.x < this.min.x ||\n          this.max.y < this.min.y ||\n          this.max.z < this.min.z\n        );\n      }\n      getCenter(t) {\n        return this.isEmpty()\n          ? t.set(0, 0, 0)\n          : t.addVectors(this.min, this.max).multiplyScalar(0.5);\n      }\n      getSize(t) {\n        return this.isEmpty()\n          ? t.set(0, 0, 0)\n          : t.subVectors(this.max, this.min);\n      }\n      expandByPoint(t) {\n        return this.min.min(t), this.max.max(t), this;\n      }\n      expandByVector(t) {\n        return this.min.sub(t), this.max.add(t), this;\n      }\n      expandByScalar(t) {\n        return this.min.addScalar(-t), this.max.addScalar(t), this;\n      }\n      expandByObject(t) {\n        t.updateWorldMatrix(!1, !1);\n        const e = t.geometry;\n        void 0 !== e &&\n          (null === e.boundingBox && e.computeBoundingBox(),\n          Gt.copy(e.boundingBox),\n          Gt.applyMatrix4(t.matrixWorld),\n          this.union(Gt));\n        const n = t.children;\n        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);\n        return this;\n      }\n      containsPoint(t) {\n        return !(\n          t.x < this.min.x ||\n          t.x > this.max.x ||\n          t.y < this.min.y ||\n          t.y > this.max.y ||\n          t.z < this.min.z ||\n          t.z > this.max.z\n        );\n      }\n      containsBox(t) {\n        return (\n          this.min.x <= t.min.x &&\n          t.max.x <= this.max.x &&\n          this.min.y <= t.min.y &&\n          t.max.y <= this.max.y &&\n          this.min.z <= t.min.z &&\n          t.max.z <= this.max.z\n        );\n      }\n      getParameter(t, e) {\n        return e.set(\n          (t.x - this.min.x) / (this.max.x - this.min.x),\n          (t.y - this.min.y) / (this.max.y - this.min.y),\n          (t.z - this.min.z) / (this.max.z - this.min.z)\n        );\n      }\n      intersectsBox(t) {\n        return !(\n          t.max.x < this.min.x ||\n          t.min.x > this.max.x ||\n          t.max.y < this.min.y ||\n          t.min.y > this.max.y ||\n          t.max.z < this.min.z ||\n          t.min.z > this.max.z\n        );\n      }\n      intersectsSphere(t) {\n        return (\n          this.clampPoint(t.center, Ht),\n          Ht.distanceToSquared(t.center) <= t.radius * t.radius\n        );\n      }\n      intersectsPlane(t) {\n        let e, n;\n        return (\n          t.normal.x > 0\n            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))\n            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),\n          t.normal.y > 0\n            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))\n            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),\n          t.normal.z > 0\n            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))\n            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),\n          e <= -t.constant && n >= -t.constant\n        );\n      }\n      intersectsTriangle(t) {\n        if (this.isEmpty()) return !1;\n        this.getCenter(Yt),\n          Jt.subVectors(this.max, Yt),\n          kt.subVectors(t.a, Yt),\n          Vt.subVectors(t.b, Yt),\n          Wt.subVectors(t.c, Yt),\n          jt.subVectors(Vt, kt),\n          qt.subVectors(Wt, Vt),\n          Xt.subVectors(kt, Wt);\n        let e = [\n          0,\n          -jt.z,\n          jt.y,\n          0,\n          -qt.z,\n          qt.y,\n          0,\n          -Xt.z,\n          Xt.y,\n          jt.z,\n          0,\n          -jt.x,\n          qt.z,\n          0,\n          -qt.x,\n          Xt.z,\n          0,\n          -Xt.x,\n          -jt.y,\n          jt.x,\n          0,\n          -qt.y,\n          qt.x,\n          0,\n          -Xt.y,\n          Xt.x,\n          0,\n        ];\n        return (\n          !!Kt(e, kt, Vt, Wt, Jt) &&\n          ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),\n          !!Kt(e, kt, Vt, Wt, Jt) &&\n            (Zt.crossVectors(jt, qt),\n            (e = [Zt.x, Zt.y, Zt.z]),\n            Kt(e, kt, Vt, Wt, Jt)))\n        );\n      }\n      clampPoint(t, e) {\n        return e.copy(t).clamp(this.min, this.max);\n      }\n      distanceToPoint(t) {\n        return Ht.copy(t).clamp(this.min, this.max).sub(t).length();\n      }\n      getBoundingSphere(t) {\n        return (\n          this.getCenter(t.center),\n          (t.radius = 0.5 * this.getSize(Ht).length()),\n          t\n        );\n      }\n      intersect(t) {\n        return (\n          this.min.max(t.min),\n          this.max.min(t.max),\n          this.isEmpty() && this.makeEmpty(),\n          this\n        );\n      }\n      union(t) {\n        return this.min.min(t.min), this.max.max(t.max), this;\n      }\n      applyMatrix4(t) {\n        return (\n          this.isEmpty() ||\n            (Ut[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),\n            Ut[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),\n            Ut[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),\n            Ut[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),\n            Ut[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),\n            Ut[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),\n            Ut[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),\n            Ut[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),\n            this.setFromPoints(Ut)),\n          this\n        );\n      }\n      translate(t) {\n        return this.min.add(t), this.max.add(t), this;\n      }\n      equals(t) {\n        return t.min.equals(this.min) && t.max.equals(this.max);\n      }\n    }\n    Ot.prototype.isBox3 = !0;\n    const Ut = [\n        new zt(),\n        new zt(),\n        new zt(),\n        new zt(),\n        new zt(),\n        new zt(),\n        new zt(),\n        new zt(),\n      ],\n      Ht = new zt(),\n      Gt = new Ot(),\n      kt = new zt(),\n      Vt = new zt(),\n      Wt = new zt(),\n      jt = new zt(),\n      qt = new zt(),\n      Xt = new zt(),\n      Yt = new zt(),\n      Jt = new zt(),\n      Zt = new zt(),\n      Qt = new zt();\n    function Kt(t, e, n, i, r) {\n      for (let s = 0, a = t.length - 3; s <= a; s += 3) {\n        Qt.fromArray(t, s);\n        const a =\n            r.x * Math.abs(Qt.x) + r.y * Math.abs(Qt.y) + r.z * Math.abs(Qt.z),\n          o = e.dot(Qt),\n          l = n.dot(Qt),\n          c = i.dot(Qt);\n        if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;\n      }\n      return !0;\n    }\n    const $t = new Ot(),\n      te = new zt(),\n      ee = new zt(),\n      ne = new zt();\n    class ie {\n      constructor(t = new zt(), e = -1) {\n        (this.center = t), (this.radius = e);\n      }\n      set(t, e) {\n        return this.center.copy(t), (this.radius = e), this;\n      }\n      setFromPoints(t, e) {\n        const n = this.center;\n        void 0 !== e ? n.copy(e) : $t.setFromPoints(t).getCenter(n);\n        let i = 0;\n        for (let e = 0, r = t.length; e < r; e++)\n          i = Math.max(i, n.distanceToSquared(t[e]));\n        return (this.radius = Math.sqrt(i)), this;\n      }\n      copy(t) {\n        return this.center.copy(t.center), (this.radius = t.radius), this;\n      }\n      isEmpty() {\n        return this.radius < 0;\n      }\n      makeEmpty() {\n        return this.center.set(0, 0, 0), (this.radius = -1), this;\n      }\n      containsPoint(t) {\n        return t.distanceToSquared(this.center) <= this.radius * this.radius;\n      }\n      distanceToPoint(t) {\n        return t.distanceTo(this.center) - this.radius;\n      }\n      intersectsSphere(t) {\n        const e = this.radius + t.radius;\n        return t.center.distanceToSquared(this.center) <= e * e;\n      }\n      intersectsBox(t) {\n        return t.intersectsSphere(this);\n      }\n      intersectsPlane(t) {\n        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;\n      }\n      clampPoint(t, e) {\n        const n = this.center.distanceToSquared(t);\n        return (\n          e.copy(t),\n          n > this.radius * this.radius &&\n            (e.sub(this.center).normalize(),\n            e.multiplyScalar(this.radius).add(this.center)),\n          e\n        );\n      }\n      getBoundingBox(t) {\n        return this.isEmpty()\n          ? (t.makeEmpty(), t)\n          : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);\n      }\n      applyMatrix4(t) {\n        return (\n          this.center.applyMatrix4(t),\n          (this.radius = this.radius * t.getMaxScaleOnAxis()),\n          this\n        );\n      }\n      translate(t) {\n        return this.center.add(t), this;\n      }\n      expandByPoint(t) {\n        ne.subVectors(t, this.center);\n        const e = ne.lengthSq();\n        if (e > this.radius * this.radius) {\n          const t = Math.sqrt(e),\n            n = 0.5 * (t - this.radius);\n          this.center.add(ne.multiplyScalar(n / t)), (this.radius += n);\n        }\n        return this;\n      }\n      union(t) {\n        return (\n          ee\n            .subVectors(t.center, this.center)\n            .normalize()\n            .multiplyScalar(t.radius),\n          this.expandByPoint(te.copy(t.center).add(ee)),\n          this.expandByPoint(te.copy(t.center).sub(ee)),\n          this\n        );\n      }\n      equals(t) {\n        return t.center.equals(this.center) && t.radius === this.radius;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    const re = new zt(),\n      se = new zt(),\n      ae = new zt(),\n      oe = new zt(),\n      le = new zt(),\n      ce = new zt(),\n      he = new zt();\n    class ue {\n      constructor(t = new zt(), e = new zt(0, 0, -1)) {\n        (this.origin = t), (this.direction = e);\n      }\n      set(t, e) {\n        return this.origin.copy(t), this.direction.copy(e), this;\n      }\n      copy(t) {\n        return (\n          this.origin.copy(t.origin), this.direction.copy(t.direction), this\n        );\n      }\n      at(t, e) {\n        return e.copy(this.direction).multiplyScalar(t).add(this.origin);\n      }\n      lookAt(t) {\n        return this.direction.copy(t).sub(this.origin).normalize(), this;\n      }\n      recast(t) {\n        return this.origin.copy(this.at(t, re)), this;\n      }\n      closestPointToPoint(t, e) {\n        e.subVectors(t, this.origin);\n        const n = e.dot(this.direction);\n        return n < 0\n          ? e.copy(this.origin)\n          : e.copy(this.direction).multiplyScalar(n).add(this.origin);\n      }\n      distanceToPoint(t) {\n        return Math.sqrt(this.distanceSqToPoint(t));\n      }\n      distanceSqToPoint(t) {\n        const e = re.subVectors(t, this.origin).dot(this.direction);\n        return e < 0\n          ? this.origin.distanceToSquared(t)\n          : (re.copy(this.direction).multiplyScalar(e).add(this.origin),\n            re.distanceToSquared(t));\n      }\n      distanceSqToSegment(t, e, n, i) {\n        se.copy(t).add(e).multiplyScalar(0.5),\n          ae.copy(e).sub(t).normalize(),\n          oe.copy(this.origin).sub(se);\n        const r = 0.5 * t.distanceTo(e),\n          s = -this.direction.dot(ae),\n          a = oe.dot(this.direction),\n          o = -oe.dot(ae),\n          l = oe.lengthSq(),\n          c = Math.abs(1 - s * s);\n        let h, u, d, p;\n        if (c > 0)\n          if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))\n            if (u >= -p)\n              if (u <= p) {\n                const t = 1 / c;\n                (h *= t),\n                  (u *= t),\n                  (d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);\n              } else\n                (u = r),\n                  (h = Math.max(0, -(s * u + a))),\n                  (d = -h * h + u * (u + 2 * o) + l);\n            else\n              (u = -r),\n                (h = Math.max(0, -(s * u + a))),\n                (d = -h * h + u * (u + 2 * o) + l);\n          else\n            u <= -p\n              ? ((h = Math.max(0, -(-s * r + a))),\n                (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),\n                (d = -h * h + u * (u + 2 * o) + l))\n              : u <= p\n              ? ((h = 0),\n                (u = Math.min(Math.max(-r, -o), r)),\n                (d = u * (u + 2 * o) + l))\n              : ((h = Math.max(0, -(s * r + a))),\n                (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),\n                (d = -h * h + u * (u + 2 * o) + l));\n        else\n          (u = s > 0 ? -r : r),\n            (h = Math.max(0, -(s * u + a))),\n            (d = -h * h + u * (u + 2 * o) + l);\n        return (\n          n && n.copy(this.direction).multiplyScalar(h).add(this.origin),\n          i && i.copy(ae).multiplyScalar(u).add(se),\n          d\n        );\n      }\n      intersectSphere(t, e) {\n        re.subVectors(t.center, this.origin);\n        const n = re.dot(this.direction),\n          i = re.dot(re) - n * n,\n          r = t.radius * t.radius;\n        if (i > r) return null;\n        const s = Math.sqrt(r - i),\n          a = n - s,\n          o = n + s;\n        return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);\n      }\n      intersectsSphere(t) {\n        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;\n      }\n      distanceToPlane(t) {\n        const e = t.normal.dot(this.direction);\n        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;\n        const n = -(this.origin.dot(t.normal) + t.constant) / e;\n        return n >= 0 ? n : null;\n      }\n      intersectPlane(t, e) {\n        const n = this.distanceToPlane(t);\n        return null === n ? null : this.at(n, e);\n      }\n      intersectsPlane(t) {\n        const e = t.distanceToPoint(this.origin);\n        if (0 === e) return !0;\n        return t.normal.dot(this.direction) * e < 0;\n      }\n      intersectBox(t, e) {\n        let n, i, r, s, a, o;\n        const l = 1 / this.direction.x,\n          c = 1 / this.direction.y,\n          h = 1 / this.direction.z,\n          u = this.origin;\n        return (\n          l >= 0\n            ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))\n            : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),\n          c >= 0\n            ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))\n            : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),\n          n > s || r > i\n            ? null\n            : ((r > n || n != n) && (n = r),\n              (s < i || i != i) && (i = s),\n              h >= 0\n                ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))\n                : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),\n              n > o || a > i\n                ? null\n                : ((a > n || n != n) && (n = a),\n                  (o < i || i != i) && (i = o),\n                  i < 0 ? null : this.at(n >= 0 ? n : i, e)))\n        );\n      }\n      intersectsBox(t) {\n        return null !== this.intersectBox(t, re);\n      }\n      intersectTriangle(t, e, n, i, r) {\n        le.subVectors(e, t), ce.subVectors(n, t), he.crossVectors(le, ce);\n        let s,\n          a = this.direction.dot(he);\n        if (a > 0) {\n          if (i) return null;\n          s = 1;\n        } else {\n          if (!(a < 0)) return null;\n          (s = -1), (a = -a);\n        }\n        oe.subVectors(this.origin, t);\n        const o = s * this.direction.dot(ce.crossVectors(oe, ce));\n        if (o < 0) return null;\n        const l = s * this.direction.dot(le.cross(oe));\n        if (l < 0) return null;\n        if (o + l > a) return null;\n        const c = -s * oe.dot(he);\n        return c < 0 ? null : this.at(c / a, r);\n      }\n      applyMatrix4(t) {\n        return (\n          this.origin.applyMatrix4(t),\n          this.direction.transformDirection(t),\n          this\n        );\n      }\n      equals(t) {\n        return (\n          t.origin.equals(this.origin) && t.direction.equals(this.direction)\n        );\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    class de {\n      constructor() {\n        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),\n          arguments.length > 0 &&\n            console.error(\n              \"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\"\n            );\n      }\n      set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {\n        const g = this.elements;\n        return (\n          (g[0] = t),\n          (g[4] = e),\n          (g[8] = n),\n          (g[12] = i),\n          (g[1] = r),\n          (g[5] = s),\n          (g[9] = a),\n          (g[13] = o),\n          (g[2] = l),\n          (g[6] = c),\n          (g[10] = h),\n          (g[14] = u),\n          (g[3] = d),\n          (g[7] = p),\n          (g[11] = m),\n          (g[15] = f),\n          this\n        );\n      }\n      identity() {\n        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;\n      }\n      clone() {\n        return new de().fromArray(this.elements);\n      }\n      copy(t) {\n        const e = this.elements,\n          n = t.elements;\n        return (\n          (e[0] = n[0]),\n          (e[1] = n[1]),\n          (e[2] = n[2]),\n          (e[3] = n[3]),\n          (e[4] = n[4]),\n          (e[5] = n[5]),\n          (e[6] = n[6]),\n          (e[7] = n[7]),\n          (e[8] = n[8]),\n          (e[9] = n[9]),\n          (e[10] = n[10]),\n          (e[11] = n[11]),\n          (e[12] = n[12]),\n          (e[13] = n[13]),\n          (e[14] = n[14]),\n          (e[15] = n[15]),\n          this\n        );\n      }\n      copyPosition(t) {\n        const e = this.elements,\n          n = t.elements;\n        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;\n      }\n      setFromMatrix3(t) {\n        const e = t.elements;\n        return (\n          this.set(\n            e[0],\n            e[3],\n            e[6],\n            0,\n            e[1],\n            e[4],\n            e[7],\n            0,\n            e[2],\n            e[5],\n            e[8],\n            0,\n            0,\n            0,\n            0,\n            1\n          ),\n          this\n        );\n      }\n      extractBasis(t, e, n) {\n        return (\n          t.setFromMatrixColumn(this, 0),\n          e.setFromMatrixColumn(this, 1),\n          n.setFromMatrixColumn(this, 2),\n          this\n        );\n      }\n      makeBasis(t, e, n) {\n        return (\n          this.set(\n            t.x,\n            e.x,\n            n.x,\n            0,\n            t.y,\n            e.y,\n            n.y,\n            0,\n            t.z,\n            e.z,\n            n.z,\n            0,\n            0,\n            0,\n            0,\n            1\n          ),\n          this\n        );\n      }\n      extractRotation(t) {\n        const e = this.elements,\n          n = t.elements,\n          i = 1 / pe.setFromMatrixColumn(t, 0).length(),\n          r = 1 / pe.setFromMatrixColumn(t, 1).length(),\n          s = 1 / pe.setFromMatrixColumn(t, 2).length();\n        return (\n          (e[0] = n[0] * i),\n          (e[1] = n[1] * i),\n          (e[2] = n[2] * i),\n          (e[3] = 0),\n          (e[4] = n[4] * r),\n          (e[5] = n[5] * r),\n          (e[6] = n[6] * r),\n          (e[7] = 0),\n          (e[8] = n[8] * s),\n          (e[9] = n[9] * s),\n          (e[10] = n[10] * s),\n          (e[11] = 0),\n          (e[12] = 0),\n          (e[13] = 0),\n          (e[14] = 0),\n          (e[15] = 1),\n          this\n        );\n      }\n      makeRotationFromEuler(t) {\n        (t && t.isEuler) ||\n          console.error(\n            \"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\"\n          );\n        const e = this.elements,\n          n = t.x,\n          i = t.y,\n          r = t.z,\n          s = Math.cos(n),\n          a = Math.sin(n),\n          o = Math.cos(i),\n          l = Math.sin(i),\n          c = Math.cos(r),\n          h = Math.sin(r);\n        if (\"XYZ\" === t.order) {\n          const t = s * c,\n            n = s * h,\n            i = a * c,\n            r = a * h;\n          (e[0] = o * c),\n            (e[4] = -o * h),\n            (e[8] = l),\n            (e[1] = n + i * l),\n            (e[5] = t - r * l),\n            (e[9] = -a * o),\n            (e[2] = r - t * l),\n            (e[6] = i + n * l),\n            (e[10] = s * o);\n        } else if (\"YXZ\" === t.order) {\n          const t = o * c,\n            n = o * h,\n            i = l * c,\n            r = l * h;\n          (e[0] = t + r * a),\n            (e[4] = i * a - n),\n            (e[8] = s * l),\n            (e[1] = s * h),\n            (e[5] = s * c),\n            (e[9] = -a),\n            (e[2] = n * a - i),\n            (e[6] = r + t * a),\n            (e[10] = s * o);\n        } else if (\"ZXY\" === t.order) {\n          const t = o * c,\n            n = o * h,\n            i = l * c,\n            r = l * h;\n          (e[0] = t - r * a),\n            (e[4] = -s * h),\n            (e[8] = i + n * a),\n            (e[1] = n + i * a),\n            (e[5] = s * c),\n            (e[9] = r - t * a),\n            (e[2] = -s * l),\n            (e[6] = a),\n            (e[10] = s * o);\n        } else if (\"ZYX\" === t.order) {\n          const t = s * c,\n            n = s * h,\n            i = a * c,\n            r = a * h;\n          (e[0] = o * c),\n            (e[4] = i * l - n),\n            (e[8] = t * l + r),\n            (e[1] = o * h),\n            (e[5] = r * l + t),\n            (e[9] = n * l - i),\n            (e[2] = -l),\n            (e[6] = a * o),\n            (e[10] = s * o);\n        } else if (\"YZX\" === t.order) {\n          const t = s * o,\n            n = s * l,\n            i = a * o,\n            r = a * l;\n          (e[0] = o * c),\n            (e[4] = r - t * h),\n            (e[8] = i * h + n),\n            (e[1] = h),\n            (e[5] = s * c),\n            (e[9] = -a * c),\n            (e[2] = -l * c),\n            (e[6] = n * h + i),\n            (e[10] = t - r * h);\n        } else if (\"XZY\" === t.order) {\n          const t = s * o,\n            n = s * l,\n            i = a * o,\n            r = a * l;\n          (e[0] = o * c),\n            (e[4] = -h),\n            (e[8] = l * c),\n            (e[1] = t * h + r),\n            (e[5] = s * c),\n            (e[9] = n * h - i),\n            (e[2] = i * h - n),\n            (e[6] = a * c),\n            (e[10] = r * h + t);\n        }\n        return (\n          (e[3] = 0),\n          (e[7] = 0),\n          (e[11] = 0),\n          (e[12] = 0),\n          (e[13] = 0),\n          (e[14] = 0),\n          (e[15] = 1),\n          this\n        );\n      }\n      makeRotationFromQuaternion(t) {\n        return this.compose(fe, t, ge);\n      }\n      lookAt(t, e, n) {\n        const i = this.elements;\n        return (\n          xe.subVectors(t, e),\n          0 === xe.lengthSq() && (xe.z = 1),\n          xe.normalize(),\n          ve.crossVectors(n, xe),\n          0 === ve.lengthSq() &&\n            (1 === Math.abs(n.z) ? (xe.x += 1e-4) : (xe.z += 1e-4),\n            xe.normalize(),\n            ve.crossVectors(n, xe)),\n          ve.normalize(),\n          ye.crossVectors(xe, ve),\n          (i[0] = ve.x),\n          (i[4] = ye.x),\n          (i[8] = xe.x),\n          (i[1] = ve.y),\n          (i[5] = ye.y),\n          (i[9] = xe.y),\n          (i[2] = ve.z),\n          (i[6] = ye.z),\n          (i[10] = xe.z),\n          this\n        );\n      }\n      multiply(t, e) {\n        return void 0 !== e\n          ? (console.warn(\n              \"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"\n            ),\n            this.multiplyMatrices(t, e))\n          : this.multiplyMatrices(this, t);\n      }\n      premultiply(t) {\n        return this.multiplyMatrices(t, this);\n      }\n      multiplyMatrices(t, e) {\n        const n = t.elements,\n          i = e.elements,\n          r = this.elements,\n          s = n[0],\n          a = n[4],\n          o = n[8],\n          l = n[12],\n          c = n[1],\n          h = n[5],\n          u = n[9],\n          d = n[13],\n          p = n[2],\n          m = n[6],\n          f = n[10],\n          g = n[14],\n          v = n[3],\n          y = n[7],\n          x = n[11],\n          _ = n[15],\n          M = i[0],\n          b = i[4],\n          w = i[8],\n          S = i[12],\n          T = i[1],\n          E = i[5],\n          A = i[9],\n          L = i[13],\n          R = i[2],\n          C = i[6],\n          P = i[10],\n          I = i[14],\n          D = i[3],\n          N = i[7],\n          z = i[11],\n          B = i[15];\n        return (\n          (r[0] = s * M + a * T + o * R + l * D),\n          (r[4] = s * b + a * E + o * C + l * N),\n          (r[8] = s * w + a * A + o * P + l * z),\n          (r[12] = s * S + a * L + o * I + l * B),\n          (r[1] = c * M + h * T + u * R + d * D),\n          (r[5] = c * b + h * E + u * C + d * N),\n          (r[9] = c * w + h * A + u * P + d * z),\n          (r[13] = c * S + h * L + u * I + d * B),\n          (r[2] = p * M + m * T + f * R + g * D),\n          (r[6] = p * b + m * E + f * C + g * N),\n          (r[10] = p * w + m * A + f * P + g * z),\n          (r[14] = p * S + m * L + f * I + g * B),\n          (r[3] = v * M + y * T + x * R + _ * D),\n          (r[7] = v * b + y * E + x * C + _ * N),\n          (r[11] = v * w + y * A + x * P + _ * z),\n          (r[15] = v * S + y * L + x * I + _ * B),\n          this\n        );\n      }\n      multiplyScalar(t) {\n        const e = this.elements;\n        return (\n          (e[0] *= t),\n          (e[4] *= t),\n          (e[8] *= t),\n          (e[12] *= t),\n          (e[1] *= t),\n          (e[5] *= t),\n          (e[9] *= t),\n          (e[13] *= t),\n          (e[2] *= t),\n          (e[6] *= t),\n          (e[10] *= t),\n          (e[14] *= t),\n          (e[3] *= t),\n          (e[7] *= t),\n          (e[11] *= t),\n          (e[15] *= t),\n          this\n        );\n      }\n      determinant() {\n        const t = this.elements,\n          e = t[0],\n          n = t[4],\n          i = t[8],\n          r = t[12],\n          s = t[1],\n          a = t[5],\n          o = t[9],\n          l = t[13],\n          c = t[2],\n          h = t[6],\n          u = t[10],\n          d = t[14];\n        return (\n          t[3] *\n            (+r * o * h -\n              i * l * h -\n              r * a * u +\n              n * l * u +\n              i * a * d -\n              n * o * d) +\n          t[7] *\n            (+e * o * d -\n              e * l * u +\n              r * s * u -\n              i * s * d +\n              i * l * c -\n              r * o * c) +\n          t[11] *\n            (+e * l * h -\n              e * a * d -\n              r * s * h +\n              n * s * d +\n              r * a * c -\n              n * l * c) +\n          t[15] *\n            (-i * a * c -\n              e * o * h +\n              e * a * u +\n              i * s * h -\n              n * s * u +\n              n * o * c)\n        );\n      }\n      transpose() {\n        const t = this.elements;\n        let e;\n        return (\n          (e = t[1]),\n          (t[1] = t[4]),\n          (t[4] = e),\n          (e = t[2]),\n          (t[2] = t[8]),\n          (t[8] = e),\n          (e = t[6]),\n          (t[6] = t[9]),\n          (t[9] = e),\n          (e = t[3]),\n          (t[3] = t[12]),\n          (t[12] = e),\n          (e = t[7]),\n          (t[7] = t[13]),\n          (t[13] = e),\n          (e = t[11]),\n          (t[11] = t[14]),\n          (t[14] = e),\n          this\n        );\n      }\n      setPosition(t, e, n) {\n        const i = this.elements;\n        return (\n          t.isVector3\n            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))\n            : ((i[12] = t), (i[13] = e), (i[14] = n)),\n          this\n        );\n      }\n      invert() {\n        const t = this.elements,\n          e = t[0],\n          n = t[1],\n          i = t[2],\n          r = t[3],\n          s = t[4],\n          a = t[5],\n          o = t[6],\n          l = t[7],\n          c = t[8],\n          h = t[9],\n          u = t[10],\n          d = t[11],\n          p = t[12],\n          m = t[13],\n          f = t[14],\n          g = t[15],\n          v =\n            h * f * l -\n            m * u * l +\n            m * o * d -\n            a * f * d -\n            h * o * g +\n            a * u * g,\n          y =\n            p * u * l -\n            c * f * l -\n            p * o * d +\n            s * f * d +\n            c * o * g -\n            s * u * g,\n          x =\n            c * m * l -\n            p * h * l +\n            p * a * d -\n            s * m * d -\n            c * a * g +\n            s * h * g,\n          _ =\n            p * h * o -\n            c * m * o -\n            p * a * u +\n            s * m * u +\n            c * a * f -\n            s * h * f,\n          M = e * v + n * y + i * x + r * _;\n        if (0 === M)\n          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n        const b = 1 / M;\n        return (\n          (t[0] = v * b),\n          (t[1] =\n            (m * u * r -\n              h * f * r -\n              m * i * d +\n              n * f * d +\n              h * i * g -\n              n * u * g) *\n            b),\n          (t[2] =\n            (a * f * r -\n              m * o * r +\n              m * i * l -\n              n * f * l -\n              a * i * g +\n              n * o * g) *\n            b),\n          (t[3] =\n            (h * o * r -\n              a * u * r -\n              h * i * l +\n              n * u * l +\n              a * i * d -\n              n * o * d) *\n            b),\n          (t[4] = y * b),\n          (t[5] =\n            (c * f * r -\n              p * u * r +\n              p * i * d -\n              e * f * d -\n              c * i * g +\n              e * u * g) *\n            b),\n          (t[6] =\n            (p * o * r -\n              s * f * r -\n              p * i * l +\n              e * f * l +\n              s * i * g -\n              e * o * g) *\n            b),\n          (t[7] =\n            (s * u * r -\n              c * o * r +\n              c * i * l -\n              e * u * l -\n              s * i * d +\n              e * o * d) *\n            b),\n          (t[8] = x * b),\n          (t[9] =\n            (p * h * r -\n              c * m * r -\n              p * n * d +\n              e * m * d +\n              c * n * g -\n              e * h * g) *\n            b),\n          (t[10] =\n            (s * m * r -\n              p * a * r +\n              p * n * l -\n              e * m * l -\n              s * n * g +\n              e * a * g) *\n            b),\n          (t[11] =\n            (c * a * r -\n              s * h * r -\n              c * n * l +\n              e * h * l +\n              s * n * d -\n              e * a * d) *\n            b),\n          (t[12] = _ * b),\n          (t[13] =\n            (c * m * i -\n              p * h * i +\n              p * n * u -\n              e * m * u -\n              c * n * f +\n              e * h * f) *\n            b),\n          (t[14] =\n            (p * a * i -\n              s * m * i -\n              p * n * o +\n              e * m * o +\n              s * n * f -\n              e * a * f) *\n            b),\n          (t[15] =\n            (s * h * i -\n              c * a * i +\n              c * n * o -\n              e * h * o -\n              s * n * u +\n              e * a * u) *\n            b),\n          this\n        );\n      }\n      scale(t) {\n        const e = this.elements,\n          n = t.x,\n          i = t.y,\n          r = t.z;\n        return (\n          (e[0] *= n),\n          (e[4] *= i),\n          (e[8] *= r),\n          (e[1] *= n),\n          (e[5] *= i),\n          (e[9] *= r),\n          (e[2] *= n),\n          (e[6] *= i),\n          (e[10] *= r),\n          (e[3] *= n),\n          (e[7] *= i),\n          (e[11] *= r),\n          this\n        );\n      }\n      getMaxScaleOnAxis() {\n        const t = this.elements,\n          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],\n          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],\n          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];\n        return Math.sqrt(Math.max(e, n, i));\n      }\n      makeTranslation(t, e, n) {\n        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;\n      }\n      makeRotationX(t) {\n        const e = Math.cos(t),\n          n = Math.sin(t);\n        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;\n      }\n      makeRotationY(t) {\n        const e = Math.cos(t),\n          n = Math.sin(t);\n        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;\n      }\n      makeRotationZ(t) {\n        const e = Math.cos(t),\n          n = Math.sin(t);\n        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;\n      }\n      makeRotationAxis(t, e) {\n        const n = Math.cos(e),\n          i = Math.sin(e),\n          r = 1 - n,\n          s = t.x,\n          a = t.y,\n          o = t.z,\n          l = r * s,\n          c = r * a;\n        return (\n          this.set(\n            l * s + n,\n            l * a - i * o,\n            l * o + i * a,\n            0,\n            l * a + i * o,\n            c * a + n,\n            c * o - i * s,\n            0,\n            l * o - i * a,\n            c * o + i * s,\n            r * o * o + n,\n            0,\n            0,\n            0,\n            0,\n            1\n          ),\n          this\n        );\n      }\n      makeScale(t, e, n) {\n        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;\n      }\n      makeShear(t, e, n, i, r, s) {\n        return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;\n      }\n      compose(t, e, n) {\n        const i = this.elements,\n          r = e._x,\n          s = e._y,\n          a = e._z,\n          o = e._w,\n          l = r + r,\n          c = s + s,\n          h = a + a,\n          u = r * l,\n          d = r * c,\n          p = r * h,\n          m = s * c,\n          f = s * h,\n          g = a * h,\n          v = o * l,\n          y = o * c,\n          x = o * h,\n          _ = n.x,\n          M = n.y,\n          b = n.z;\n        return (\n          (i[0] = (1 - (m + g)) * _),\n          (i[1] = (d + x) * _),\n          (i[2] = (p - y) * _),\n          (i[3] = 0),\n          (i[4] = (d - x) * M),\n          (i[5] = (1 - (u + g)) * M),\n          (i[6] = (f + v) * M),\n          (i[7] = 0),\n          (i[8] = (p + y) * b),\n          (i[9] = (f - v) * b),\n          (i[10] = (1 - (u + m)) * b),\n          (i[11] = 0),\n          (i[12] = t.x),\n          (i[13] = t.y),\n          (i[14] = t.z),\n          (i[15] = 1),\n          this\n        );\n      }\n      decompose(t, e, n) {\n        const i = this.elements;\n        let r = pe.set(i[0], i[1], i[2]).length();\n        const s = pe.set(i[4], i[5], i[6]).length(),\n          a = pe.set(i[8], i[9], i[10]).length();\n        this.determinant() < 0 && (r = -r),\n          (t.x = i[12]),\n          (t.y = i[13]),\n          (t.z = i[14]),\n          me.copy(this);\n        const o = 1 / r,\n          l = 1 / s,\n          c = 1 / a;\n        return (\n          (me.elements[0] *= o),\n          (me.elements[1] *= o),\n          (me.elements[2] *= o),\n          (me.elements[4] *= l),\n          (me.elements[5] *= l),\n          (me.elements[6] *= l),\n          (me.elements[8] *= c),\n          (me.elements[9] *= c),\n          (me.elements[10] *= c),\n          e.setFromRotationMatrix(me),\n          (n.x = r),\n          (n.y = s),\n          (n.z = a),\n          this\n        );\n      }\n      makePerspective(t, e, n, i, r, s) {\n        void 0 === s &&\n          console.warn(\n            \"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\"\n          );\n        const a = this.elements,\n          o = (2 * r) / (e - t),\n          l = (2 * r) / (n - i),\n          c = (e + t) / (e - t),\n          h = (n + i) / (n - i),\n          u = -(s + r) / (s - r),\n          d = (-2 * s * r) / (s - r);\n        return (\n          (a[0] = o),\n          (a[4] = 0),\n          (a[8] = c),\n          (a[12] = 0),\n          (a[1] = 0),\n          (a[5] = l),\n          (a[9] = h),\n          (a[13] = 0),\n          (a[2] = 0),\n          (a[6] = 0),\n          (a[10] = u),\n          (a[14] = d),\n          (a[3] = 0),\n          (a[7] = 0),\n          (a[11] = -1),\n          (a[15] = 0),\n          this\n        );\n      }\n      makeOrthographic(t, e, n, i, r, s) {\n        const a = this.elements,\n          o = 1 / (e - t),\n          l = 1 / (n - i),\n          c = 1 / (s - r),\n          h = (e + t) * o,\n          u = (n + i) * l,\n          d = (s + r) * c;\n        return (\n          (a[0] = 2 * o),\n          (a[4] = 0),\n          (a[8] = 0),\n          (a[12] = -h),\n          (a[1] = 0),\n          (a[5] = 2 * l),\n          (a[9] = 0),\n          (a[13] = -u),\n          (a[2] = 0),\n          (a[6] = 0),\n          (a[10] = -2 * c),\n          (a[14] = -d),\n          (a[3] = 0),\n          (a[7] = 0),\n          (a[11] = 0),\n          (a[15] = 1),\n          this\n        );\n      }\n      equals(t) {\n        const e = this.elements,\n          n = t.elements;\n        for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;\n        return !0;\n      }\n      fromArray(t, e = 0) {\n        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];\n        return this;\n      }\n      toArray(t = [], e = 0) {\n        const n = this.elements;\n        return (\n          (t[e] = n[0]),\n          (t[e + 1] = n[1]),\n          (t[e + 2] = n[2]),\n          (t[e + 3] = n[3]),\n          (t[e + 4] = n[4]),\n          (t[e + 5] = n[5]),\n          (t[e + 6] = n[6]),\n          (t[e + 7] = n[7]),\n          (t[e + 8] = n[8]),\n          (t[e + 9] = n[9]),\n          (t[e + 10] = n[10]),\n          (t[e + 11] = n[11]),\n          (t[e + 12] = n[12]),\n          (t[e + 13] = n[13]),\n          (t[e + 14] = n[14]),\n          (t[e + 15] = n[15]),\n          t\n        );\n      }\n    }\n    de.prototype.isMatrix4 = !0;\n    const pe = new zt(),\n      me = new de(),\n      fe = new zt(0, 0, 0),\n      ge = new zt(1, 1, 1),\n      ve = new zt(),\n      ye = new zt(),\n      xe = new zt(),\n      _e = new de(),\n      Me = new Nt();\n    class be {\n      constructor(t = 0, e = 0, n = 0, i = be.DefaultOrder) {\n        (this._x = t), (this._y = e), (this._z = n), (this._order = i);\n      }\n      get x() {\n        return this._x;\n      }\n      set x(t) {\n        (this._x = t), this._onChangeCallback();\n      }\n      get y() {\n        return this._y;\n      }\n      set y(t) {\n        (this._y = t), this._onChangeCallback();\n      }\n      get z() {\n        return this._z;\n      }\n      set z(t) {\n        (this._z = t), this._onChangeCallback();\n      }\n      get order() {\n        return this._order;\n      }\n      set order(t) {\n        (this._order = t), this._onChangeCallback();\n      }\n      set(t, e, n, i = this._order) {\n        return (\n          (this._x = t),\n          (this._y = e),\n          (this._z = n),\n          (this._order = i),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      clone() {\n        return new this.constructor(this._x, this._y, this._z, this._order);\n      }\n      copy(t) {\n        return (\n          (this._x = t._x),\n          (this._y = t._y),\n          (this._z = t._z),\n          (this._order = t._order),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      setFromRotationMatrix(t, e = this._order, n = !0) {\n        const i = t.elements,\n          r = i[0],\n          s = i[4],\n          a = i[8],\n          o = i[1],\n          l = i[5],\n          c = i[9],\n          h = i[2],\n          u = i[6],\n          d = i[10];\n        switch (e) {\n          case \"XYZ\":\n            (this._y = Math.asin(ut(a, -1, 1))),\n              Math.abs(a) < 0.9999999\n                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))\n                : ((this._x = Math.atan2(u, l)), (this._z = 0));\n            break;\n          case \"YXZ\":\n            (this._x = Math.asin(-ut(c, -1, 1))),\n              Math.abs(c) < 0.9999999\n                ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))\n                : ((this._y = Math.atan2(-h, r)), (this._z = 0));\n            break;\n          case \"ZXY\":\n            (this._x = Math.asin(ut(u, -1, 1))),\n              Math.abs(u) < 0.9999999\n                ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-s, l)))\n                : ((this._y = 0), (this._z = Math.atan2(o, r)));\n            break;\n          case \"ZYX\":\n            (this._y = Math.asin(-ut(h, -1, 1))),\n              Math.abs(h) < 0.9999999\n                ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, r)))\n                : ((this._x = 0), (this._z = Math.atan2(-s, l)));\n            break;\n          case \"YZX\":\n            (this._z = Math.asin(ut(o, -1, 1))),\n              Math.abs(o) < 0.9999999\n                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, r)))\n                : ((this._x = 0), (this._y = Math.atan2(a, d)));\n            break;\n          case \"XZY\":\n            (this._z = Math.asin(-ut(s, -1, 1))),\n              Math.abs(s) < 0.9999999\n                ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, r)))\n                : ((this._x = Math.atan2(-c, d)), (this._y = 0));\n            break;\n          default:\n            console.warn(\n              \"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" +\n                e\n            );\n        }\n        return (this._order = e), !0 === n && this._onChangeCallback(), this;\n      }\n      setFromQuaternion(t, e, n) {\n        return (\n          _e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(_e, e, n)\n        );\n      }\n      setFromVector3(t, e = this._order) {\n        return this.set(t.x, t.y, t.z, e);\n      }\n      reorder(t) {\n        return Me.setFromEuler(this), this.setFromQuaternion(Me, t);\n      }\n      equals(t) {\n        return (\n          t._x === this._x &&\n          t._y === this._y &&\n          t._z === this._z &&\n          t._order === this._order\n        );\n      }\n      fromArray(t) {\n        return (\n          (this._x = t[0]),\n          (this._y = t[1]),\n          (this._z = t[2]),\n          void 0 !== t[3] && (this._order = t[3]),\n          this._onChangeCallback(),\n          this\n        );\n      }\n      toArray(t = [], e = 0) {\n        return (\n          (t[e] = this._x),\n          (t[e + 1] = this._y),\n          (t[e + 2] = this._z),\n          (t[e + 3] = this._order),\n          t\n        );\n      }\n      toVector3(t) {\n        return t\n          ? t.set(this._x, this._y, this._z)\n          : new zt(this._x, this._y, this._z);\n      }\n      _onChange(t) {\n        return (this._onChangeCallback = t), this;\n      }\n      _onChangeCallback() {}\n    }\n    (be.prototype.isEuler = !0),\n      (be.DefaultOrder = \"XYZ\"),\n      (be.RotationOrders = [\"XYZ\", \"YZX\", \"ZXY\", \"XZY\", \"YXZ\", \"ZYX\"]);\n    class we {\n      constructor() {\n        this.mask = 1;\n      }\n      set(t) {\n        this.mask = (1 << t) | 0;\n      }\n      enable(t) {\n        this.mask |= (1 << t) | 0;\n      }\n      enableAll() {\n        this.mask = -1;\n      }\n      toggle(t) {\n        this.mask ^= (1 << t) | 0;\n      }\n      disable(t) {\n        this.mask &= ~((1 << t) | 0);\n      }\n      disableAll() {\n        this.mask = 0;\n      }\n      test(t) {\n        return 0 != (this.mask & t.mask);\n      }\n    }\n    let Se = 0;\n    const Te = new zt(),\n      Ee = new Nt(),\n      Ae = new de(),\n      Le = new zt(),\n      Re = new zt(),\n      Ce = new zt(),\n      Pe = new Nt(),\n      Ie = new zt(1, 0, 0),\n      De = new zt(0, 1, 0),\n      Ne = new zt(0, 0, 1),\n      ze = { type: \"added\" },\n      Be = { type: \"removed\" };\n    class Fe extends rt {\n      constructor() {\n        super(),\n          Object.defineProperty(this, \"id\", { value: Se++ }),\n          (this.uuid = ht()),\n          (this.name = \"\"),\n          (this.type = \"Object3D\"),\n          (this.parent = null),\n          (this.children = []),\n          (this.up = Fe.DefaultUp.clone());\n        const t = new zt(),\n          e = new be(),\n          n = new Nt(),\n          i = new zt(1, 1, 1);\n        e._onChange(function () {\n          n.setFromEuler(e, !1);\n        }),\n          n._onChange(function () {\n            e.setFromQuaternion(n, void 0, !1);\n          }),\n          Object.defineProperties(this, {\n            position: { configurable: !0, enumerable: !0, value: t },\n            rotation: { configurable: !0, enumerable: !0, value: e },\n            quaternion: { configurable: !0, enumerable: !0, value: n },\n            scale: { configurable: !0, enumerable: !0, value: i },\n            modelViewMatrix: { value: new de() },\n            normalMatrix: { value: new xt() },\n          }),\n          (this.matrix = new de()),\n          (this.matrixWorld = new de()),\n          (this.matrixAutoUpdate = Fe.DefaultMatrixAutoUpdate),\n          (this.matrixWorldNeedsUpdate = !1),\n          (this.layers = new we()),\n          (this.visible = !0),\n          (this.castShadow = !1),\n          (this.receiveShadow = !1),\n          (this.frustumCulled = !0),\n          (this.renderOrder = 0),\n          (this.animations = []),\n          (this.userData = {});\n      }\n      onBeforeRender() {}\n      onAfterRender() {}\n      applyMatrix4(t) {\n        this.matrixAutoUpdate && this.updateMatrix(),\n          this.matrix.premultiply(t),\n          this.matrix.decompose(this.position, this.quaternion, this.scale);\n      }\n      applyQuaternion(t) {\n        return this.quaternion.premultiply(t), this;\n      }\n      setRotationFromAxisAngle(t, e) {\n        this.quaternion.setFromAxisAngle(t, e);\n      }\n      setRotationFromEuler(t) {\n        this.quaternion.setFromEuler(t, !0);\n      }\n      setRotationFromMatrix(t) {\n        this.quaternion.setFromRotationMatrix(t);\n      }\n      setRotationFromQuaternion(t) {\n        this.quaternion.copy(t);\n      }\n      rotateOnAxis(t, e) {\n        return Ee.setFromAxisAngle(t, e), this.quaternion.multiply(Ee), this;\n      }\n      rotateOnWorldAxis(t, e) {\n        return Ee.setFromAxisAngle(t, e), this.quaternion.premultiply(Ee), this;\n      }\n      rotateX(t) {\n        return this.rotateOnAxis(Ie, t);\n      }\n      rotateY(t) {\n        return this.rotateOnAxis(De, t);\n      }\n      rotateZ(t) {\n        return this.rotateOnAxis(Ne, t);\n      }\n      translateOnAxis(t, e) {\n        return (\n          Te.copy(t).applyQuaternion(this.quaternion),\n          this.position.add(Te.multiplyScalar(e)),\n          this\n        );\n      }\n      translateX(t) {\n        return this.translateOnAxis(Ie, t);\n      }\n      translateY(t) {\n        return this.translateOnAxis(De, t);\n      }\n      translateZ(t) {\n        return this.translateOnAxis(Ne, t);\n      }\n      localToWorld(t) {\n        return t.applyMatrix4(this.matrixWorld);\n      }\n      worldToLocal(t) {\n        return t.applyMatrix4(Ae.copy(this.matrixWorld).invert());\n      }\n      lookAt(t, e, n) {\n        t.isVector3 ? Le.copy(t) : Le.set(t, e, n);\n        const i = this.parent;\n        this.updateWorldMatrix(!0, !1),\n          Re.setFromMatrixPosition(this.matrixWorld),\n          this.isCamera || this.isLight\n            ? Ae.lookAt(Re, Le, this.up)\n            : Ae.lookAt(Le, Re, this.up),\n          this.quaternion.setFromRotationMatrix(Ae),\n          i &&\n            (Ae.extractRotation(i.matrixWorld),\n            Ee.setFromRotationMatrix(Ae),\n            this.quaternion.premultiply(Ee.invert()));\n      }\n      add(t) {\n        if (arguments.length > 1) {\n          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);\n          return this;\n        }\n        return t === this\n          ? (console.error(\n              \"THREE.Object3D.add: object can't be added as a child of itself.\",\n              t\n            ),\n            this)\n          : (t && t.isObject3D\n              ? (null !== t.parent && t.parent.remove(t),\n                (t.parent = this),\n                this.children.push(t),\n                t.dispatchEvent(ze))\n              : console.error(\n                  \"THREE.Object3D.add: object not an instance of THREE.Object3D.\",\n                  t\n                ),\n            this);\n      }\n      remove(t) {\n        if (arguments.length > 1) {\n          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);\n          return this;\n        }\n        const e = this.children.indexOf(t);\n        return (\n          -1 !== e &&\n            ((t.parent = null),\n            this.children.splice(e, 1),\n            t.dispatchEvent(Be)),\n          this\n        );\n      }\n      removeFromParent() {\n        const t = this.parent;\n        return null !== t && t.remove(this), this;\n      }\n      clear() {\n        for (let t = 0; t < this.children.length; t++) {\n          const e = this.children[t];\n          (e.parent = null), e.dispatchEvent(Be);\n        }\n        return (this.children.length = 0), this;\n      }\n      attach(t) {\n        return (\n          this.updateWorldMatrix(!0, !1),\n          Ae.copy(this.matrixWorld).invert(),\n          null !== t.parent &&\n            (t.parent.updateWorldMatrix(!0, !1),\n            Ae.multiply(t.parent.matrixWorld)),\n          t.applyMatrix4(Ae),\n          this.add(t),\n          t.updateWorldMatrix(!1, !0),\n          this\n        );\n      }\n      getObjectById(t) {\n        return this.getObjectByProperty(\"id\", t);\n      }\n      getObjectByName(t) {\n        return this.getObjectByProperty(\"name\", t);\n      }\n      getObjectByProperty(t, e) {\n        if (this[t] === e) return this;\n        for (let n = 0, i = this.children.length; n < i; n++) {\n          const i = this.children[n].getObjectByProperty(t, e);\n          if (void 0 !== i) return i;\n        }\n      }\n      getWorldPosition(t) {\n        return (\n          this.updateWorldMatrix(!0, !1),\n          t.setFromMatrixPosition(this.matrixWorld)\n        );\n      }\n      getWorldQuaternion(t) {\n        return (\n          this.updateWorldMatrix(!0, !1),\n          this.matrixWorld.decompose(Re, t, Ce),\n          t\n        );\n      }\n      getWorldScale(t) {\n        return (\n          this.updateWorldMatrix(!0, !1),\n          this.matrixWorld.decompose(Re, Pe, t),\n          t\n        );\n      }\n      getWorldDirection(t) {\n        this.updateWorldMatrix(!0, !1);\n        const e = this.matrixWorld.elements;\n        return t.set(e[8], e[9], e[10]).normalize();\n      }\n      raycast() {}\n      traverse(t) {\n        t(this);\n        const e = this.children;\n        for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);\n      }\n      traverseVisible(t) {\n        if (!1 === this.visible) return;\n        t(this);\n        const e = this.children;\n        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);\n      }\n      traverseAncestors(t) {\n        const e = this.parent;\n        null !== e && (t(e), e.traverseAncestors(t));\n      }\n      updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale),\n          (this.matrixWorldNeedsUpdate = !0);\n      }\n      updateMatrixWorld(t) {\n        this.matrixAutoUpdate && this.updateMatrix(),\n          (this.matrixWorldNeedsUpdate || t) &&\n            (null === this.parent\n              ? this.matrixWorld.copy(this.matrix)\n              : this.matrixWorld.multiplyMatrices(\n                  this.parent.matrixWorld,\n                  this.matrix\n                ),\n            (this.matrixWorldNeedsUpdate = !1),\n            (t = !0));\n        const e = this.children;\n        for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);\n      }\n      updateWorldMatrix(t, e) {\n        const n = this.parent;\n        if (\n          (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),\n          this.matrixAutoUpdate && this.updateMatrix(),\n          null === this.parent\n            ? this.matrixWorld.copy(this.matrix)\n            : this.matrixWorld.multiplyMatrices(\n                this.parent.matrixWorld,\n                this.matrix\n              ),\n          !0 === e)\n        ) {\n          const t = this.children;\n          for (let e = 0, n = t.length; e < n; e++)\n            t[e].updateWorldMatrix(!1, !0);\n        }\n      }\n      toJSON(t) {\n        const e = void 0 === t || \"string\" == typeof t,\n          n = {};\n        e &&\n          ((t = {\n            geometries: {},\n            materials: {},\n            textures: {},\n            images: {},\n            shapes: {},\n            skeletons: {},\n            animations: {},\n          }),\n          (n.metadata = {\n            version: 4.5,\n            type: \"Object\",\n            generator: \"Object3D.toJSON\",\n          }));\n        const i = {};\n        function r(e, n) {\n          return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;\n        }\n        if (\n          ((i.uuid = this.uuid),\n          (i.type = this.type),\n          \"\" !== this.name && (i.name = this.name),\n          !0 === this.castShadow && (i.castShadow = !0),\n          !0 === this.receiveShadow && (i.receiveShadow = !0),\n          !1 === this.visible && (i.visible = !1),\n          !1 === this.frustumCulled && (i.frustumCulled = !1),\n          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),\n          \"{}\" !== JSON.stringify(this.userData) &&\n            (i.userData = this.userData),\n          (i.layers = this.layers.mask),\n          (i.matrix = this.matrix.toArray()),\n          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),\n          this.isInstancedMesh &&\n            ((i.type = \"InstancedMesh\"),\n            (i.count = this.count),\n            (i.instanceMatrix = this.instanceMatrix.toJSON()),\n            null !== this.instanceColor &&\n              (i.instanceColor = this.instanceColor.toJSON())),\n          this.isScene)\n        )\n          this.background &&\n            (this.background.isColor\n              ? (i.background = this.background.toJSON())\n              : this.background.isTexture &&\n                (i.background = this.background.toJSON(t).uuid)),\n            this.environment &&\n              this.environment.isTexture &&\n              (i.environment = this.environment.toJSON(t).uuid);\n        else if (this.isMesh || this.isLine || this.isPoints) {\n          i.geometry = r(t.geometries, this.geometry);\n          const e = this.geometry.parameters;\n          if (void 0 !== e && void 0 !== e.shapes) {\n            const n = e.shapes;\n            if (Array.isArray(n))\n              for (let e = 0, i = n.length; e < i; e++) {\n                const i = n[e];\n                r(t.shapes, i);\n              }\n            else r(t.shapes, n);\n          }\n        }\n        if (\n          (this.isSkinnedMesh &&\n            ((i.bindMode = this.bindMode),\n            (i.bindMatrix = this.bindMatrix.toArray()),\n            void 0 !== this.skeleton &&\n              (r(t.skeletons, this.skeleton),\n              (i.skeleton = this.skeleton.uuid))),\n          void 0 !== this.material)\n        )\n          if (Array.isArray(this.material)) {\n            const e = [];\n            for (let n = 0, i = this.material.length; n < i; n++)\n              e.push(r(t.materials, this.material[n]));\n            i.material = e;\n          } else i.material = r(t.materials, this.material);\n        if (this.children.length > 0) {\n          i.children = [];\n          for (let e = 0; e < this.children.length; e++)\n            i.children.push(this.children[e].toJSON(t).object);\n        }\n        if (this.animations.length > 0) {\n          i.animations = [];\n          for (let e = 0; e < this.animations.length; e++) {\n            const n = this.animations[e];\n            i.animations.push(r(t.animations, n));\n          }\n        }\n        if (e) {\n          const e = s(t.geometries),\n            i = s(t.materials),\n            r = s(t.textures),\n            a = s(t.images),\n            o = s(t.shapes),\n            l = s(t.skeletons),\n            c = s(t.animations);\n          e.length > 0 && (n.geometries = e),\n            i.length > 0 && (n.materials = i),\n            r.length > 0 && (n.textures = r),\n            a.length > 0 && (n.images = a),\n            o.length > 0 && (n.shapes = o),\n            l.length > 0 && (n.skeletons = l),\n            c.length > 0 && (n.animations = c);\n        }\n        return (n.object = i), n;\n        function s(t) {\n          const e = [];\n          for (const n in t) {\n            const i = t[n];\n            delete i.metadata, e.push(i);\n          }\n          return e;\n        }\n      }\n      clone(t) {\n        return new this.constructor().copy(this, t);\n      }\n      copy(t, e = !0) {\n        if (\n          ((this.name = t.name),\n          this.up.copy(t.up),\n          this.position.copy(t.position),\n          (this.rotation.order = t.rotation.order),\n          this.quaternion.copy(t.quaternion),\n          this.scale.copy(t.scale),\n          this.matrix.copy(t.matrix),\n          this.matrixWorld.copy(t.matrixWorld),\n          (this.matrixAutoUpdate = t.matrixAutoUpdate),\n          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),\n          (this.layers.mask = t.layers.mask),\n          (this.visible = t.visible),\n          (this.castShadow = t.castShadow),\n          (this.receiveShadow = t.receiveShadow),\n          (this.frustumCulled = t.frustumCulled),\n          (this.renderOrder = t.renderOrder),\n          (this.userData = JSON.parse(JSON.stringify(t.userData))),\n          !0 === e)\n        )\n          for (let e = 0; e < t.children.length; e++) {\n            const n = t.children[e];\n            this.add(n.clone());\n          }\n        return this;\n      }\n    }\n    (Fe.DefaultUp = new zt(0, 1, 0)),\n      (Fe.DefaultMatrixAutoUpdate = !0),\n      (Fe.prototype.isObject3D = !0);\n    const Oe = new zt(),\n      Ue = new zt(),\n      He = new zt(),\n      Ge = new zt(),\n      ke = new zt(),\n      Ve = new zt(),\n      We = new zt(),\n      je = new zt(),\n      qe = new zt(),\n      Xe = new zt();\n    class Ye {\n      constructor(t = new zt(), e = new zt(), n = new zt()) {\n        (this.a = t), (this.b = e), (this.c = n);\n      }\n      static getNormal(t, e, n, i) {\n        i.subVectors(n, e), Oe.subVectors(t, e), i.cross(Oe);\n        const r = i.lengthSq();\n        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);\n      }\n      static getBarycoord(t, e, n, i, r) {\n        Oe.subVectors(i, e), Ue.subVectors(n, e), He.subVectors(t, e);\n        const s = Oe.dot(Oe),\n          a = Oe.dot(Ue),\n          o = Oe.dot(He),\n          l = Ue.dot(Ue),\n          c = Ue.dot(He),\n          h = s * l - a * a;\n        if (0 === h) return r.set(-2, -1, -1);\n        const u = 1 / h,\n          d = (l * o - a * c) * u,\n          p = (s * c - a * o) * u;\n        return r.set(1 - d - p, p, d);\n      }\n      static containsPoint(t, e, n, i) {\n        return (\n          this.getBarycoord(t, e, n, i, Ge),\n          Ge.x >= 0 && Ge.y >= 0 && Ge.x + Ge.y <= 1\n        );\n      }\n      static getUV(t, e, n, i, r, s, a, o) {\n        return (\n          this.getBarycoord(t, e, n, i, Ge),\n          o.set(0, 0),\n          o.addScaledVector(r, Ge.x),\n          o.addScaledVector(s, Ge.y),\n          o.addScaledVector(a, Ge.z),\n          o\n        );\n      }\n      static isFrontFacing(t, e, n, i) {\n        return (\n          Oe.subVectors(n, e), Ue.subVectors(t, e), Oe.cross(Ue).dot(i) < 0\n        );\n      }\n      set(t, e, n) {\n        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;\n      }\n      setFromPointsAndIndices(t, e, n, i) {\n        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;\n      }\n      setFromAttributeAndIndices(t, e, n, i) {\n        return (\n          this.a.fromBufferAttribute(t, e),\n          this.b.fromBufferAttribute(t, n),\n          this.c.fromBufferAttribute(t, i),\n          this\n        );\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;\n      }\n      getArea() {\n        return (\n          Oe.subVectors(this.c, this.b),\n          Ue.subVectors(this.a, this.b),\n          0.5 * Oe.cross(Ue).length()\n        );\n      }\n      getMidpoint(t) {\n        return t\n          .addVectors(this.a, this.b)\n          .add(this.c)\n          .multiplyScalar(1 / 3);\n      }\n      getNormal(t) {\n        return Ye.getNormal(this.a, this.b, this.c, t);\n      }\n      getPlane(t) {\n        return t.setFromCoplanarPoints(this.a, this.b, this.c);\n      }\n      getBarycoord(t, e) {\n        return Ye.getBarycoord(t, this.a, this.b, this.c, e);\n      }\n      getUV(t, e, n, i, r) {\n        return Ye.getUV(t, this.a, this.b, this.c, e, n, i, r);\n      }\n      containsPoint(t) {\n        return Ye.containsPoint(t, this.a, this.b, this.c);\n      }\n      isFrontFacing(t) {\n        return Ye.isFrontFacing(this.a, this.b, this.c, t);\n      }\n      intersectsBox(t) {\n        return t.intersectsTriangle(this);\n      }\n      closestPointToPoint(t, e) {\n        const n = this.a,\n          i = this.b,\n          r = this.c;\n        let s, a;\n        ke.subVectors(i, n), Ve.subVectors(r, n), je.subVectors(t, n);\n        const o = ke.dot(je),\n          l = Ve.dot(je);\n        if (o <= 0 && l <= 0) return e.copy(n);\n        qe.subVectors(t, i);\n        const c = ke.dot(qe),\n          h = Ve.dot(qe);\n        if (c >= 0 && h <= c) return e.copy(i);\n        const u = o * h - c * l;\n        if (u <= 0 && o >= 0 && c <= 0)\n          return (s = o / (o - c)), e.copy(n).addScaledVector(ke, s);\n        Xe.subVectors(t, r);\n        const d = ke.dot(Xe),\n          p = Ve.dot(Xe);\n        if (p >= 0 && d <= p) return e.copy(r);\n        const m = d * l - o * p;\n        if (m <= 0 && l >= 0 && p <= 0)\n          return (a = l / (l - p)), e.copy(n).addScaledVector(Ve, a);\n        const f = c * p - d * h;\n        if (f <= 0 && h - c >= 0 && d - p >= 0)\n          return (\n            We.subVectors(r, i),\n            (a = (h - c) / (h - c + (d - p))),\n            e.copy(i).addScaledVector(We, a)\n          );\n        const g = 1 / (f + m + u);\n        return (\n          (s = m * g),\n          (a = u * g),\n          e.copy(n).addScaledVector(ke, s).addScaledVector(Ve, a)\n        );\n      }\n      equals(t) {\n        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);\n      }\n    }\n    let Je = 0;\n    class Ze extends rt {\n      constructor() {\n        super(),\n          Object.defineProperty(this, \"id\", { value: Je++ }),\n          (this.uuid = ht()),\n          (this.name = \"\"),\n          (this.type = \"Material\"),\n          (this.fog = !0),\n          (this.blending = 1),\n          (this.side = 0),\n          (this.vertexColors = !1),\n          (this.opacity = 1),\n          (this.format = E),\n          (this.transparent = !1),\n          (this.blendSrc = 204),\n          (this.blendDst = 205),\n          (this.blendEquation = n),\n          (this.blendSrcAlpha = null),\n          (this.blendDstAlpha = null),\n          (this.blendEquationAlpha = null),\n          (this.depthFunc = 3),\n          (this.depthTest = !0),\n          (this.depthWrite = !0),\n          (this.stencilWriteMask = 255),\n          (this.stencilFunc = 519),\n          (this.stencilRef = 0),\n          (this.stencilFuncMask = 255),\n          (this.stencilFail = tt),\n          (this.stencilZFail = tt),\n          (this.stencilZPass = tt),\n          (this.stencilWrite = !1),\n          (this.clippingPlanes = null),\n          (this.clipIntersection = !1),\n          (this.clipShadows = !1),\n          (this.shadowSide = null),\n          (this.colorWrite = !0),\n          (this.precision = null),\n          (this.polygonOffset = !1),\n          (this.polygonOffsetFactor = 0),\n          (this.polygonOffsetUnits = 0),\n          (this.dithering = !1),\n          (this.alphaToCoverage = !1),\n          (this.premultipliedAlpha = !1),\n          (this.visible = !0),\n          (this.toneMapped = !0),\n          (this.userData = {}),\n          (this.version = 0),\n          (this._alphaTest = 0);\n      }\n      get alphaTest() {\n        return this._alphaTest;\n      }\n      set alphaTest(t) {\n        this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);\n      }\n      onBuild() {}\n      onBeforeRender() {}\n      onBeforeCompile() {}\n      customProgramCacheKey() {\n        return this.onBeforeCompile.toString();\n      }\n      setValues(t) {\n        if (void 0 !== t)\n          for (const e in t) {\n            const n = t[e];\n            if (void 0 === n) {\n              console.warn(\n                \"THREE.Material: '\" + e + \"' parameter is undefined.\"\n              );\n              continue;\n            }\n            if (\"shading\" === e) {\n              console.warn(\n                \"THREE.\" +\n                  this.type +\n                  \": .shading has been removed. Use the boolean .flatShading instead.\"\n              ),\n                (this.flatShading = 1 === n);\n              continue;\n            }\n            const i = this[e];\n            void 0 !== i\n              ? i && i.isColor\n                ? i.set(n)\n                : i && i.isVector3 && n && n.isVector3\n                ? i.copy(n)\n                : (this[e] = n)\n              : console.warn(\n                  \"THREE.\" +\n                    this.type +\n                    \": '\" +\n                    e +\n                    \"' is not a property of this material.\"\n                );\n          }\n      }\n      toJSON(t) {\n        const e = void 0 === t || \"string\" == typeof t;\n        e && (t = { textures: {}, images: {} });\n        const n = {\n          metadata: {\n            version: 4.5,\n            type: \"Material\",\n            generator: \"Material.toJSON\",\n          },\n        };\n        function i(t) {\n          const e = [];\n          for (const n in t) {\n            const i = t[n];\n            delete i.metadata, e.push(i);\n          }\n          return e;\n        }\n        if (\n          ((n.uuid = this.uuid),\n          (n.type = this.type),\n          \"\" !== this.name && (n.name = this.name),\n          this.color && this.color.isColor && (n.color = this.color.getHex()),\n          void 0 !== this.roughness && (n.roughness = this.roughness),\n          void 0 !== this.metalness && (n.metalness = this.metalness),\n          void 0 !== this.sheen && (n.sheen = this.sheen),\n          this.sheenColor &&\n            this.sheenColor.isColor &&\n            (n.sheenColor = this.sheenColor.getHex()),\n          void 0 !== this.sheenRoughness &&\n            (n.sheenRoughness = this.sheenRoughness),\n          this.emissive &&\n            this.emissive.isColor &&\n            (n.emissive = this.emissive.getHex()),\n          this.emissiveIntensity &&\n            1 !== this.emissiveIntensity &&\n            (n.emissiveIntensity = this.emissiveIntensity),\n          this.specular &&\n            this.specular.isColor &&\n            (n.specular = this.specular.getHex()),\n          void 0 !== this.specularIntensity &&\n            (n.specularIntensity = this.specularIntensity),\n          this.specularColor &&\n            this.specularColor.isColor &&\n            (n.specularColor = this.specularColor.getHex()),\n          void 0 !== this.shininess && (n.shininess = this.shininess),\n          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),\n          void 0 !== this.clearcoatRoughness &&\n            (n.clearcoatRoughness = this.clearcoatRoughness),\n          this.clearcoatMap &&\n            this.clearcoatMap.isTexture &&\n            (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),\n          this.clearcoatRoughnessMap &&\n            this.clearcoatRoughnessMap.isTexture &&\n            (n.clearcoatRoughnessMap =\n              this.clearcoatRoughnessMap.toJSON(t).uuid),\n          this.clearcoatNormalMap &&\n            this.clearcoatNormalMap.isTexture &&\n            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),\n            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),\n          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),\n          this.matcap &&\n            this.matcap.isTexture &&\n            (n.matcap = this.matcap.toJSON(t).uuid),\n          this.alphaMap &&\n            this.alphaMap.isTexture &&\n            (n.alphaMap = this.alphaMap.toJSON(t).uuid),\n          this.lightMap &&\n            this.lightMap.isTexture &&\n            ((n.lightMap = this.lightMap.toJSON(t).uuid),\n            (n.lightMapIntensity = this.lightMapIntensity)),\n          this.aoMap &&\n            this.aoMap.isTexture &&\n            ((n.aoMap = this.aoMap.toJSON(t).uuid),\n            (n.aoMapIntensity = this.aoMapIntensity)),\n          this.bumpMap &&\n            this.bumpMap.isTexture &&\n            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),\n            (n.bumpScale = this.bumpScale)),\n          this.normalMap &&\n            this.normalMap.isTexture &&\n            ((n.normalMap = this.normalMap.toJSON(t).uuid),\n            (n.normalMapType = this.normalMapType),\n            (n.normalScale = this.normalScale.toArray())),\n          this.displacementMap &&\n            this.displacementMap.isTexture &&\n            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),\n            (n.displacementScale = this.displacementScale),\n            (n.displacementBias = this.displacementBias)),\n          this.roughnessMap &&\n            this.roughnessMap.isTexture &&\n            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),\n          this.metalnessMap &&\n            this.metalnessMap.isTexture &&\n            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),\n          this.emissiveMap &&\n            this.emissiveMap.isTexture &&\n            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),\n          this.specularMap &&\n            this.specularMap.isTexture &&\n            (n.specularMap = this.specularMap.toJSON(t).uuid),\n          this.specularIntensityMap &&\n            this.specularIntensityMap.isTexture &&\n            (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),\n          this.specularColorMap &&\n            this.specularColorMap.isTexture &&\n            (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),\n          this.envMap &&\n            this.envMap.isTexture &&\n            ((n.envMap = this.envMap.toJSON(t).uuid),\n            void 0 !== this.combine && (n.combine = this.combine)),\n          void 0 !== this.envMapIntensity &&\n            (n.envMapIntensity = this.envMapIntensity),\n          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),\n          void 0 !== this.refractionRatio &&\n            (n.refractionRatio = this.refractionRatio),\n          this.gradientMap &&\n            this.gradientMap.isTexture &&\n            (n.gradientMap = this.gradientMap.toJSON(t).uuid),\n          void 0 !== this.transmission && (n.transmission = this.transmission),\n          this.transmissionMap &&\n            this.transmissionMap.isTexture &&\n            (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),\n          void 0 !== this.thickness && (n.thickness = this.thickness),\n          this.thicknessMap &&\n            this.thicknessMap.isTexture &&\n            (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),\n          void 0 !== this.attenuationDistance &&\n            (n.attenuationDistance = this.attenuationDistance),\n          void 0 !== this.attenuationColor &&\n            (n.attenuationColor = this.attenuationColor.getHex()),\n          void 0 !== this.size && (n.size = this.size),\n          null !== this.shadowSide && (n.shadowSide = this.shadowSide),\n          void 0 !== this.sizeAttenuation &&\n            (n.sizeAttenuation = this.sizeAttenuation),\n          1 !== this.blending && (n.blending = this.blending),\n          0 !== this.side && (n.side = this.side),\n          this.vertexColors && (n.vertexColors = !0),\n          this.opacity < 1 && (n.opacity = this.opacity),\n          this.format !== E && (n.format = this.format),\n          !0 === this.transparent && (n.transparent = this.transparent),\n          (n.depthFunc = this.depthFunc),\n          (n.depthTest = this.depthTest),\n          (n.depthWrite = this.depthWrite),\n          (n.colorWrite = this.colorWrite),\n          (n.stencilWrite = this.stencilWrite),\n          (n.stencilWriteMask = this.stencilWriteMask),\n          (n.stencilFunc = this.stencilFunc),\n          (n.stencilRef = this.stencilRef),\n          (n.stencilFuncMask = this.stencilFuncMask),\n          (n.stencilFail = this.stencilFail),\n          (n.stencilZFail = this.stencilZFail),\n          (n.stencilZPass = this.stencilZPass),\n          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),\n          !0 === this.polygonOffset && (n.polygonOffset = !0),\n          0 !== this.polygonOffsetFactor &&\n            (n.polygonOffsetFactor = this.polygonOffsetFactor),\n          0 !== this.polygonOffsetUnits &&\n            (n.polygonOffsetUnits = this.polygonOffsetUnits),\n          this.linewidth &&\n            1 !== this.linewidth &&\n            (n.linewidth = this.linewidth),\n          void 0 !== this.dashSize && (n.dashSize = this.dashSize),\n          void 0 !== this.gapSize && (n.gapSize = this.gapSize),\n          void 0 !== this.scale && (n.scale = this.scale),\n          !0 === this.dithering && (n.dithering = !0),\n          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),\n          !0 === this.alphaToCoverage &&\n            (n.alphaToCoverage = this.alphaToCoverage),\n          !0 === this.premultipliedAlpha &&\n            (n.premultipliedAlpha = this.premultipliedAlpha),\n          !0 === this.wireframe && (n.wireframe = this.wireframe),\n          this.wireframeLinewidth > 1 &&\n            (n.wireframeLinewidth = this.wireframeLinewidth),\n          \"round\" !== this.wireframeLinecap &&\n            (n.wireframeLinecap = this.wireframeLinecap),\n          \"round\" !== this.wireframeLinejoin &&\n            (n.wireframeLinejoin = this.wireframeLinejoin),\n          !0 === this.flatShading && (n.flatShading = this.flatShading),\n          !1 === this.visible && (n.visible = !1),\n          !1 === this.toneMapped && (n.toneMapped = !1),\n          \"{}\" !== JSON.stringify(this.userData) &&\n            (n.userData = this.userData),\n          e)\n        ) {\n          const e = i(t.textures),\n            r = i(t.images);\n          e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);\n        }\n        return n;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        (this.name = t.name),\n          (this.fog = t.fog),\n          (this.blending = t.blending),\n          (this.side = t.side),\n          (this.vertexColors = t.vertexColors),\n          (this.opacity = t.opacity),\n          (this.format = t.format),\n          (this.transparent = t.transparent),\n          (this.blendSrc = t.blendSrc),\n          (this.blendDst = t.blendDst),\n          (this.blendEquation = t.blendEquation),\n          (this.blendSrcAlpha = t.blendSrcAlpha),\n          (this.blendDstAlpha = t.blendDstAlpha),\n          (this.blendEquationAlpha = t.blendEquationAlpha),\n          (this.depthFunc = t.depthFunc),\n          (this.depthTest = t.depthTest),\n          (this.depthWrite = t.depthWrite),\n          (this.stencilWriteMask = t.stencilWriteMask),\n          (this.stencilFunc = t.stencilFunc),\n          (this.stencilRef = t.stencilRef),\n          (this.stencilFuncMask = t.stencilFuncMask),\n          (this.stencilFail = t.stencilFail),\n          (this.stencilZFail = t.stencilZFail),\n          (this.stencilZPass = t.stencilZPass),\n          (this.stencilWrite = t.stencilWrite);\n        const e = t.clippingPlanes;\n        let n = null;\n        if (null !== e) {\n          const t = e.length;\n          n = new Array(t);\n          for (let i = 0; i !== t; ++i) n[i] = e[i].clone();\n        }\n        return (\n          (this.clippingPlanes = n),\n          (this.clipIntersection = t.clipIntersection),\n          (this.clipShadows = t.clipShadows),\n          (this.shadowSide = t.shadowSide),\n          (this.colorWrite = t.colorWrite),\n          (this.precision = t.precision),\n          (this.polygonOffset = t.polygonOffset),\n          (this.polygonOffsetFactor = t.polygonOffsetFactor),\n          (this.polygonOffsetUnits = t.polygonOffsetUnits),\n          (this.dithering = t.dithering),\n          (this.alphaTest = t.alphaTest),\n          (this.alphaToCoverage = t.alphaToCoverage),\n          (this.premultipliedAlpha = t.premultipliedAlpha),\n          (this.visible = t.visible),\n          (this.toneMapped = t.toneMapped),\n          (this.userData = JSON.parse(JSON.stringify(t.userData))),\n          this\n        );\n      }\n      dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n      set needsUpdate(t) {\n        !0 === t && this.version++;\n      }\n    }\n    Ze.prototype.isMaterial = !0;\n    const Qe = {\n        aliceblue: 15792383,\n        antiquewhite: 16444375,\n        aqua: 65535,\n        aquamarine: 8388564,\n        azure: 15794175,\n        beige: 16119260,\n        bisque: 16770244,\n        black: 0,\n        blanchedalmond: 16772045,\n        blue: 255,\n        blueviolet: 9055202,\n        brown: 10824234,\n        burlywood: 14596231,\n        cadetblue: 6266528,\n        chartreuse: 8388352,\n        chocolate: 13789470,\n        coral: 16744272,\n        cornflowerblue: 6591981,\n        cornsilk: 16775388,\n        crimson: 14423100,\n        cyan: 65535,\n        darkblue: 139,\n        darkcyan: 35723,\n        darkgoldenrod: 12092939,\n        darkgray: 11119017,\n        darkgreen: 25600,\n        darkgrey: 11119017,\n        darkkhaki: 12433259,\n        darkmagenta: 9109643,\n        darkolivegreen: 5597999,\n        darkorange: 16747520,\n        darkorchid: 10040012,\n        darkred: 9109504,\n        darksalmon: 15308410,\n        darkseagreen: 9419919,\n        darkslateblue: 4734347,\n        darkslategray: 3100495,\n        darkslategrey: 3100495,\n        darkturquoise: 52945,\n        darkviolet: 9699539,\n        deeppink: 16716947,\n        deepskyblue: 49151,\n        dimgray: 6908265,\n        dimgrey: 6908265,\n        dodgerblue: 2003199,\n        firebrick: 11674146,\n        floralwhite: 16775920,\n        forestgreen: 2263842,\n        fuchsia: 16711935,\n        gainsboro: 14474460,\n        ghostwhite: 16316671,\n        gold: 16766720,\n        goldenrod: 14329120,\n        gray: 8421504,\n        green: 32768,\n        greenyellow: 11403055,\n        grey: 8421504,\n        honeydew: 15794160,\n        hotpink: 16738740,\n        indianred: 13458524,\n        indigo: 4915330,\n        ivory: 16777200,\n        khaki: 15787660,\n        lavender: 15132410,\n        lavenderblush: 16773365,\n        lawngreen: 8190976,\n        lemonchiffon: 16775885,\n        lightblue: 11393254,\n        lightcoral: 15761536,\n        lightcyan: 14745599,\n        lightgoldenrodyellow: 16448210,\n        lightgray: 13882323,\n        lightgreen: 9498256,\n        lightgrey: 13882323,\n        lightpink: 16758465,\n        lightsalmon: 16752762,\n        lightseagreen: 2142890,\n        lightskyblue: 8900346,\n        lightslategray: 7833753,\n        lightslategrey: 7833753,\n        lightsteelblue: 11584734,\n        lightyellow: 16777184,\n        lime: 65280,\n        limegreen: 3329330,\n        linen: 16445670,\n        magenta: 16711935,\n        maroon: 8388608,\n        mediumaquamarine: 6737322,\n        mediumblue: 205,\n        mediumorchid: 12211667,\n        mediumpurple: 9662683,\n        mediumseagreen: 3978097,\n        mediumslateblue: 8087790,\n        mediumspringgreen: 64154,\n        mediumturquoise: 4772300,\n        mediumvioletred: 13047173,\n        midnightblue: 1644912,\n        mintcream: 16121850,\n        mistyrose: 16770273,\n        moccasin: 16770229,\n        navajowhite: 16768685,\n        navy: 128,\n        oldlace: 16643558,\n        olive: 8421376,\n        olivedrab: 7048739,\n        orange: 16753920,\n        orangered: 16729344,\n        orchid: 14315734,\n        palegoldenrod: 15657130,\n        palegreen: 10025880,\n        paleturquoise: 11529966,\n        palevioletred: 14381203,\n        papayawhip: 16773077,\n        peachpuff: 16767673,\n        peru: 13468991,\n        pink: 16761035,\n        plum: 14524637,\n        powderblue: 11591910,\n        purple: 8388736,\n        rebeccapurple: 6697881,\n        red: 16711680,\n        rosybrown: 12357519,\n        royalblue: 4286945,\n        saddlebrown: 9127187,\n        salmon: 16416882,\n        sandybrown: 16032864,\n        seagreen: 3050327,\n        seashell: 16774638,\n        sienna: 10506797,\n        silver: 12632256,\n        skyblue: 8900331,\n        slateblue: 6970061,\n        slategray: 7372944,\n        slategrey: 7372944,\n        snow: 16775930,\n        springgreen: 65407,\n        steelblue: 4620980,\n        tan: 13808780,\n        teal: 32896,\n        thistle: 14204888,\n        tomato: 16737095,\n        turquoise: 4251856,\n        violet: 15631086,\n        wheat: 16113331,\n        white: 16777215,\n        whitesmoke: 16119285,\n        yellow: 16776960,\n        yellowgreen: 10145074,\n      },\n      Ke = { h: 0, s: 0, l: 0 },\n      $e = { h: 0, s: 0, l: 0 };\n    function tn(t, e, n) {\n      return (\n        n < 0 && (n += 1),\n        n > 1 && (n -= 1),\n        n < 1 / 6\n          ? t + 6 * (e - t) * n\n          : n < 0.5\n          ? e\n          : n < 2 / 3\n          ? t + 6 * (e - t) * (2 / 3 - n)\n          : t\n      );\n    }\n    function en(t) {\n      return t < 0.04045\n        ? 0.0773993808 * t\n        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);\n    }\n    function nn(t) {\n      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;\n    }\n    class rn {\n      constructor(t, e, n) {\n        return void 0 === e && void 0 === n\n          ? this.set(t)\n          : this.setRGB(t, e, n);\n      }\n      set(t) {\n        return (\n          t && t.isColor\n            ? this.copy(t)\n            : \"number\" == typeof t\n            ? this.setHex(t)\n            : \"string\" == typeof t && this.setStyle(t),\n          this\n        );\n      }\n      setScalar(t) {\n        return (this.r = t), (this.g = t), (this.b = t), this;\n      }\n      setHex(t) {\n        return (\n          (t = Math.floor(t)),\n          (this.r = ((t >> 16) & 255) / 255),\n          (this.g = ((t >> 8) & 255) / 255),\n          (this.b = (255 & t) / 255),\n          this\n        );\n      }\n      setRGB(t, e, n) {\n        return (this.r = t), (this.g = e), (this.b = n), this;\n      }\n      setHSL(t, e, n) {\n        if (((t = dt(t, 1)), (e = ut(e, 0, 1)), (n = ut(n, 0, 1)), 0 === e))\n          this.r = this.g = this.b = n;\n        else {\n          const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,\n            r = 2 * n - i;\n          (this.r = tn(r, i, t + 1 / 3)),\n            (this.g = tn(r, i, t)),\n            (this.b = tn(r, i, t - 1 / 3));\n        }\n        return this;\n      }\n      setStyle(t) {\n        function e(e) {\n          void 0 !== e &&\n            parseFloat(e) < 1 &&\n            console.warn(\n              \"THREE.Color: Alpha component of \" + t + \" will be ignored.\"\n            );\n        }\n        let n;\n        if ((n = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(t))) {\n          let t;\n          const i = n[1],\n            r = n[2];\n          switch (i) {\n            case \"rgb\":\n            case \"rgba\":\n              if (\n                (t =\n                  /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                    r\n                  ))\n              )\n                return (\n                  (this.r = Math.min(255, parseInt(t[1], 10)) / 255),\n                  (this.g = Math.min(255, parseInt(t[2], 10)) / 255),\n                  (this.b = Math.min(255, parseInt(t[3], 10)) / 255),\n                  e(t[4]),\n                  this\n                );\n              if (\n                (t =\n                  /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                    r\n                  ))\n              )\n                return (\n                  (this.r = Math.min(100, parseInt(t[1], 10)) / 100),\n                  (this.g = Math.min(100, parseInt(t[2], 10)) / 100),\n                  (this.b = Math.min(100, parseInt(t[3], 10)) / 100),\n                  e(t[4]),\n                  this\n                );\n              break;\n            case \"hsl\":\n            case \"hsla\":\n              if (\n                (t =\n                  /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n                    r\n                  ))\n              ) {\n                const n = parseFloat(t[1]) / 360,\n                  i = parseInt(t[2], 10) / 100,\n                  r = parseInt(t[3], 10) / 100;\n                return e(t[4]), this.setHSL(n, i, r);\n              }\n          }\n        } else if ((n = /^\\#([A-Fa-f\\d]+)$/.exec(t))) {\n          const t = n[1],\n            e = t.length;\n          if (3 === e)\n            return (\n              (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),\n              (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),\n              (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),\n              this\n            );\n          if (6 === e)\n            return (\n              (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),\n              (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),\n              (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),\n              this\n            );\n        }\n        return t && t.length > 0 ? this.setColorName(t) : this;\n      }\n      setColorName(t) {\n        const e = Qe[t.toLowerCase()];\n        return (\n          void 0 !== e\n            ? this.setHex(e)\n            : console.warn(\"THREE.Color: Unknown color \" + t),\n          this\n        );\n      }\n      clone() {\n        return new this.constructor(this.r, this.g, this.b);\n      }\n      copy(t) {\n        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;\n      }\n      copyGammaToLinear(t, e = 2) {\n        return (\n          (this.r = Math.pow(t.r, e)),\n          (this.g = Math.pow(t.g, e)),\n          (this.b = Math.pow(t.b, e)),\n          this\n        );\n      }\n      copyLinearToGamma(t, e = 2) {\n        const n = e > 0 ? 1 / e : 1;\n        return (\n          (this.r = Math.pow(t.r, n)),\n          (this.g = Math.pow(t.g, n)),\n          (this.b = Math.pow(t.b, n)),\n          this\n        );\n      }\n      convertGammaToLinear(t) {\n        return this.copyGammaToLinear(this, t), this;\n      }\n      convertLinearToGamma(t) {\n        return this.copyLinearToGamma(this, t), this;\n      }\n      copySRGBToLinear(t) {\n        return (this.r = en(t.r)), (this.g = en(t.g)), (this.b = en(t.b)), this;\n      }\n      copyLinearToSRGB(t) {\n        return (this.r = nn(t.r)), (this.g = nn(t.g)), (this.b = nn(t.b)), this;\n      }\n      convertSRGBToLinear() {\n        return this.copySRGBToLinear(this), this;\n      }\n      convertLinearToSRGB() {\n        return this.copyLinearToSRGB(this), this;\n      }\n      getHex() {\n        return (\n          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)\n        );\n      }\n      getHexString() {\n        return (\"000000\" + this.getHex().toString(16)).slice(-6);\n      }\n      getHSL(t) {\n        const e = this.r,\n          n = this.g,\n          i = this.b,\n          r = Math.max(e, n, i),\n          s = Math.min(e, n, i);\n        let a, o;\n        const l = (s + r) / 2;\n        if (s === r) (a = 0), (o = 0);\n        else {\n          const t = r - s;\n          switch (((o = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {\n            case e:\n              a = (n - i) / t + (n < i ? 6 : 0);\n              break;\n            case n:\n              a = (i - e) / t + 2;\n              break;\n            case i:\n              a = (e - n) / t + 4;\n          }\n          a /= 6;\n        }\n        return (t.h = a), (t.s = o), (t.l = l), t;\n      }\n      getStyle() {\n        return (\n          \"rgb(\" +\n          ((255 * this.r) | 0) +\n          \",\" +\n          ((255 * this.g) | 0) +\n          \",\" +\n          ((255 * this.b) | 0) +\n          \")\"\n        );\n      }\n      offsetHSL(t, e, n) {\n        return (\n          this.getHSL(Ke),\n          (Ke.h += t),\n          (Ke.s += e),\n          (Ke.l += n),\n          this.setHSL(Ke.h, Ke.s, Ke.l),\n          this\n        );\n      }\n      add(t) {\n        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;\n      }\n      addColors(t, e) {\n        return (\n          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this\n        );\n      }\n      addScalar(t) {\n        return (this.r += t), (this.g += t), (this.b += t), this;\n      }\n      sub(t) {\n        return (\n          (this.r = Math.max(0, this.r - t.r)),\n          (this.g = Math.max(0, this.g - t.g)),\n          (this.b = Math.max(0, this.b - t.b)),\n          this\n        );\n      }\n      multiply(t) {\n        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;\n      }\n      multiplyScalar(t) {\n        return (this.r *= t), (this.g *= t), (this.b *= t), this;\n      }\n      lerp(t, e) {\n        return (\n          (this.r += (t.r - this.r) * e),\n          (this.g += (t.g - this.g) * e),\n          (this.b += (t.b - this.b) * e),\n          this\n        );\n      }\n      lerpColors(t, e, n) {\n        return (\n          (this.r = t.r + (e.r - t.r) * n),\n          (this.g = t.g + (e.g - t.g) * n),\n          (this.b = t.b + (e.b - t.b) * n),\n          this\n        );\n      }\n      lerpHSL(t, e) {\n        this.getHSL(Ke), t.getHSL($e);\n        const n = pt(Ke.h, $e.h, e),\n          i = pt(Ke.s, $e.s, e),\n          r = pt(Ke.l, $e.l, e);\n        return this.setHSL(n, i, r), this;\n      }\n      equals(t) {\n        return t.r === this.r && t.g === this.g && t.b === this.b;\n      }\n      fromArray(t, e = 0) {\n        return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;\n      }\n      toArray(t = [], e = 0) {\n        return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;\n      }\n      fromBufferAttribute(t, e) {\n        return (\n          (this.r = t.getX(e)),\n          (this.g = t.getY(e)),\n          (this.b = t.getZ(e)),\n          !0 === t.normalized &&\n            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),\n          this\n        );\n      }\n      toJSON() {\n        return this.getHex();\n      }\n    }\n    (rn.NAMES = Qe),\n      (rn.prototype.isColor = !0),\n      (rn.prototype.r = 1),\n      (rn.prototype.g = 1),\n      (rn.prototype.b = 1);\n    class sn extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshBasicMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.map = null),\n          (this.lightMap = null),\n          (this.lightMapIntensity = 1),\n          (this.aoMap = null),\n          (this.aoMapIntensity = 1),\n          (this.specularMap = null),\n          (this.alphaMap = null),\n          (this.envMap = null),\n          (this.combine = 0),\n          (this.reflectivity = 1),\n          (this.refractionRatio = 0.98),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.wireframeLinecap = \"round\"),\n          (this.wireframeLinejoin = \"round\"),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.map = t.map),\n          (this.lightMap = t.lightMap),\n          (this.lightMapIntensity = t.lightMapIntensity),\n          (this.aoMap = t.aoMap),\n          (this.aoMapIntensity = t.aoMapIntensity),\n          (this.specularMap = t.specularMap),\n          (this.alphaMap = t.alphaMap),\n          (this.envMap = t.envMap),\n          (this.combine = t.combine),\n          (this.reflectivity = t.reflectivity),\n          (this.refractionRatio = t.refractionRatio),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.wireframeLinecap = t.wireframeLinecap),\n          (this.wireframeLinejoin = t.wireframeLinejoin),\n          this\n        );\n      }\n    }\n    sn.prototype.isMeshBasicMaterial = !0;\n    const an = new zt(),\n      on = new yt();\n    class ln {\n      constructor(t, e, n) {\n        if (Array.isArray(t))\n          throw new TypeError(\n            \"THREE.BufferAttribute: array should be a Typed Array.\"\n          );\n        (this.name = \"\"),\n          (this.array = t),\n          (this.itemSize = e),\n          (this.count = void 0 !== t ? t.length / e : 0),\n          (this.normalized = !0 === n),\n          (this.usage = et),\n          (this.updateRange = { offset: 0, count: -1 }),\n          (this.version = 0);\n      }\n      onUploadCallback() {}\n      set needsUpdate(t) {\n        !0 === t && this.version++;\n      }\n      setUsage(t) {\n        return (this.usage = t), this;\n      }\n      copy(t) {\n        return (\n          (this.name = t.name),\n          (this.array = new t.array.constructor(t.array)),\n          (this.itemSize = t.itemSize),\n          (this.count = t.count),\n          (this.normalized = t.normalized),\n          (this.usage = t.usage),\n          this\n        );\n      }\n      copyAt(t, e, n) {\n        (t *= this.itemSize), (n *= e.itemSize);\n        for (let i = 0, r = this.itemSize; i < r; i++)\n          this.array[t + i] = e.array[n + i];\n        return this;\n      }\n      copyArray(t) {\n        return this.array.set(t), this;\n      }\n      copyColorsArray(t) {\n        const e = this.array;\n        let n = 0;\n        for (let i = 0, r = t.length; i < r; i++) {\n          let r = t[i];\n          void 0 === r &&\n            (console.warn(\n              \"THREE.BufferAttribute.copyColorsArray(): color is undefined\",\n              i\n            ),\n            (r = new rn())),\n            (e[n++] = r.r),\n            (e[n++] = r.g),\n            (e[n++] = r.b);\n        }\n        return this;\n      }\n      copyVector2sArray(t) {\n        const e = this.array;\n        let n = 0;\n        for (let i = 0, r = t.length; i < r; i++) {\n          let r = t[i];\n          void 0 === r &&\n            (console.warn(\n              \"THREE.BufferAttribute.copyVector2sArray(): vector is undefined\",\n              i\n            ),\n            (r = new yt())),\n            (e[n++] = r.x),\n            (e[n++] = r.y);\n        }\n        return this;\n      }\n      copyVector3sArray(t) {\n        const e = this.array;\n        let n = 0;\n        for (let i = 0, r = t.length; i < r; i++) {\n          let r = t[i];\n          void 0 === r &&\n            (console.warn(\n              \"THREE.BufferAttribute.copyVector3sArray(): vector is undefined\",\n              i\n            ),\n            (r = new zt())),\n            (e[n++] = r.x),\n            (e[n++] = r.y),\n            (e[n++] = r.z);\n        }\n        return this;\n      }\n      copyVector4sArray(t) {\n        const e = this.array;\n        let n = 0;\n        for (let i = 0, r = t.length; i < r; i++) {\n          let r = t[i];\n          void 0 === r &&\n            (console.warn(\n              \"THREE.BufferAttribute.copyVector4sArray(): vector is undefined\",\n              i\n            ),\n            (r = new Ct())),\n            (e[n++] = r.x),\n            (e[n++] = r.y),\n            (e[n++] = r.z),\n            (e[n++] = r.w);\n        }\n        return this;\n      }\n      applyMatrix3(t) {\n        if (2 === this.itemSize)\n          for (let e = 0, n = this.count; e < n; e++)\n            on.fromBufferAttribute(this, e),\n              on.applyMatrix3(t),\n              this.setXY(e, on.x, on.y);\n        else if (3 === this.itemSize)\n          for (let e = 0, n = this.count; e < n; e++)\n            an.fromBufferAttribute(this, e),\n              an.applyMatrix3(t),\n              this.setXYZ(e, an.x, an.y, an.z);\n        return this;\n      }\n      applyMatrix4(t) {\n        for (let e = 0, n = this.count; e < n; e++)\n          (an.x = this.getX(e)),\n            (an.y = this.getY(e)),\n            (an.z = this.getZ(e)),\n            an.applyMatrix4(t),\n            this.setXYZ(e, an.x, an.y, an.z);\n        return this;\n      }\n      applyNormalMatrix(t) {\n        for (let e = 0, n = this.count; e < n; e++)\n          (an.x = this.getX(e)),\n            (an.y = this.getY(e)),\n            (an.z = this.getZ(e)),\n            an.applyNormalMatrix(t),\n            this.setXYZ(e, an.x, an.y, an.z);\n        return this;\n      }\n      transformDirection(t) {\n        for (let e = 0, n = this.count; e < n; e++)\n          (an.x = this.getX(e)),\n            (an.y = this.getY(e)),\n            (an.z = this.getZ(e)),\n            an.transformDirection(t),\n            this.setXYZ(e, an.x, an.y, an.z);\n        return this;\n      }\n      set(t, e = 0) {\n        return this.array.set(t, e), this;\n      }\n      getX(t) {\n        return this.array[t * this.itemSize];\n      }\n      setX(t, e) {\n        return (this.array[t * this.itemSize] = e), this;\n      }\n      getY(t) {\n        return this.array[t * this.itemSize + 1];\n      }\n      setY(t, e) {\n        return (this.array[t * this.itemSize + 1] = e), this;\n      }\n      getZ(t) {\n        return this.array[t * this.itemSize + 2];\n      }\n      setZ(t, e) {\n        return (this.array[t * this.itemSize + 2] = e), this;\n      }\n      getW(t) {\n        return this.array[t * this.itemSize + 3];\n      }\n      setW(t, e) {\n        return (this.array[t * this.itemSize + 3] = e), this;\n      }\n      setXY(t, e, n) {\n        return (\n          (t *= this.itemSize),\n          (this.array[t + 0] = e),\n          (this.array[t + 1] = n),\n          this\n        );\n      }\n      setXYZ(t, e, n, i) {\n        return (\n          (t *= this.itemSize),\n          (this.array[t + 0] = e),\n          (this.array[t + 1] = n),\n          (this.array[t + 2] = i),\n          this\n        );\n      }\n      setXYZW(t, e, n, i, r) {\n        return (\n          (t *= this.itemSize),\n          (this.array[t + 0] = e),\n          (this.array[t + 1] = n),\n          (this.array[t + 2] = i),\n          (this.array[t + 3] = r),\n          this\n        );\n      }\n      onUpload(t) {\n        return (this.onUploadCallback = t), this;\n      }\n      clone() {\n        return new this.constructor(this.array, this.itemSize).copy(this);\n      }\n      toJSON() {\n        const t = {\n          itemSize: this.itemSize,\n          type: this.array.constructor.name,\n          array: Array.prototype.slice.call(this.array),\n          normalized: this.normalized,\n        };\n        return (\n          \"\" !== this.name && (t.name = this.name),\n          this.usage !== et && (t.usage = this.usage),\n          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||\n            (t.updateRange = this.updateRange),\n          t\n        );\n      }\n    }\n    ln.prototype.isBufferAttribute = !0;\n    class cn extends ln {\n      constructor(t, e, n) {\n        super(new Int8Array(t), e, n);\n      }\n    }\n    class hn extends ln {\n      constructor(t, e, n) {\n        super(new Uint8Array(t), e, n);\n      }\n    }\n    class un extends ln {\n      constructor(t, e, n) {\n        super(new Uint8ClampedArray(t), e, n);\n      }\n    }\n    class dn extends ln {\n      constructor(t, e, n) {\n        super(new Int16Array(t), e, n);\n      }\n    }\n    class pn extends ln {\n      constructor(t, e, n) {\n        super(new Uint16Array(t), e, n);\n      }\n    }\n    class mn extends ln {\n      constructor(t, e, n) {\n        super(new Int32Array(t), e, n);\n      }\n    }\n    class fn extends ln {\n      constructor(t, e, n) {\n        super(new Uint32Array(t), e, n);\n      }\n    }\n    class gn extends ln {\n      constructor(t, e, n) {\n        super(new Uint16Array(t), e, n);\n      }\n    }\n    gn.prototype.isFloat16BufferAttribute = !0;\n    class vn extends ln {\n      constructor(t, e, n) {\n        super(new Float32Array(t), e, n);\n      }\n    }\n    class yn extends ln {\n      constructor(t, e, n) {\n        super(new Float64Array(t), e, n);\n      }\n    }\n    let xn = 0;\n    const _n = new de(),\n      Mn = new Fe(),\n      bn = new zt(),\n      wn = new Ot(),\n      Sn = new Ot(),\n      Tn = new zt();\n    class En extends rt {\n      constructor() {\n        super(),\n          Object.defineProperty(this, \"id\", { value: xn++ }),\n          (this.uuid = ht()),\n          (this.name = \"\"),\n          (this.type = \"BufferGeometry\"),\n          (this.index = null),\n          (this.attributes = {}),\n          (this.morphAttributes = {}),\n          (this.morphTargetsRelative = !1),\n          (this.groups = []),\n          (this.boundingBox = null),\n          (this.boundingSphere = null),\n          (this.drawRange = { start: 0, count: 1 / 0 }),\n          (this.userData = {});\n      }\n      getIndex() {\n        return this.index;\n      }\n      setIndex(t) {\n        return (\n          Array.isArray(t)\n            ? (this.index = new (_t(t) > 65535 ? fn : pn)(t, 1))\n            : (this.index = t),\n          this\n        );\n      }\n      getAttribute(t) {\n        return this.attributes[t];\n      }\n      setAttribute(t, e) {\n        return (this.attributes[t] = e), this;\n      }\n      deleteAttribute(t) {\n        return delete this.attributes[t], this;\n      }\n      hasAttribute(t) {\n        return void 0 !== this.attributes[t];\n      }\n      addGroup(t, e, n = 0) {\n        this.groups.push({ start: t, count: e, materialIndex: n });\n      }\n      clearGroups() {\n        this.groups = [];\n      }\n      setDrawRange(t, e) {\n        (this.drawRange.start = t), (this.drawRange.count = e);\n      }\n      applyMatrix4(t) {\n        const e = this.attributes.position;\n        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));\n        const n = this.attributes.normal;\n        if (void 0 !== n) {\n          const e = new xt().getNormalMatrix(t);\n          n.applyNormalMatrix(e), (n.needsUpdate = !0);\n        }\n        const i = this.attributes.tangent;\n        return (\n          void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),\n          null !== this.boundingBox && this.computeBoundingBox(),\n          null !== this.boundingSphere && this.computeBoundingSphere(),\n          this\n        );\n      }\n      applyQuaternion(t) {\n        return _n.makeRotationFromQuaternion(t), this.applyMatrix4(_n), this;\n      }\n      rotateX(t) {\n        return _n.makeRotationX(t), this.applyMatrix4(_n), this;\n      }\n      rotateY(t) {\n        return _n.makeRotationY(t), this.applyMatrix4(_n), this;\n      }\n      rotateZ(t) {\n        return _n.makeRotationZ(t), this.applyMatrix4(_n), this;\n      }\n      translate(t, e, n) {\n        return _n.makeTranslation(t, e, n), this.applyMatrix4(_n), this;\n      }\n      scale(t, e, n) {\n        return _n.makeScale(t, e, n), this.applyMatrix4(_n), this;\n      }\n      lookAt(t) {\n        return (\n          Mn.lookAt(t), Mn.updateMatrix(), this.applyMatrix4(Mn.matrix), this\n        );\n      }\n      center() {\n        return (\n          this.computeBoundingBox(),\n          this.boundingBox.getCenter(bn).negate(),\n          this.translate(bn.x, bn.y, bn.z),\n          this\n        );\n      }\n      setFromPoints(t) {\n        const e = [];\n        for (let n = 0, i = t.length; n < i; n++) {\n          const i = t[n];\n          e.push(i.x, i.y, i.z || 0);\n        }\n        return this.setAttribute(\"position\", new vn(e, 3)), this;\n      }\n      computeBoundingBox() {\n        null === this.boundingBox && (this.boundingBox = new Ot());\n        const t = this.attributes.position,\n          e = this.morphAttributes.position;\n        if (t && t.isGLBufferAttribute)\n          return (\n            console.error(\n              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n              this\n            ),\n            void this.boundingBox.set(\n              new zt(-1 / 0, -1 / 0, -1 / 0),\n              new zt(1 / 0, 1 / 0, 1 / 0)\n            )\n          );\n        if (void 0 !== t) {\n          if ((this.boundingBox.setFromBufferAttribute(t), e))\n            for (let t = 0, n = e.length; t < n; t++) {\n              const n = e[t];\n              wn.setFromBufferAttribute(n),\n                this.morphTargetsRelative\n                  ? (Tn.addVectors(this.boundingBox.min, wn.min),\n                    this.boundingBox.expandByPoint(Tn),\n                    Tn.addVectors(this.boundingBox.max, wn.max),\n                    this.boundingBox.expandByPoint(Tn))\n                  : (this.boundingBox.expandByPoint(wn.min),\n                    this.boundingBox.expandByPoint(wn.max));\n            }\n        } else this.boundingBox.makeEmpty();\n        (isNaN(this.boundingBox.min.x) ||\n          isNaN(this.boundingBox.min.y) ||\n          isNaN(this.boundingBox.min.z)) &&\n          console.error(\n            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.',\n            this\n          );\n      }\n      computeBoundingSphere() {\n        null === this.boundingSphere && (this.boundingSphere = new ie());\n        const t = this.attributes.position,\n          e = this.morphAttributes.position;\n        if (t && t.isGLBufferAttribute)\n          return (\n            console.error(\n              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".',\n              this\n            ),\n            void this.boundingSphere.set(new zt(), 1 / 0)\n          );\n        if (t) {\n          const n = this.boundingSphere.center;\n          if ((wn.setFromBufferAttribute(t), e))\n            for (let t = 0, n = e.length; t < n; t++) {\n              const n = e[t];\n              Sn.setFromBufferAttribute(n),\n                this.morphTargetsRelative\n                  ? (Tn.addVectors(wn.min, Sn.min),\n                    wn.expandByPoint(Tn),\n                    Tn.addVectors(wn.max, Sn.max),\n                    wn.expandByPoint(Tn))\n                  : (wn.expandByPoint(Sn.min), wn.expandByPoint(Sn.max));\n            }\n          wn.getCenter(n);\n          let i = 0;\n          for (let e = 0, r = t.count; e < r; e++)\n            Tn.fromBufferAttribute(t, e),\n              (i = Math.max(i, n.distanceToSquared(Tn)));\n          if (e)\n            for (let r = 0, s = e.length; r < s; r++) {\n              const s = e[r],\n                a = this.morphTargetsRelative;\n              for (let e = 0, r = s.count; e < r; e++)\n                Tn.fromBufferAttribute(s, e),\n                  a && (bn.fromBufferAttribute(t, e), Tn.add(bn)),\n                  (i = Math.max(i, n.distanceToSquared(Tn)));\n            }\n          (this.boundingSphere.radius = Math.sqrt(i)),\n            isNaN(this.boundingSphere.radius) &&\n              console.error(\n                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.',\n                this\n              );\n        }\n      }\n      computeTangents() {\n        const t = this.index,\n          e = this.attributes;\n        if (\n          null === t ||\n          void 0 === e.position ||\n          void 0 === e.normal ||\n          void 0 === e.uv\n        )\n          return void console.error(\n            \"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\"\n          );\n        const n = t.array,\n          i = e.position.array,\n          r = e.normal.array,\n          s = e.uv.array,\n          a = i.length / 3;\n        void 0 === e.tangent &&\n          this.setAttribute(\"tangent\", new ln(new Float32Array(4 * a), 4));\n        const o = e.tangent.array,\n          l = [],\n          c = [];\n        for (let t = 0; t < a; t++) (l[t] = new zt()), (c[t] = new zt());\n        const h = new zt(),\n          u = new zt(),\n          d = new zt(),\n          p = new yt(),\n          m = new yt(),\n          f = new yt(),\n          g = new zt(),\n          v = new zt();\n        function y(t, e, n) {\n          h.fromArray(i, 3 * t),\n            u.fromArray(i, 3 * e),\n            d.fromArray(i, 3 * n),\n            p.fromArray(s, 2 * t),\n            m.fromArray(s, 2 * e),\n            f.fromArray(s, 2 * n),\n            u.sub(h),\n            d.sub(h),\n            m.sub(p),\n            f.sub(p);\n          const r = 1 / (m.x * f.y - f.x * m.y);\n          isFinite(r) &&\n            (g\n              .copy(u)\n              .multiplyScalar(f.y)\n              .addScaledVector(d, -m.y)\n              .multiplyScalar(r),\n            v\n              .copy(d)\n              .multiplyScalar(m.x)\n              .addScaledVector(u, -f.x)\n              .multiplyScalar(r),\n            l[t].add(g),\n            l[e].add(g),\n            l[n].add(g),\n            c[t].add(v),\n            c[e].add(v),\n            c[n].add(v));\n        }\n        let x = this.groups;\n        0 === x.length && (x = [{ start: 0, count: n.length }]);\n        for (let t = 0, e = x.length; t < e; ++t) {\n          const e = x[t],\n            i = e.start;\n          for (let t = i, r = i + e.count; t < r; t += 3)\n            y(n[t + 0], n[t + 1], n[t + 2]);\n        }\n        const _ = new zt(),\n          M = new zt(),\n          b = new zt(),\n          w = new zt();\n        function S(t) {\n          b.fromArray(r, 3 * t), w.copy(b);\n          const e = l[t];\n          _.copy(e),\n            _.sub(b.multiplyScalar(b.dot(e))).normalize(),\n            M.crossVectors(w, e);\n          const n = M.dot(c[t]) < 0 ? -1 : 1;\n          (o[4 * t] = _.x),\n            (o[4 * t + 1] = _.y),\n            (o[4 * t + 2] = _.z),\n            (o[4 * t + 3] = n);\n        }\n        for (let t = 0, e = x.length; t < e; ++t) {\n          const e = x[t],\n            i = e.start;\n          for (let t = i, r = i + e.count; t < r; t += 3)\n            S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);\n        }\n      }\n      computeVertexNormals() {\n        const t = this.index,\n          e = this.getAttribute(\"position\");\n        if (void 0 !== e) {\n          let n = this.getAttribute(\"normal\");\n          if (void 0 === n)\n            (n = new ln(new Float32Array(3 * e.count), 3)),\n              this.setAttribute(\"normal\", n);\n          else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);\n          const i = new zt(),\n            r = new zt(),\n            s = new zt(),\n            a = new zt(),\n            o = new zt(),\n            l = new zt(),\n            c = new zt(),\n            h = new zt();\n          if (t)\n            for (let u = 0, d = t.count; u < d; u += 3) {\n              const d = t.getX(u + 0),\n                p = t.getX(u + 1),\n                m = t.getX(u + 2);\n              i.fromBufferAttribute(e, d),\n                r.fromBufferAttribute(e, p),\n                s.fromBufferAttribute(e, m),\n                c.subVectors(s, r),\n                h.subVectors(i, r),\n                c.cross(h),\n                a.fromBufferAttribute(n, d),\n                o.fromBufferAttribute(n, p),\n                l.fromBufferAttribute(n, m),\n                a.add(c),\n                o.add(c),\n                l.add(c),\n                n.setXYZ(d, a.x, a.y, a.z),\n                n.setXYZ(p, o.x, o.y, o.z),\n                n.setXYZ(m, l.x, l.y, l.z);\n            }\n          else\n            for (let t = 0, a = e.count; t < a; t += 3)\n              i.fromBufferAttribute(e, t + 0),\n                r.fromBufferAttribute(e, t + 1),\n                s.fromBufferAttribute(e, t + 2),\n                c.subVectors(s, r),\n                h.subVectors(i, r),\n                c.cross(h),\n                n.setXYZ(t + 0, c.x, c.y, c.z),\n                n.setXYZ(t + 1, c.x, c.y, c.z),\n                n.setXYZ(t + 2, c.x, c.y, c.z);\n          this.normalizeNormals(), (n.needsUpdate = !0);\n        }\n      }\n      merge(t, e) {\n        if (!t || !t.isBufferGeometry)\n          return void console.error(\n            \"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\",\n            t\n          );\n        void 0 === e &&\n          ((e = 0),\n          console.warn(\n            \"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.\"\n          ));\n        const n = this.attributes;\n        for (const i in n) {\n          if (void 0 === t.attributes[i]) continue;\n          const r = n[i].array,\n            s = t.attributes[i],\n            a = s.array,\n            o = s.itemSize * e,\n            l = Math.min(a.length, r.length - o);\n          for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t];\n        }\n        return this;\n      }\n      normalizeNormals() {\n        const t = this.attributes.normal;\n        for (let e = 0, n = t.count; e < n; e++)\n          Tn.fromBufferAttribute(t, e),\n            Tn.normalize(),\n            t.setXYZ(e, Tn.x, Tn.y, Tn.z);\n      }\n      toNonIndexed() {\n        function t(t, e) {\n          const n = t.array,\n            i = t.itemSize,\n            r = t.normalized,\n            s = new n.constructor(e.length * i);\n          let a = 0,\n            o = 0;\n          for (let r = 0, l = e.length; r < l; r++) {\n            a = t.isInterleavedBufferAttribute\n              ? e[r] * t.data.stride + t.offset\n              : e[r] * i;\n            for (let t = 0; t < i; t++) s[o++] = n[a++];\n          }\n          return new ln(s, i, r);\n        }\n        if (null === this.index)\n          return (\n            console.warn(\n              \"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\"\n            ),\n            this\n          );\n        const e = new En(),\n          n = this.index.array,\n          i = this.attributes;\n        for (const r in i) {\n          const s = t(i[r], n);\n          e.setAttribute(r, s);\n        }\n        const r = this.morphAttributes;\n        for (const i in r) {\n          const s = [],\n            a = r[i];\n          for (let e = 0, i = a.length; e < i; e++) {\n            const i = t(a[e], n);\n            s.push(i);\n          }\n          e.morphAttributes[i] = s;\n        }\n        e.morphTargetsRelative = this.morphTargetsRelative;\n        const s = this.groups;\n        for (let t = 0, n = s.length; t < n; t++) {\n          const n = s[t];\n          e.addGroup(n.start, n.count, n.materialIndex);\n        }\n        return e;\n      }\n      toJSON() {\n        const t = {\n          metadata: {\n            version: 4.5,\n            type: \"BufferGeometry\",\n            generator: \"BufferGeometry.toJSON\",\n          },\n        };\n        if (\n          ((t.uuid = this.uuid),\n          (t.type = this.type),\n          \"\" !== this.name && (t.name = this.name),\n          Object.keys(this.userData).length > 0 && (t.userData = this.userData),\n          void 0 !== this.parameters)\n        ) {\n          const e = this.parameters;\n          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);\n          return t;\n        }\n        t.data = { attributes: {} };\n        const e = this.index;\n        null !== e &&\n          (t.data.index = {\n            type: e.array.constructor.name,\n            array: Array.prototype.slice.call(e.array),\n          });\n        const n = this.attributes;\n        for (const e in n) {\n          const i = n[e];\n          t.data.attributes[e] = i.toJSON(t.data);\n        }\n        const i = {};\n        let r = !1;\n        for (const e in this.morphAttributes) {\n          const n = this.morphAttributes[e],\n            s = [];\n          for (let e = 0, i = n.length; e < i; e++) {\n            const i = n[e];\n            s.push(i.toJSON(t.data));\n          }\n          s.length > 0 && ((i[e] = s), (r = !0));\n        }\n        r &&\n          ((t.data.morphAttributes = i),\n          (t.data.morphTargetsRelative = this.morphTargetsRelative));\n        const s = this.groups;\n        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));\n        const a = this.boundingSphere;\n        return (\n          null !== a &&\n            (t.data.boundingSphere = {\n              center: a.center.toArray(),\n              radius: a.radius,\n            }),\n          t\n        );\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        (this.index = null),\n          (this.attributes = {}),\n          (this.morphAttributes = {}),\n          (this.groups = []),\n          (this.boundingBox = null),\n          (this.boundingSphere = null);\n        const e = {};\n        this.name = t.name;\n        const n = t.index;\n        null !== n && this.setIndex(n.clone(e));\n        const i = t.attributes;\n        for (const t in i) {\n          const n = i[t];\n          this.setAttribute(t, n.clone(e));\n        }\n        const r = t.morphAttributes;\n        for (const t in r) {\n          const n = [],\n            i = r[t];\n          for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));\n          this.morphAttributes[t] = n;\n        }\n        this.morphTargetsRelative = t.morphTargetsRelative;\n        const s = t.groups;\n        for (let t = 0, e = s.length; t < e; t++) {\n          const e = s[t];\n          this.addGroup(e.start, e.count, e.materialIndex);\n        }\n        const a = t.boundingBox;\n        null !== a && (this.boundingBox = a.clone());\n        const o = t.boundingSphere;\n        return (\n          null !== o && (this.boundingSphere = o.clone()),\n          (this.drawRange.start = t.drawRange.start),\n          (this.drawRange.count = t.drawRange.count),\n          (this.userData = t.userData),\n          void 0 !== t.parameters &&\n            (this.parameters = Object.assign({}, t.parameters)),\n          this\n        );\n      }\n      dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n    }\n    En.prototype.isBufferGeometry = !0;\n    const An = new de(),\n      Ln = new ue(),\n      Rn = new ie(),\n      Cn = new zt(),\n      Pn = new zt(),\n      In = new zt(),\n      Dn = new zt(),\n      Nn = new zt(),\n      zn = new zt(),\n      Bn = new zt(),\n      Fn = new zt(),\n      On = new zt(),\n      Un = new yt(),\n      Hn = new yt(),\n      Gn = new yt(),\n      kn = new zt(),\n      Vn = new zt();\n    class Wn extends Fe {\n      constructor(t = new En(), e = new sn()) {\n        super(),\n          (this.type = \"Mesh\"),\n          (this.geometry = t),\n          (this.material = e),\n          this.updateMorphTargets();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          void 0 !== t.morphTargetInfluences &&\n            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),\n          void 0 !== t.morphTargetDictionary &&\n            (this.morphTargetDictionary = Object.assign(\n              {},\n              t.morphTargetDictionary\n            )),\n          (this.material = t.material),\n          (this.geometry = t.geometry),\n          this\n        );\n      }\n      updateMorphTargets() {\n        const t = this.geometry;\n        if (t.isBufferGeometry) {\n          const e = t.morphAttributes,\n            n = Object.keys(e);\n          if (n.length > 0) {\n            const t = e[n[0]];\n            if (void 0 !== t) {\n              (this.morphTargetInfluences = []),\n                (this.morphTargetDictionary = {});\n              for (let e = 0, n = t.length; e < n; e++) {\n                const n = t[e].name || String(e);\n                this.morphTargetInfluences.push(0),\n                  (this.morphTargetDictionary[n] = e);\n              }\n            }\n          }\n        } else {\n          const e = t.morphTargets;\n          void 0 !== e &&\n            e.length > 0 &&\n            console.error(\n              \"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\"\n            );\n        }\n      }\n      raycast(t, e) {\n        const n = this.geometry,\n          i = this.material,\n          r = this.matrixWorld;\n        if (void 0 === i) return;\n        if (\n          (null === n.boundingSphere && n.computeBoundingSphere(),\n          Rn.copy(n.boundingSphere),\n          Rn.applyMatrix4(r),\n          !1 === t.ray.intersectsSphere(Rn))\n        )\n          return;\n        if (\n          (An.copy(r).invert(),\n          Ln.copy(t.ray).applyMatrix4(An),\n          null !== n.boundingBox && !1 === Ln.intersectsBox(n.boundingBox))\n        )\n          return;\n        let s;\n        if (n.isBufferGeometry) {\n          const r = n.index,\n            a = n.attributes.position,\n            o = n.morphAttributes.position,\n            l = n.morphTargetsRelative,\n            c = n.attributes.uv,\n            h = n.attributes.uv2,\n            u = n.groups,\n            d = n.drawRange;\n          if (null !== r)\n            if (Array.isArray(i))\n              for (let n = 0, p = u.length; n < p; n++) {\n                const p = u[n],\n                  m = i[p.materialIndex];\n                for (\n                  let n = Math.max(p.start, d.start),\n                    i = Math.min(\n                      r.count,\n                      Math.min(p.start + p.count, d.start + d.count)\n                    );\n                  n < i;\n                  n += 3\n                ) {\n                  const i = r.getX(n),\n                    u = r.getX(n + 1),\n                    d = r.getX(n + 2);\n                  (s = jn(this, m, t, Ln, a, o, l, c, h, i, u, d)),\n                    s &&\n                      ((s.faceIndex = Math.floor(n / 3)),\n                      (s.face.materialIndex = p.materialIndex),\n                      e.push(s));\n                }\n              }\n            else {\n              for (\n                let n = Math.max(0, d.start),\n                  u = Math.min(r.count, d.start + d.count);\n                n < u;\n                n += 3\n              ) {\n                const u = r.getX(n),\n                  d = r.getX(n + 1),\n                  p = r.getX(n + 2);\n                (s = jn(this, i, t, Ln, a, o, l, c, h, u, d, p)),\n                  s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));\n              }\n            }\n          else if (void 0 !== a)\n            if (Array.isArray(i))\n              for (let n = 0, r = u.length; n < r; n++) {\n                const r = u[n],\n                  p = i[r.materialIndex];\n                for (\n                  let n = Math.max(r.start, d.start),\n                    i = Math.min(\n                      a.count,\n                      Math.min(r.start + r.count, d.start + d.count)\n                    );\n                  n < i;\n                  n += 3\n                ) {\n                  (s = jn(this, p, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),\n                    s &&\n                      ((s.faceIndex = Math.floor(n / 3)),\n                      (s.face.materialIndex = r.materialIndex),\n                      e.push(s));\n                }\n              }\n            else {\n              for (\n                let n = Math.max(0, d.start),\n                  r = Math.min(a.count, d.start + d.count);\n                n < r;\n                n += 3\n              ) {\n                (s = jn(this, i, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),\n                  s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));\n              }\n            }\n        } else n.isGeometry && console.error(\"THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n    }\n    function jn(t, e, n, i, r, s, a, o, l, c, h, u) {\n      Cn.fromBufferAttribute(r, c),\n        Pn.fromBufferAttribute(r, h),\n        In.fromBufferAttribute(r, u);\n      const d = t.morphTargetInfluences;\n      if (s && d) {\n        Bn.set(0, 0, 0), Fn.set(0, 0, 0), On.set(0, 0, 0);\n        for (let t = 0, e = s.length; t < e; t++) {\n          const e = d[t],\n            n = s[t];\n          0 !== e &&\n            (Dn.fromBufferAttribute(n, c),\n            Nn.fromBufferAttribute(n, h),\n            zn.fromBufferAttribute(n, u),\n            a\n              ? (Bn.addScaledVector(Dn, e),\n                Fn.addScaledVector(Nn, e),\n                On.addScaledVector(zn, e))\n              : (Bn.addScaledVector(Dn.sub(Cn), e),\n                Fn.addScaledVector(Nn.sub(Pn), e),\n                On.addScaledVector(zn.sub(In), e)));\n        }\n        Cn.add(Bn), Pn.add(Fn), In.add(On);\n      }\n      t.isSkinnedMesh &&\n        (t.boneTransform(c, Cn),\n        t.boneTransform(h, Pn),\n        t.boneTransform(u, In));\n      const p = (function (t, e, n, i, r, s, a, o) {\n        let l;\n        if (\n          ((l =\n            1 === e.side\n              ? i.intersectTriangle(a, s, r, !0, o)\n              : i.intersectTriangle(r, s, a, 2 !== e.side, o)),\n          null === l)\n        )\n          return null;\n        Vn.copy(o), Vn.applyMatrix4(t.matrixWorld);\n        const c = n.ray.origin.distanceTo(Vn);\n        return c < n.near || c > n.far\n          ? null\n          : { distance: c, point: Vn.clone(), object: t };\n      })(t, e, n, i, Cn, Pn, In, kn);\n      if (p) {\n        o &&\n          (Un.fromBufferAttribute(o, c),\n          Hn.fromBufferAttribute(o, h),\n          Gn.fromBufferAttribute(o, u),\n          (p.uv = Ye.getUV(kn, Cn, Pn, In, Un, Hn, Gn, new yt()))),\n          l &&\n            (Un.fromBufferAttribute(l, c),\n            Hn.fromBufferAttribute(l, h),\n            Gn.fromBufferAttribute(l, u),\n            (p.uv2 = Ye.getUV(kn, Cn, Pn, In, Un, Hn, Gn, new yt())));\n        const t = { a: c, b: h, c: u, normal: new zt(), materialIndex: 0 };\n        Ye.getNormal(Cn, Pn, In, t.normal), (p.face = t);\n      }\n      return p;\n    }\n    Wn.prototype.isMesh = !0;\n    class qn extends En {\n      constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {\n        super(),\n          (this.type = \"BoxGeometry\"),\n          (this.parameters = {\n            width: t,\n            height: e,\n            depth: n,\n            widthSegments: i,\n            heightSegments: r,\n            depthSegments: s,\n          });\n        const a = this;\n        (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));\n        const o = [],\n          l = [],\n          c = [],\n          h = [];\n        let u = 0,\n          d = 0;\n        function p(t, e, n, i, r, s, p, m, f, g, v) {\n          const y = s / f,\n            x = p / g,\n            _ = s / 2,\n            M = p / 2,\n            b = m / 2,\n            w = f + 1,\n            S = g + 1;\n          let T = 0,\n            E = 0;\n          const A = new zt();\n          for (let s = 0; s < S; s++) {\n            const a = s * x - M;\n            for (let o = 0; o < w; o++) {\n              const u = o * y - _;\n              (A[t] = u * i),\n                (A[e] = a * r),\n                (A[n] = b),\n                l.push(A.x, A.y, A.z),\n                (A[t] = 0),\n                (A[e] = 0),\n                (A[n] = m > 0 ? 1 : -1),\n                c.push(A.x, A.y, A.z),\n                h.push(o / f),\n                h.push(1 - s / g),\n                (T += 1);\n            }\n          }\n          for (let t = 0; t < g; t++)\n            for (let e = 0; e < f; e++) {\n              const n = u + e + w * t,\n                i = u + e + w * (t + 1),\n                r = u + (e + 1) + w * (t + 1),\n                s = u + (e + 1) + w * t;\n              o.push(n, i, s), o.push(i, r, s), (E += 6);\n            }\n          a.addGroup(d, E, v), (d += E), (u += T);\n        }\n        p(\"z\", \"y\", \"x\", -1, -1, n, e, t, s, r, 0),\n          p(\"z\", \"y\", \"x\", 1, -1, n, e, -t, s, r, 1),\n          p(\"x\", \"z\", \"y\", 1, 1, t, n, e, i, s, 2),\n          p(\"x\", \"z\", \"y\", 1, -1, t, n, -e, i, s, 3),\n          p(\"x\", \"y\", \"z\", 1, -1, t, e, n, i, r, 4),\n          p(\"x\", \"y\", \"z\", -1, -1, t, e, -n, i, r, 5),\n          this.setIndex(o),\n          this.setAttribute(\"position\", new vn(l, 3)),\n          this.setAttribute(\"normal\", new vn(c, 3)),\n          this.setAttribute(\"uv\", new vn(h, 2));\n      }\n      static fromJSON(t) {\n        return new qn(\n          t.width,\n          t.height,\n          t.depth,\n          t.widthSegments,\n          t.heightSegments,\n          t.depthSegments\n        );\n      }\n    }\n    function Xn(t) {\n      const e = {};\n      for (const n in t) {\n        e[n] = {};\n        for (const i in t[n]) {\n          const r = t[n][i];\n          r &&\n          (r.isColor ||\n            r.isMatrix3 ||\n            r.isMatrix4 ||\n            r.isVector2 ||\n            r.isVector3 ||\n            r.isVector4 ||\n            r.isTexture ||\n            r.isQuaternion)\n            ? (e[n][i] = r.clone())\n            : Array.isArray(r)\n            ? (e[n][i] = r.slice())\n            : (e[n][i] = r);\n        }\n      }\n      return e;\n    }\n    function Yn(t) {\n      const e = {};\n      for (let n = 0; n < t.length; n++) {\n        const i = Xn(t[n]);\n        for (const t in i) e[t] = i[t];\n      }\n      return e;\n    }\n    const Jn = { clone: Xn, merge: Yn };\n    class Zn extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"ShaderMaterial\"),\n          (this.defines = {}),\n          (this.uniforms = {}),\n          (this.vertexShader =\n            \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\"),\n          (this.fragmentShader =\n            \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\"),\n          (this.linewidth = 1),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.fog = !1),\n          (this.lights = !1),\n          (this.clipping = !1),\n          (this.extensions = {\n            derivatives: !1,\n            fragDepth: !1,\n            drawBuffers: !1,\n            shaderTextureLOD: !1,\n          }),\n          (this.defaultAttributeValues = {\n            color: [1, 1, 1],\n            uv: [0, 0],\n            uv2: [0, 0],\n          }),\n          (this.index0AttributeName = void 0),\n          (this.uniformsNeedUpdate = !1),\n          (this.glslVersion = null),\n          void 0 !== t &&\n            (void 0 !== t.attributes &&\n              console.error(\n                \"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.\"\n              ),\n            this.setValues(t));\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.fragmentShader = t.fragmentShader),\n          (this.vertexShader = t.vertexShader),\n          (this.uniforms = Xn(t.uniforms)),\n          (this.defines = Object.assign({}, t.defines)),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.lights = t.lights),\n          (this.clipping = t.clipping),\n          (this.extensions = Object.assign({}, t.extensions)),\n          (this.glslVersion = t.glslVersion),\n          this\n        );\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        (e.glslVersion = this.glslVersion), (e.uniforms = {});\n        for (const n in this.uniforms) {\n          const i = this.uniforms[n].value;\n          i && i.isTexture\n            ? (e.uniforms[n] = { type: \"t\", value: i.toJSON(t).uuid })\n            : i && i.isColor\n            ? (e.uniforms[n] = { type: \"c\", value: i.getHex() })\n            : i && i.isVector2\n            ? (e.uniforms[n] = { type: \"v2\", value: i.toArray() })\n            : i && i.isVector3\n            ? (e.uniforms[n] = { type: \"v3\", value: i.toArray() })\n            : i && i.isVector4\n            ? (e.uniforms[n] = { type: \"v4\", value: i.toArray() })\n            : i && i.isMatrix3\n            ? (e.uniforms[n] = { type: \"m3\", value: i.toArray() })\n            : i && i.isMatrix4\n            ? (e.uniforms[n] = { type: \"m4\", value: i.toArray() })\n            : (e.uniforms[n] = { value: i });\n        }\n        Object.keys(this.defines).length > 0 && (e.defines = this.defines),\n          (e.vertexShader = this.vertexShader),\n          (e.fragmentShader = this.fragmentShader);\n        const n = {};\n        for (const t in this.extensions)\n          !0 === this.extensions[t] && (n[t] = !0);\n        return Object.keys(n).length > 0 && (e.extensions = n), e;\n      }\n    }\n    Zn.prototype.isShaderMaterial = !0;\n    class Qn extends Fe {\n      constructor() {\n        super(),\n          (this.type = \"Camera\"),\n          (this.matrixWorldInverse = new de()),\n          (this.projectionMatrix = new de()),\n          (this.projectionMatrixInverse = new de());\n      }\n      copy(t, e) {\n        return (\n          super.copy(t, e),\n          this.matrixWorldInverse.copy(t.matrixWorldInverse),\n          this.projectionMatrix.copy(t.projectionMatrix),\n          this.projectionMatrixInverse.copy(t.projectionMatrixInverse),\n          this\n        );\n      }\n      getWorldDirection(t) {\n        this.updateWorldMatrix(!0, !1);\n        const e = this.matrixWorld.elements;\n        return t.set(-e[8], -e[9], -e[10]).normalize();\n      }\n      updateMatrixWorld(t) {\n        super.updateMatrixWorld(t),\n          this.matrixWorldInverse.copy(this.matrixWorld).invert();\n      }\n      updateWorldMatrix(t, e) {\n        super.updateWorldMatrix(t, e),\n          this.matrixWorldInverse.copy(this.matrixWorld).invert();\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    Qn.prototype.isCamera = !0;\n    class Kn extends Qn {\n      constructor(t = 50, e = 1, n = 0.1, i = 2e3) {\n        super(),\n          (this.type = \"PerspectiveCamera\"),\n          (this.fov = t),\n          (this.zoom = 1),\n          (this.near = n),\n          (this.far = i),\n          (this.focus = 10),\n          (this.aspect = e),\n          (this.view = null),\n          (this.filmGauge = 35),\n          (this.filmOffset = 0),\n          this.updateProjectionMatrix();\n      }\n      copy(t, e) {\n        return (\n          super.copy(t, e),\n          (this.fov = t.fov),\n          (this.zoom = t.zoom),\n          (this.near = t.near),\n          (this.far = t.far),\n          (this.focus = t.focus),\n          (this.aspect = t.aspect),\n          (this.view = null === t.view ? null : Object.assign({}, t.view)),\n          (this.filmGauge = t.filmGauge),\n          (this.filmOffset = t.filmOffset),\n          this\n        );\n      }\n      setFocalLength(t) {\n        const e = (0.5 * this.getFilmHeight()) / t;\n        (this.fov = 2 * ot * Math.atan(e)), this.updateProjectionMatrix();\n      }\n      getFocalLength() {\n        const t = Math.tan(0.5 * at * this.fov);\n        return (0.5 * this.getFilmHeight()) / t;\n      }\n      getEffectiveFOV() {\n        return 2 * ot * Math.atan(Math.tan(0.5 * at * this.fov) / this.zoom);\n      }\n      getFilmWidth() {\n        return this.filmGauge * Math.min(this.aspect, 1);\n      }\n      getFilmHeight() {\n        return this.filmGauge / Math.max(this.aspect, 1);\n      }\n      setViewOffset(t, e, n, i, r, s) {\n        (this.aspect = t / e),\n          null === this.view &&\n            (this.view = {\n              enabled: !0,\n              fullWidth: 1,\n              fullHeight: 1,\n              offsetX: 0,\n              offsetY: 0,\n              width: 1,\n              height: 1,\n            }),\n          (this.view.enabled = !0),\n          (this.view.fullWidth = t),\n          (this.view.fullHeight = e),\n          (this.view.offsetX = n),\n          (this.view.offsetY = i),\n          (this.view.width = r),\n          (this.view.height = s),\n          this.updateProjectionMatrix();\n      }\n      clearViewOffset() {\n        null !== this.view && (this.view.enabled = !1),\n          this.updateProjectionMatrix();\n      }\n      updateProjectionMatrix() {\n        const t = this.near;\n        let e = (t * Math.tan(0.5 * at * this.fov)) / this.zoom,\n          n = 2 * e,\n          i = this.aspect * n,\n          r = -0.5 * i;\n        const s = this.view;\n        if (null !== this.view && this.view.enabled) {\n          const t = s.fullWidth,\n            a = s.fullHeight;\n          (r += (s.offsetX * i) / t),\n            (e -= (s.offsetY * n) / a),\n            (i *= s.width / t),\n            (n *= s.height / a);\n        }\n        const a = this.filmOffset;\n        0 !== a && (r += (t * a) / this.getFilmWidth()),\n          this.projectionMatrix.makePerspective(\n            r,\n            r + i,\n            e,\n            e - n,\n            t,\n            this.far\n          ),\n          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (\n          (e.object.fov = this.fov),\n          (e.object.zoom = this.zoom),\n          (e.object.near = this.near),\n          (e.object.far = this.far),\n          (e.object.focus = this.focus),\n          (e.object.aspect = this.aspect),\n          null !== this.view && (e.object.view = Object.assign({}, this.view)),\n          (e.object.filmGauge = this.filmGauge),\n          (e.object.filmOffset = this.filmOffset),\n          e\n        );\n      }\n    }\n    Kn.prototype.isPerspectiveCamera = !0;\n    const $n = 90;\n    class ti extends Fe {\n      constructor(t, e, n) {\n        if (\n          (super(),\n          (this.type = \"CubeCamera\"),\n          !0 !== n.isWebGLCubeRenderTarget)\n        )\n          return void console.error(\n            \"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.\"\n          );\n        this.renderTarget = n;\n        const i = new Kn($n, 1, t, e);\n        (i.layers = this.layers),\n          i.up.set(0, -1, 0),\n          i.lookAt(new zt(1, 0, 0)),\n          this.add(i);\n        const r = new Kn($n, 1, t, e);\n        (r.layers = this.layers),\n          r.up.set(0, -1, 0),\n          r.lookAt(new zt(-1, 0, 0)),\n          this.add(r);\n        const s = new Kn($n, 1, t, e);\n        (s.layers = this.layers),\n          s.up.set(0, 0, 1),\n          s.lookAt(new zt(0, 1, 0)),\n          this.add(s);\n        const a = new Kn($n, 1, t, e);\n        (a.layers = this.layers),\n          a.up.set(0, 0, -1),\n          a.lookAt(new zt(0, -1, 0)),\n          this.add(a);\n        const o = new Kn($n, 1, t, e);\n        (o.layers = this.layers),\n          o.up.set(0, -1, 0),\n          o.lookAt(new zt(0, 0, 1)),\n          this.add(o);\n        const l = new Kn($n, 1, t, e);\n        (l.layers = this.layers),\n          l.up.set(0, -1, 0),\n          l.lookAt(new zt(0, 0, -1)),\n          this.add(l);\n      }\n      update(t, e) {\n        null === this.parent && this.updateMatrixWorld();\n        const n = this.renderTarget,\n          [i, r, s, a, o, l] = this.children,\n          c = t.xr.enabled,\n          h = t.getRenderTarget();\n        t.xr.enabled = !1;\n        const u = n.texture.generateMipmaps;\n        (n.texture.generateMipmaps = !1),\n          t.setRenderTarget(n, 0),\n          t.render(e, i),\n          t.setRenderTarget(n, 1),\n          t.render(e, r),\n          t.setRenderTarget(n, 2),\n          t.render(e, s),\n          t.setRenderTarget(n, 3),\n          t.render(e, a),\n          t.setRenderTarget(n, 4),\n          t.render(e, o),\n          (n.texture.generateMipmaps = u),\n          t.setRenderTarget(n, 5),\n          t.render(e, l),\n          t.setRenderTarget(h),\n          (t.xr.enabled = c);\n      }\n    }\n    class ei extends Lt {\n      constructor(t, e, n, i, s, a, o, l, c, h) {\n        super(\n          (t = void 0 !== t ? t : []),\n          (e = void 0 !== e ? e : r),\n          n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          c,\n          h\n        ),\n          (this.flipY = !1);\n      }\n      get images() {\n        return this.image;\n      }\n      set images(t) {\n        this.image = t;\n      }\n    }\n    ei.prototype.isCubeTexture = !0;\n    class ni extends Pt {\n      constructor(t, e, n) {\n        Number.isInteger(e) &&\n          (console.warn(\n            \"THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )\"\n          ),\n          (e = n)),\n          super(t, t, e),\n          (e = e || {}),\n          (this.texture = new ei(\n            void 0,\n            e.mapping,\n            e.wrapS,\n            e.wrapT,\n            e.magFilter,\n            e.minFilter,\n            e.format,\n            e.type,\n            e.anisotropy,\n            e.encoding\n          )),\n          (this.texture.isRenderTargetTexture = !0),\n          (this.texture.generateMipmaps =\n            void 0 !== e.generateMipmaps && e.generateMipmaps),\n          (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : g),\n          (this.texture._needsFlipEnvMap = !1);\n      }\n      fromEquirectangularTexture(t, e) {\n        (this.texture.type = e.type),\n          (this.texture.format = E),\n          (this.texture.encoding = e.encoding),\n          (this.texture.generateMipmaps = e.generateMipmaps),\n          (this.texture.minFilter = e.minFilter),\n          (this.texture.magFilter = e.magFilter);\n        const n = {\n            uniforms: { tEquirect: { value: null } },\n            vertexShader:\n              \"\\n\\n\\t\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t\\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\n\\t\\t\\t\\t\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\",\n            fragmentShader:\n              \"\\n\\n\\t\\t\\t\\tuniform sampler2D tEquirect;\\n\\n\\t\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t\\t#include <common>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec3 direction = normalize( vWorldDirection );\\n\\n\\t\\t\\t\\t\\tvec2 sampleUV = equirectUv( direction );\\n\\n\\t\\t\\t\\t\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\",\n          },\n          i = new qn(5, 5, 5),\n          r = new Zn({\n            name: \"CubemapFromEquirect\",\n            uniforms: Xn(n.uniforms),\n            vertexShader: n.vertexShader,\n            fragmentShader: n.fragmentShader,\n            side: 1,\n            blending: 0,\n          });\n        r.uniforms.tEquirect.value = e;\n        const s = new Wn(i, r),\n          a = e.minFilter;\n        e.minFilter === y && (e.minFilter = g);\n        return (\n          new ti(1, 10, this).update(t, s),\n          (e.minFilter = a),\n          s.geometry.dispose(),\n          s.material.dispose(),\n          this\n        );\n      }\n      clear(t, e, n, i) {\n        const r = t.getRenderTarget();\n        for (let r = 0; r < 6; r++)\n          t.setRenderTarget(this, r), t.clear(e, n, i);\n        t.setRenderTarget(r);\n      }\n    }\n    ni.prototype.isWebGLCubeRenderTarget = !0;\n    const ii = new zt(),\n      ri = new zt(),\n      si = new xt();\n    class ai {\n      constructor(t = new zt(1, 0, 0), e = 0) {\n        (this.normal = t), (this.constant = e);\n      }\n      set(t, e) {\n        return this.normal.copy(t), (this.constant = e), this;\n      }\n      setComponents(t, e, n, i) {\n        return this.normal.set(t, e, n), (this.constant = i), this;\n      }\n      setFromNormalAndCoplanarPoint(t, e) {\n        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;\n      }\n      setFromCoplanarPoints(t, e, n) {\n        const i = ii.subVectors(n, e).cross(ri.subVectors(t, e)).normalize();\n        return this.setFromNormalAndCoplanarPoint(i, t), this;\n      }\n      copy(t) {\n        return this.normal.copy(t.normal), (this.constant = t.constant), this;\n      }\n      normalize() {\n        const t = 1 / this.normal.length();\n        return this.normal.multiplyScalar(t), (this.constant *= t), this;\n      }\n      negate() {\n        return (this.constant *= -1), this.normal.negate(), this;\n      }\n      distanceToPoint(t) {\n        return this.normal.dot(t) + this.constant;\n      }\n      distanceToSphere(t) {\n        return this.distanceToPoint(t.center) - t.radius;\n      }\n      projectPoint(t, e) {\n        return e\n          .copy(this.normal)\n          .multiplyScalar(-this.distanceToPoint(t))\n          .add(t);\n      }\n      intersectLine(t, e) {\n        const n = t.delta(ii),\n          i = this.normal.dot(n);\n        if (0 === i)\n          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;\n        const r = -(t.start.dot(this.normal) + this.constant) / i;\n        return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);\n      }\n      intersectsLine(t) {\n        const e = this.distanceToPoint(t.start),\n          n = this.distanceToPoint(t.end);\n        return (e < 0 && n > 0) || (n < 0 && e > 0);\n      }\n      intersectsBox(t) {\n        return t.intersectsPlane(this);\n      }\n      intersectsSphere(t) {\n        return t.intersectsPlane(this);\n      }\n      coplanarPoint(t) {\n        return t.copy(this.normal).multiplyScalar(-this.constant);\n      }\n      applyMatrix4(t, e) {\n        const n = e || si.getNormalMatrix(t),\n          i = this.coplanarPoint(ii).applyMatrix4(t),\n          r = this.normal.applyMatrix3(n).normalize();\n        return (this.constant = -i.dot(r)), this;\n      }\n      translate(t) {\n        return (this.constant -= t.dot(this.normal)), this;\n      }\n      equals(t) {\n        return t.normal.equals(this.normal) && t.constant === this.constant;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    ai.prototype.isPlane = !0;\n    const oi = new ie(),\n      li = new zt();\n    class ci {\n      constructor(\n        t = new ai(),\n        e = new ai(),\n        n = new ai(),\n        i = new ai(),\n        r = new ai(),\n        s = new ai()\n      ) {\n        this.planes = [t, e, n, i, r, s];\n      }\n      set(t, e, n, i, r, s) {\n        const a = this.planes;\n        return (\n          a[0].copy(t),\n          a[1].copy(e),\n          a[2].copy(n),\n          a[3].copy(i),\n          a[4].copy(r),\n          a[5].copy(s),\n          this\n        );\n      }\n      copy(t) {\n        const e = this.planes;\n        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);\n        return this;\n      }\n      setFromProjectionMatrix(t) {\n        const e = this.planes,\n          n = t.elements,\n          i = n[0],\n          r = n[1],\n          s = n[2],\n          a = n[3],\n          o = n[4],\n          l = n[5],\n          c = n[6],\n          h = n[7],\n          u = n[8],\n          d = n[9],\n          p = n[10],\n          m = n[11],\n          f = n[12],\n          g = n[13],\n          v = n[14],\n          y = n[15];\n        return (\n          e[0].setComponents(a - i, h - o, m - u, y - f).normalize(),\n          e[1].setComponents(a + i, h + o, m + u, y + f).normalize(),\n          e[2].setComponents(a + r, h + l, m + d, y + g).normalize(),\n          e[3].setComponents(a - r, h - l, m - d, y - g).normalize(),\n          e[4].setComponents(a - s, h - c, m - p, y - v).normalize(),\n          e[5].setComponents(a + s, h + c, m + p, y + v).normalize(),\n          this\n        );\n      }\n      intersectsObject(t) {\n        const e = t.geometry;\n        return (\n          null === e.boundingSphere && e.computeBoundingSphere(),\n          oi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),\n          this.intersectsSphere(oi)\n        );\n      }\n      intersectsSprite(t) {\n        return (\n          oi.center.set(0, 0, 0),\n          (oi.radius = 0.7071067811865476),\n          oi.applyMatrix4(t.matrixWorld),\n          this.intersectsSphere(oi)\n        );\n      }\n      intersectsSphere(t) {\n        const e = this.planes,\n          n = t.center,\n          i = -t.radius;\n        for (let t = 0; t < 6; t++) {\n          if (e[t].distanceToPoint(n) < i) return !1;\n        }\n        return !0;\n      }\n      intersectsBox(t) {\n        const e = this.planes;\n        for (let n = 0; n < 6; n++) {\n          const i = e[n];\n          if (\n            ((li.x = i.normal.x > 0 ? t.max.x : t.min.x),\n            (li.y = i.normal.y > 0 ? t.max.y : t.min.y),\n            (li.z = i.normal.z > 0 ? t.max.z : t.min.z),\n            i.distanceToPoint(li) < 0)\n          )\n            return !1;\n        }\n        return !0;\n      }\n      containsPoint(t) {\n        const e = this.planes;\n        for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;\n        return !0;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    function hi() {\n      let t = null,\n        e = !1,\n        n = null,\n        i = null;\n      function r(e, s) {\n        n(e, s), (i = t.requestAnimationFrame(r));\n      }\n      return {\n        start: function () {\n          !0 !== e &&\n            null !== n &&\n            ((i = t.requestAnimationFrame(r)), (e = !0));\n        },\n        stop: function () {\n          t.cancelAnimationFrame(i), (e = !1);\n        },\n        setAnimationLoop: function (t) {\n          n = t;\n        },\n        setContext: function (e) {\n          t = e;\n        },\n      };\n    }\n    function ui(t, e) {\n      const n = e.isWebGL2,\n        i = new WeakMap();\n      return {\n        get: function (t) {\n          return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);\n        },\n        remove: function (e) {\n          e.isInterleavedBufferAttribute && (e = e.data);\n          const n = i.get(e);\n          n && (t.deleteBuffer(n.buffer), i.delete(e));\n        },\n        update: function (e, r) {\n          if (e.isGLBufferAttribute) {\n            const t = i.get(e);\n            return void (\n              (!t || t.version < e.version) &&\n              i.set(e, {\n                buffer: e.buffer,\n                type: e.type,\n                bytesPerElement: e.elementSize,\n                version: e.version,\n              })\n            );\n          }\n          e.isInterleavedBufferAttribute && (e = e.data);\n          const s = i.get(e);\n          void 0 === s\n            ? i.set(\n                e,\n                (function (e, i) {\n                  const r = e.array,\n                    s = e.usage,\n                    a = t.createBuffer();\n                  t.bindBuffer(i, a),\n                    t.bufferData(i, r, s),\n                    e.onUploadCallback();\n                  let o = 5126;\n                  return (\n                    r instanceof Float32Array\n                      ? (o = 5126)\n                      : r instanceof Float64Array\n                      ? console.warn(\n                          \"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.\"\n                        )\n                      : r instanceof Uint16Array\n                      ? e.isFloat16BufferAttribute\n                        ? n\n                          ? (o = 5131)\n                          : console.warn(\n                              \"THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.\"\n                            )\n                        : (o = 5123)\n                      : r instanceof Int16Array\n                      ? (o = 5122)\n                      : r instanceof Uint32Array\n                      ? (o = 5125)\n                      : r instanceof Int32Array\n                      ? (o = 5124)\n                      : r instanceof Int8Array\n                      ? (o = 5120)\n                      : (r instanceof Uint8Array ||\n                          r instanceof Uint8ClampedArray) &&\n                        (o = 5121),\n                    {\n                      buffer: a,\n                      type: o,\n                      bytesPerElement: r.BYTES_PER_ELEMENT,\n                      version: e.version,\n                    }\n                  );\n                })(e, r)\n              )\n            : s.version < e.version &&\n              (!(function (e, i, r) {\n                const s = i.array,\n                  a = i.updateRange;\n                t.bindBuffer(r, e),\n                  -1 === a.count\n                    ? t.bufferSubData(r, 0, s)\n                    : (n\n                        ? t.bufferSubData(\n                            r,\n                            a.offset * s.BYTES_PER_ELEMENT,\n                            s,\n                            a.offset,\n                            a.count\n                          )\n                        : t.bufferSubData(\n                            r,\n                            a.offset * s.BYTES_PER_ELEMENT,\n                            s.subarray(a.offset, a.offset + a.count)\n                          ),\n                      (a.count = -1));\n              })(s.buffer, e, r),\n              (s.version = e.version));\n        },\n      };\n    }\n    class di extends En {\n      constructor(t = 1, e = 1, n = 1, i = 1) {\n        super(),\n          (this.type = \"PlaneGeometry\"),\n          (this.parameters = {\n            width: t,\n            height: e,\n            widthSegments: n,\n            heightSegments: i,\n          });\n        const r = t / 2,\n          s = e / 2,\n          a = Math.floor(n),\n          o = Math.floor(i),\n          l = a + 1,\n          c = o + 1,\n          h = t / a,\n          u = e / o,\n          d = [],\n          p = [],\n          m = [],\n          f = [];\n        for (let t = 0; t < c; t++) {\n          const e = t * u - s;\n          for (let n = 0; n < l; n++) {\n            const i = n * h - r;\n            p.push(i, -e, 0), m.push(0, 0, 1), f.push(n / a), f.push(1 - t / o);\n          }\n        }\n        for (let t = 0; t < o; t++)\n          for (let e = 0; e < a; e++) {\n            const n = e + l * t,\n              i = e + l * (t + 1),\n              r = e + 1 + l * (t + 1),\n              s = e + 1 + l * t;\n            d.push(n, i, s), d.push(i, r, s);\n          }\n        this.setIndex(d),\n          this.setAttribute(\"position\", new vn(p, 3)),\n          this.setAttribute(\"normal\", new vn(m, 3)),\n          this.setAttribute(\"uv\", new vn(f, 2));\n      }\n      static fromJSON(t) {\n        return new di(t.width, t.height, t.widthSegments, t.heightSegments);\n      }\n    }\n    const pi = {\n        alphamap_fragment:\n          \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\",\n        alphamap_pars_fragment:\n          \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\",\n        alphatest_fragment:\n          \"#ifdef USE_ALPHATEST\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n#endif\",\n        alphatest_pars_fragment:\n          \"#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif\",\n        aomap_fragment:\n          \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif\",\n        aomap_pars_fragment:\n          \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\",\n        begin_vertex: \"vec3 transformed = vec3( position );\",\n        beginnormal_vertex:\n          \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\",\n        bsdfs:\n          \"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif\",\n        bumpmap_pars_fragment:\n          \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\",\n        clipping_planes_fragment:\n          \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\",\n        clipping_planes_pars_fragment:\n          \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\",\n        clipping_planes_pars_vertex:\n          \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\",\n        clipping_planes_vertex:\n          \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\",\n        color_fragment:\n          \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\",\n        color_pars_fragment:\n          \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\",\n        color_pars_vertex:\n          \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\",\n        color_vertex:\n          \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\",\n        common:\n          \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\",\n        cube_uv_reflection_fragment:\n          \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\",\n        defaultnormal_vertex:\n          \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\",\n        displacementmap_pars_vertex:\n          \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\",\n        displacementmap_vertex:\n          \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\",\n        emissivemap_fragment:\n          \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\",\n        emissivemap_pars_fragment:\n          \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\",\n        encodings_fragment:\n          \"gl_FragColor = linearToOutputTexel( gl_FragColor );\",\n        encodings_pars_fragment:\n          \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\",\n        envmap_fragment:\n          \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\",\n        envmap_common_pars_fragment:\n          \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\",\n        envmap_pars_fragment:\n          \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\",\n        envmap_pars_vertex:\n          \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\",\n        envmap_physical_pars_fragment:\n          \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 reflectVec;\\n\\t\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\t\\treflectVec = reflect( - viewDir, normal );\\n\\t\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treflectVec = refract( - viewDir, normal, refractionRatio );\\n\\t\\t\\t#endif\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\",\n        envmap_vertex:\n          \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\",\n        fog_vertex: \"#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif\",\n        fog_pars_vertex: \"#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif\",\n        fog_fragment:\n          \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\",\n        fog_pars_fragment:\n          \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\",\n        gradientmap_pars_fragment:\n          \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\",\n        lightmap_fragment:\n          \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tlightMapIrradiance *= PI;\\n\\t#endif\\n\\treflectedLight.indirectDiffuse += lightMapIrradiance;\\n#endif\",\n        lightmap_pars_fragment:\n          \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\",\n        lights_lambert_vertex:\n          \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\",\n        lights_pars_begin:\n          \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t}\\n\\t\\treturn distanceFalloff;\\n\\t#else\\n\\t\\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\t\\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t#endif\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\",\n        lights_toon_fragment:\n          \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\",\n        lights_toon_pars_fragment:\n          \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\",\n        lights_phong_fragment:\n          \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\",\n        lights_phong_pars_fragment:\n          \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\",\n        lights_physical_fragment:\n          \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\t#ifdef SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULARCOLORMAP\\n\\t\\t\\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEENCOLORMAP\\n\\t\\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEENROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\\n\\t#endif\\n#endif\",\n        lights_physical_pars_fragment:\n          \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n};\\nvec3 clearcoatSpecular = vec3( 0.0 );\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(\\t\\t0, 1,\\t\\t0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\",\n        lights_fragment_begin:\n          \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef USE_CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\",\n        lights_fragment_maps:\n          \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometry.normal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif\",\n        lights_fragment_end:\n          \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\",\n        logdepthbuf_fragment:\n          \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\",\n        logdepthbuf_pars_fragment:\n          \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\",\n        logdepthbuf_pars_vertex:\n          \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\",\n        logdepthbuf_vertex:\n          \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\",\n        map_fragment:\n          \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\",\n        map_pars_fragment: \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\",\n        map_particle_fragment:\n          \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\",\n        map_particle_pars_fragment:\n          \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\",\n        metalnessmap_fragment:\n          \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\",\n        metalnessmap_pars_fragment:\n          \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\",\n        morphnormal_vertex:\n          \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\t\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\t\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\t\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n\\t#endif\\n#endif\",\n        morphtarget_pars_vertex:\n          \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t\\tuniform sampler2DArray morphTargetsTexture;\\n\\t\\tuniform vec2 morphTargetsTextureSize;\\n\\t\\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\\n\\t\\t\\tfloat texelIndex = float( vertexIndex * stride + offset );\\n\\t\\t\\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\\n\\t\\t\\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\t\\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\\n\\t\\t\\treturn texture( morphTargetsTexture, morphUV ).xyz;\\n\\t\\t}\\n\\t#else\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t\\t#else\\n\\t\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\",\n        morphtarget_vertex:\n          \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\\n\\t\\t\\t#else\\n\\t\\t\\t\\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#else\\n\\t\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\t\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\t\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\t\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\",\n        normal_fragment_begin:\n          \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\",\n        normal_fragment_maps:\n          \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\",\n        normal_pars_fragment:\n          \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\",\n        normal_pars_vertex:\n          \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\",\n        normal_vertex:\n          \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\",\n        normalmap_pars_fragment:\n          \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\",\n        clearcoat_normal_fragment_begin:\n          \"#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\",\n        clearcoat_normal_fragment_maps:\n          \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\",\n        clearcoat_pars_fragment:\n          \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\",\n        output_fragment:\n          \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= transmissionAlpha + 0.1;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\n        packing:\n          \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\",\n        premultiplied_alpha_fragment:\n          \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\",\n        project_vertex:\n          \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\",\n        dithering_fragment:\n          \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\",\n        dithering_pars_fragment:\n          \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\",\n        roughnessmap_fragment:\n          \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\",\n        roughnessmap_pars_fragment:\n          \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\",\n        shadowmap_pars_fragment:\n          \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\\tf.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\\tf.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\",\n        shadowmap_pars_vertex:\n          \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\",\n        shadowmap_vertex:\n          \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\",\n        shadowmask_pars_fragment:\n          \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\",\n        skinbase_vertex:\n          \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\",\n        skinning_pars_vertex:\n          \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\",\n        skinning_vertex:\n          \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\",\n        skinnormal_vertex:\n          \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\",\n        specularmap_fragment:\n          \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\",\n        specularmap_pars_fragment:\n          \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\",\n        tonemapping_fragment:\n          \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\",\n        tonemapping_pars_fragment:\n          \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(\\t1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,\\t1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,\\t1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\",\n        transmission_fragment:\n          \"#ifdef USE_TRANSMISSION\\n\\tfloat transmissionAlpha = 1.0;\\n\\tfloat transmissionFactor = transmission;\\n\\tfloat thicknessFactor = thickness;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmission = getIBLVolumeRefraction(\\n\\t\\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance );\\n\\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\\n\\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\\n#endif\",\n        transmission_pars_fragment:\n          \"#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( float roughness, float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\\n\\t\\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\\n\\t\\tif ( attenuationDistance == 0.0 ) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\\n\\t\\tvec3 attenuationColor, float attenuationDistance ) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\\n\\t}\\n#endif\",\n        uv_pars_fragment:\n          \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\",\n        uv_pars_vertex:\n          \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\",\n        uv_vertex:\n          \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\",\n        uv2_pars_fragment:\n          \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\",\n        uv2_pars_vertex:\n          \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\",\n        uv2_vertex:\n          \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\",\n        worldpos_vertex:\n          \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\",\n        background_vert:\n          \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\",\n        background_frag:\n          \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\",\n        cube_vert:\n          \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\",\n        cube_frag:\n          \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\",\n        depth_vert:\n          \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\",\n        depth_frag:\n          \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\",\n        distanceRGBA_vert:\n          \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\",\n        distanceRGBA_frag:\n          \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\",\n        equirect_vert:\n          \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\",\n        equirect_frag:\n          \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\",\n        linedashed_vert:\n          \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        linedashed_frag:\n          \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\",\n        meshbasic_vert:\n          \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        meshbasic_frag:\n          \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        meshlambert_vert:\n          \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        meshlambert_frag:\n          \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        meshmatcap_vert:\n          \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\",\n        meshmatcap_frag:\n          \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        meshnormal_vert:\n          \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\",\n        meshnormal_frag:\n          \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\",\n        meshphong_vert:\n          \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        meshphong_frag:\n          \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        meshphysical_vert:\n          \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\",\n        meshphysical_frag:\n          \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULARCOLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEENCOLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEENROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\\n\\t#endif\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        meshtoon_vert:\n          \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        meshtoon_frag:\n          \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\",\n        points_vert:\n          \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        points_frag:\n          \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\",\n        shadow_vert:\n          \"#include <common>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        shadow_frag:\n          \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\",\n        sprite_vert:\n          \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\",\n        sprite_frag:\n          \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\",\n      },\n      mi = {\n        common: {\n          diffuse: { value: new rn(16777215) },\n          opacity: { value: 1 },\n          map: { value: null },\n          uvTransform: { value: new xt() },\n          uv2Transform: { value: new xt() },\n          alphaMap: { value: null },\n          alphaTest: { value: 0 },\n        },\n        specularmap: { specularMap: { value: null } },\n        envmap: {\n          envMap: { value: null },\n          flipEnvMap: { value: -1 },\n          reflectivity: { value: 1 },\n          ior: { value: 1.5 },\n          refractionRatio: { value: 0.98 },\n          maxMipLevel: { value: 0 },\n        },\n        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },\n        lightmap: {\n          lightMap: { value: null },\n          lightMapIntensity: { value: 1 },\n        },\n        emissivemap: { emissiveMap: { value: null } },\n        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },\n        normalmap: {\n          normalMap: { value: null },\n          normalScale: { value: new yt(1, 1) },\n        },\n        displacementmap: {\n          displacementMap: { value: null },\n          displacementScale: { value: 1 },\n          displacementBias: { value: 0 },\n        },\n        roughnessmap: { roughnessMap: { value: null } },\n        metalnessmap: { metalnessMap: { value: null } },\n        gradientmap: { gradientMap: { value: null } },\n        fog: {\n          fogDensity: { value: 25e-5 },\n          fogNear: { value: 1 },\n          fogFar: { value: 2e3 },\n          fogColor: { value: new rn(16777215) },\n        },\n        lights: {\n          ambientLightColor: { value: [] },\n          lightProbe: { value: [] },\n          directionalLights: {\n            value: [],\n            properties: { direction: {}, color: {} },\n          },\n          directionalLightShadows: {\n            value: [],\n            properties: {\n              shadowBias: {},\n              shadowNormalBias: {},\n              shadowRadius: {},\n              shadowMapSize: {},\n            },\n          },\n          directionalShadowMap: { value: [] },\n          directionalShadowMatrix: { value: [] },\n          spotLights: {\n            value: [],\n            properties: {\n              color: {},\n              position: {},\n              direction: {},\n              distance: {},\n              coneCos: {},\n              penumbraCos: {},\n              decay: {},\n            },\n          },\n          spotLightShadows: {\n            value: [],\n            properties: {\n              shadowBias: {},\n              shadowNormalBias: {},\n              shadowRadius: {},\n              shadowMapSize: {},\n            },\n          },\n          spotShadowMap: { value: [] },\n          spotShadowMatrix: { value: [] },\n          pointLights: {\n            value: [],\n            properties: { color: {}, position: {}, decay: {}, distance: {} },\n          },\n          pointLightShadows: {\n            value: [],\n            properties: {\n              shadowBias: {},\n              shadowNormalBias: {},\n              shadowRadius: {},\n              shadowMapSize: {},\n              shadowCameraNear: {},\n              shadowCameraFar: {},\n            },\n          },\n          pointShadowMap: { value: [] },\n          pointShadowMatrix: { value: [] },\n          hemisphereLights: {\n            value: [],\n            properties: { direction: {}, skyColor: {}, groundColor: {} },\n          },\n          rectAreaLights: {\n            value: [],\n            properties: { color: {}, position: {}, width: {}, height: {} },\n          },\n          ltc_1: { value: null },\n          ltc_2: { value: null },\n        },\n        points: {\n          diffuse: { value: new rn(16777215) },\n          opacity: { value: 1 },\n          size: { value: 1 },\n          scale: { value: 1 },\n          map: { value: null },\n          alphaMap: { value: null },\n          alphaTest: { value: 0 },\n          uvTransform: { value: new xt() },\n        },\n        sprite: {\n          diffuse: { value: new rn(16777215) },\n          opacity: { value: 1 },\n          center: { value: new yt(0.5, 0.5) },\n          rotation: { value: 0 },\n          map: { value: null },\n          alphaMap: { value: null },\n          alphaTest: { value: 0 },\n          uvTransform: { value: new xt() },\n        },\n      },\n      fi = {\n        basic: {\n          uniforms: Yn([\n            mi.common,\n            mi.specularmap,\n            mi.envmap,\n            mi.aomap,\n            mi.lightmap,\n            mi.fog,\n          ]),\n          vertexShader: pi.meshbasic_vert,\n          fragmentShader: pi.meshbasic_frag,\n        },\n        lambert: {\n          uniforms: Yn([\n            mi.common,\n            mi.specularmap,\n            mi.envmap,\n            mi.aomap,\n            mi.lightmap,\n            mi.emissivemap,\n            mi.fog,\n            mi.lights,\n            { emissive: { value: new rn(0) } },\n          ]),\n          vertexShader: pi.meshlambert_vert,\n          fragmentShader: pi.meshlambert_frag,\n        },\n        phong: {\n          uniforms: Yn([\n            mi.common,\n            mi.specularmap,\n            mi.envmap,\n            mi.aomap,\n            mi.lightmap,\n            mi.emissivemap,\n            mi.bumpmap,\n            mi.normalmap,\n            mi.displacementmap,\n            mi.fog,\n            mi.lights,\n            {\n              emissive: { value: new rn(0) },\n              specular: { value: new rn(1118481) },\n              shininess: { value: 30 },\n            },\n          ]),\n          vertexShader: pi.meshphong_vert,\n          fragmentShader: pi.meshphong_frag,\n        },\n        standard: {\n          uniforms: Yn([\n            mi.common,\n            mi.envmap,\n            mi.aomap,\n            mi.lightmap,\n            mi.emissivemap,\n            mi.bumpmap,\n            mi.normalmap,\n            mi.displacementmap,\n            mi.roughnessmap,\n            mi.metalnessmap,\n            mi.fog,\n            mi.lights,\n            {\n              emissive: { value: new rn(0) },\n              roughness: { value: 1 },\n              metalness: { value: 0 },\n              envMapIntensity: { value: 1 },\n            },\n          ]),\n          vertexShader: pi.meshphysical_vert,\n          fragmentShader: pi.meshphysical_frag,\n        },\n        toon: {\n          uniforms: Yn([\n            mi.common,\n            mi.aomap,\n            mi.lightmap,\n            mi.emissivemap,\n            mi.bumpmap,\n            mi.normalmap,\n            mi.displacementmap,\n            mi.gradientmap,\n            mi.fog,\n            mi.lights,\n            { emissive: { value: new rn(0) } },\n          ]),\n          vertexShader: pi.meshtoon_vert,\n          fragmentShader: pi.meshtoon_frag,\n        },\n        matcap: {\n          uniforms: Yn([\n            mi.common,\n            mi.bumpmap,\n            mi.normalmap,\n            mi.displacementmap,\n            mi.fog,\n            { matcap: { value: null } },\n          ]),\n          vertexShader: pi.meshmatcap_vert,\n          fragmentShader: pi.meshmatcap_frag,\n        },\n        points: {\n          uniforms: Yn([mi.points, mi.fog]),\n          vertexShader: pi.points_vert,\n          fragmentShader: pi.points_frag,\n        },\n        dashed: {\n          uniforms: Yn([\n            mi.common,\n            mi.fog,\n            {\n              scale: { value: 1 },\n              dashSize: { value: 1 },\n              totalSize: { value: 2 },\n            },\n          ]),\n          vertexShader: pi.linedashed_vert,\n          fragmentShader: pi.linedashed_frag,\n        },\n        depth: {\n          uniforms: Yn([mi.common, mi.displacementmap]),\n          vertexShader: pi.depth_vert,\n          fragmentShader: pi.depth_frag,\n        },\n        normal: {\n          uniforms: Yn([\n            mi.common,\n            mi.bumpmap,\n            mi.normalmap,\n            mi.displacementmap,\n            { opacity: { value: 1 } },\n          ]),\n          vertexShader: pi.meshnormal_vert,\n          fragmentShader: pi.meshnormal_frag,\n        },\n        sprite: {\n          uniforms: Yn([mi.sprite, mi.fog]),\n          vertexShader: pi.sprite_vert,\n          fragmentShader: pi.sprite_frag,\n        },\n        background: {\n          uniforms: { uvTransform: { value: new xt() }, t2D: { value: null } },\n          vertexShader: pi.background_vert,\n          fragmentShader: pi.background_frag,\n        },\n        cube: {\n          uniforms: Yn([mi.envmap, { opacity: { value: 1 } }]),\n          vertexShader: pi.cube_vert,\n          fragmentShader: pi.cube_frag,\n        },\n        equirect: {\n          uniforms: { tEquirect: { value: null } },\n          vertexShader: pi.equirect_vert,\n          fragmentShader: pi.equirect_frag,\n        },\n        distanceRGBA: {\n          uniforms: Yn([\n            mi.common,\n            mi.displacementmap,\n            {\n              referencePosition: { value: new zt() },\n              nearDistance: { value: 1 },\n              farDistance: { value: 1e3 },\n            },\n          ]),\n          vertexShader: pi.distanceRGBA_vert,\n          fragmentShader: pi.distanceRGBA_frag,\n        },\n        shadow: {\n          uniforms: Yn([\n            mi.lights,\n            mi.fog,\n            { color: { value: new rn(0) }, opacity: { value: 1 } },\n          ]),\n          vertexShader: pi.shadow_vert,\n          fragmentShader: pi.shadow_frag,\n        },\n      };\n    function gi(t, e, n, i, r) {\n      const s = new rn(0);\n      let a,\n        o,\n        c = 0,\n        h = null,\n        u = 0,\n        d = null;\n      function p(t, e) {\n        n.buffers.color.setClear(t.r, t.g, t.b, e, r);\n      }\n      return {\n        getClearColor: function () {\n          return s;\n        },\n        setClearColor: function (t, e = 1) {\n          s.set(t), (c = e), p(s, c);\n        },\n        getClearAlpha: function () {\n          return c;\n        },\n        setClearAlpha: function (t) {\n          (c = t), p(s, c);\n        },\n        render: function (n, r) {\n          let m = !1,\n            f = !0 === r.isScene ? r.background : null;\n          f && f.isTexture && (f = e.get(f));\n          const g = t.xr,\n            v = g.getSession && g.getSession();\n          v && \"additive\" === v.environmentBlendMode && (f = null),\n            null === f ? p(s, c) : f && f.isColor && (p(f, 1), (m = !0)),\n            (t.autoClear || m) &&\n              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),\n            f && (f.isCubeTexture || f.mapping === l)\n              ? (void 0 === o &&\n                  ((o = new Wn(\n                    new qn(1, 1, 1),\n                    new Zn({\n                      name: \"BackgroundCubeMaterial\",\n                      uniforms: Xn(fi.cube.uniforms),\n                      vertexShader: fi.cube.vertexShader,\n                      fragmentShader: fi.cube.fragmentShader,\n                      side: 1,\n                      depthTest: !1,\n                      depthWrite: !1,\n                      fog: !1,\n                    })\n                  )),\n                  o.geometry.deleteAttribute(\"normal\"),\n                  o.geometry.deleteAttribute(\"uv\"),\n                  (o.onBeforeRender = function (t, e, n) {\n                    this.matrixWorld.copyPosition(n.matrixWorld);\n                  }),\n                  Object.defineProperty(o.material, \"envMap\", {\n                    get: function () {\n                      return this.uniforms.envMap.value;\n                    },\n                  }),\n                  i.update(o)),\n                (o.material.uniforms.envMap.value = f),\n                (o.material.uniforms.flipEnvMap.value =\n                  f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1),\n                (h === f && u === f.version && d === t.toneMapping) ||\n                  ((o.material.needsUpdate = !0),\n                  (h = f),\n                  (u = f.version),\n                  (d = t.toneMapping)),\n                n.unshift(o, o.geometry, o.material, 0, 0, null))\n              : f &&\n                f.isTexture &&\n                (void 0 === a &&\n                  ((a = new Wn(\n                    new di(2, 2),\n                    new Zn({\n                      name: \"BackgroundMaterial\",\n                      uniforms: Xn(fi.background.uniforms),\n                      vertexShader: fi.background.vertexShader,\n                      fragmentShader: fi.background.fragmentShader,\n                      side: 0,\n                      depthTest: !1,\n                      depthWrite: !1,\n                      fog: !1,\n                    })\n                  )),\n                  a.geometry.deleteAttribute(\"normal\"),\n                  Object.defineProperty(a.material, \"map\", {\n                    get: function () {\n                      return this.uniforms.t2D.value;\n                    },\n                  }),\n                  i.update(a)),\n                (a.material.uniforms.t2D.value = f),\n                !0 === f.matrixAutoUpdate && f.updateMatrix(),\n                a.material.uniforms.uvTransform.value.copy(f.matrix),\n                (h === f && u === f.version && d === t.toneMapping) ||\n                  ((a.material.needsUpdate = !0),\n                  (h = f),\n                  (u = f.version),\n                  (d = t.toneMapping)),\n                n.unshift(a, a.geometry, a.material, 0, 0, null));\n        },\n      };\n    }\n    function vi(t, e, n, i) {\n      const r = t.getParameter(34921),\n        s = i.isWebGL2 ? null : e.get(\"OES_vertex_array_object\"),\n        a = i.isWebGL2 || null !== s,\n        o = {},\n        l = d(null);\n      let c = l;\n      function h(e) {\n        return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);\n      }\n      function u(e) {\n        return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);\n      }\n      function d(t) {\n        const e = [],\n          n = [],\n          i = [];\n        for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);\n        return {\n          geometry: null,\n          program: null,\n          wireframe: !1,\n          newAttributes: e,\n          enabledAttributes: n,\n          attributeDivisors: i,\n          object: t,\n          attributes: {},\n          index: null,\n        };\n      }\n      function p() {\n        const t = c.newAttributes;\n        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;\n      }\n      function m(t) {\n        f(t, 0);\n      }\n      function f(n, r) {\n        const s = c.newAttributes,\n          a = c.enabledAttributes,\n          o = c.attributeDivisors;\n        if (\n          ((s[n] = 1),\n          0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),\n          o[n] !== r)\n        ) {\n          (i.isWebGL2 ? t : e.get(\"ANGLE_instanced_arrays\"))[\n            i.isWebGL2 ? \"vertexAttribDivisor\" : \"vertexAttribDivisorANGLE\"\n          ](n, r),\n            (o[n] = r);\n        }\n      }\n      function g() {\n        const e = c.newAttributes,\n          n = c.enabledAttributes;\n        for (let i = 0, r = n.length; i < r; i++)\n          n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));\n      }\n      function v(e, n, r, s, a, o) {\n        !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)\n          ? t.vertexAttribPointer(e, n, r, s, a, o)\n          : t.vertexAttribIPointer(e, n, r, a, o);\n      }\n      function y() {\n        x(), c !== l && ((c = l), h(c.object));\n      }\n      function x() {\n        (l.geometry = null), (l.program = null), (l.wireframe = !1);\n      }\n      return {\n        setup: function (r, l, u, y, x) {\n          let _ = !1;\n          if (a) {\n            const e = (function (e, n, r) {\n              const a = !0 === r.wireframe;\n              let l = o[e.id];\n              void 0 === l && ((l = {}), (o[e.id] = l));\n              let c = l[n.id];\n              void 0 === c && ((c = {}), (l[n.id] = c));\n              let h = c[a];\n              void 0 === h &&\n                ((h = d(\n                  i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()\n                )),\n                (c[a] = h));\n              return h;\n            })(y, u, l);\n            c !== e && ((c = e), h(c.object)),\n              (_ = (function (t, e) {\n                const n = c.attributes,\n                  i = t.attributes;\n                let r = 0;\n                for (const t in i) {\n                  const e = n[t],\n                    s = i[t];\n                  if (void 0 === e) return !0;\n                  if (e.attribute !== s) return !0;\n                  if (e.data !== s.data) return !0;\n                  r++;\n                }\n                return c.attributesNum !== r || c.index !== e;\n              })(y, x)),\n              _ &&\n                (function (t, e) {\n                  const n = {},\n                    i = t.attributes;\n                  let r = 0;\n                  for (const t in i) {\n                    const e = i[t],\n                      s = {};\n                    (s.attribute = e),\n                      e.data && (s.data = e.data),\n                      (n[t] = s),\n                      r++;\n                  }\n                  (c.attributes = n), (c.attributesNum = r), (c.index = e);\n                })(y, x);\n          } else {\n            const t = !0 === l.wireframe;\n            (c.geometry === y.id && c.program === u.id && c.wireframe === t) ||\n              ((c.geometry = y.id),\n              (c.program = u.id),\n              (c.wireframe = t),\n              (_ = !0));\n          }\n          !0 === r.isInstancedMesh && (_ = !0),\n            null !== x && n.update(x, 34963),\n            _ &&\n              (!(function (r, s, a, o) {\n                if (\n                  !1 === i.isWebGL2 &&\n                  (r.isInstancedMesh || o.isInstancedBufferGeometry) &&\n                  null === e.get(\"ANGLE_instanced_arrays\")\n                )\n                  return;\n                p();\n                const l = o.attributes,\n                  c = a.getAttributes(),\n                  h = s.defaultAttributeValues;\n                for (const e in c) {\n                  const i = c[e];\n                  if (i.location >= 0) {\n                    let s = l[e];\n                    if (\n                      (void 0 === s &&\n                        (\"instanceMatrix\" === e &&\n                          r.instanceMatrix &&\n                          (s = r.instanceMatrix),\n                        \"instanceColor\" === e &&\n                          r.instanceColor &&\n                          (s = r.instanceColor)),\n                      void 0 !== s)\n                    ) {\n                      const e = s.normalized,\n                        a = s.itemSize,\n                        l = n.get(s);\n                      if (void 0 === l) continue;\n                      const c = l.buffer,\n                        h = l.type,\n                        u = l.bytesPerElement;\n                      if (s.isInterleavedBufferAttribute) {\n                        const n = s.data,\n                          l = n.stride,\n                          d = s.offset;\n                        if (n && n.isInstancedInterleavedBuffer) {\n                          for (let t = 0; t < i.locationSize; t++)\n                            f(i.location + t, n.meshPerAttribute);\n                          !0 !== r.isInstancedMesh &&\n                            void 0 === o._maxInstanceCount &&\n                            (o._maxInstanceCount =\n                              n.meshPerAttribute * n.count);\n                        } else\n                          for (let t = 0; t < i.locationSize; t++)\n                            m(i.location + t);\n                        t.bindBuffer(34962, c);\n                        for (let t = 0; t < i.locationSize; t++)\n                          v(\n                            i.location + t,\n                            a / i.locationSize,\n                            h,\n                            e,\n                            l * u,\n                            (d + (a / i.locationSize) * t) * u\n                          );\n                      } else {\n                        if (s.isInstancedBufferAttribute) {\n                          for (let t = 0; t < i.locationSize; t++)\n                            f(i.location + t, s.meshPerAttribute);\n                          !0 !== r.isInstancedMesh &&\n                            void 0 === o._maxInstanceCount &&\n                            (o._maxInstanceCount =\n                              s.meshPerAttribute * s.count);\n                        } else\n                          for (let t = 0; t < i.locationSize; t++)\n                            m(i.location + t);\n                        t.bindBuffer(34962, c);\n                        for (let t = 0; t < i.locationSize; t++)\n                          v(\n                            i.location + t,\n                            a / i.locationSize,\n                            h,\n                            e,\n                            a * u,\n                            (a / i.locationSize) * t * u\n                          );\n                      }\n                    } else if (void 0 !== h) {\n                      const n = h[e];\n                      if (void 0 !== n)\n                        switch (n.length) {\n                          case 2:\n                            t.vertexAttrib2fv(i.location, n);\n                            break;\n                          case 3:\n                            t.vertexAttrib3fv(i.location, n);\n                            break;\n                          case 4:\n                            t.vertexAttrib4fv(i.location, n);\n                            break;\n                          default:\n                            t.vertexAttrib1fv(i.location, n);\n                        }\n                    }\n                  }\n                }\n                g();\n              })(r, l, u, y),\n              null !== x && t.bindBuffer(34963, n.get(x).buffer));\n        },\n        reset: y,\n        resetDefaultState: x,\n        dispose: function () {\n          y();\n          for (const t in o) {\n            const e = o[t];\n            for (const t in e) {\n              const n = e[t];\n              for (const t in n) u(n[t].object), delete n[t];\n              delete e[t];\n            }\n            delete o[t];\n          }\n        },\n        releaseStatesOfGeometry: function (t) {\n          if (void 0 === o[t.id]) return;\n          const e = o[t.id];\n          for (const t in e) {\n            const n = e[t];\n            for (const t in n) u(n[t].object), delete n[t];\n            delete e[t];\n          }\n          delete o[t.id];\n        },\n        releaseStatesOfProgram: function (t) {\n          for (const e in o) {\n            const n = o[e];\n            if (void 0 === n[t.id]) continue;\n            const i = n[t.id];\n            for (const t in i) u(i[t].object), delete i[t];\n            delete n[t.id];\n          }\n        },\n        initAttributes: p,\n        enableAttribute: m,\n        disableUnusedAttributes: g,\n      };\n    }\n    function yi(t, e, n, i) {\n      const r = i.isWebGL2;\n      let s;\n      (this.setMode = function (t) {\n        s = t;\n      }),\n        (this.render = function (e, i) {\n          t.drawArrays(s, e, i), n.update(i, s, 1);\n        }),\n        (this.renderInstances = function (i, a, o) {\n          if (0 === o) return;\n          let l, c;\n          if (r) (l = t), (c = \"drawArraysInstanced\");\n          else if (\n            ((l = e.get(\"ANGLE_instanced_arrays\")),\n            (c = \"drawArraysInstancedANGLE\"),\n            null === l)\n          )\n            return void console.error(\n              \"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\"\n            );\n          l[c](s, i, a, o), n.update(a, s, o);\n        });\n    }\n    function xi(t, e, n) {\n      let i;\n      function r(e) {\n        if (\"highp\" === e) {\n          if (\n            t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&\n            t.getShaderPrecisionFormat(35632, 36338).precision > 0\n          )\n            return \"highp\";\n          e = \"mediump\";\n        }\n        return \"mediump\" === e &&\n          t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&\n          t.getShaderPrecisionFormat(35632, 36337).precision > 0\n          ? \"mediump\"\n          : \"lowp\";\n      }\n      const s =\n        (\"undefined\" != typeof WebGL2RenderingContext &&\n          t instanceof WebGL2RenderingContext) ||\n        (\"undefined\" != typeof WebGL2ComputeRenderingContext &&\n          t instanceof WebGL2ComputeRenderingContext);\n      let a = void 0 !== n.precision ? n.precision : \"highp\";\n      const o = r(a);\n      o !== a &&\n        (console.warn(\n          \"THREE.WebGLRenderer:\",\n          a,\n          \"not supported, using\",\n          o,\n          \"instead.\"\n        ),\n        (a = o));\n      const l = s || e.has(\"WEBGL_draw_buffers\"),\n        c = !0 === n.logarithmicDepthBuffer,\n        h = t.getParameter(34930),\n        u = t.getParameter(35660),\n        d = t.getParameter(3379),\n        p = t.getParameter(34076),\n        m = t.getParameter(34921),\n        f = t.getParameter(36347),\n        g = t.getParameter(36348),\n        v = t.getParameter(36349),\n        y = u > 0,\n        x = s || e.has(\"OES_texture_float\");\n      return {\n        isWebGL2: s,\n        drawBuffers: l,\n        getMaxAnisotropy: function () {\n          if (void 0 !== i) return i;\n          if (!0 === e.has(\"EXT_texture_filter_anisotropic\")) {\n            const n = e.get(\"EXT_texture_filter_anisotropic\");\n            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n          } else i = 0;\n          return i;\n        },\n        getMaxPrecision: r,\n        precision: a,\n        logarithmicDepthBuffer: c,\n        maxTextures: h,\n        maxVertexTextures: u,\n        maxTextureSize: d,\n        maxCubemapSize: p,\n        maxAttributes: m,\n        maxVertexUniforms: f,\n        maxVaryings: g,\n        maxFragmentUniforms: v,\n        vertexTextures: y,\n        floatFragmentTextures: x,\n        floatVertexTextures: y && x,\n        maxSamples: s ? t.getParameter(36183) : 0,\n      };\n    }\n    function _i(t) {\n      const e = this;\n      let n = null,\n        i = 0,\n        r = !1,\n        s = !1;\n      const a = new ai(),\n        o = new xt(),\n        l = { value: null, needsUpdate: !1 };\n      function c() {\n        l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),\n          (e.numPlanes = i),\n          (e.numIntersection = 0);\n      }\n      function h(t, n, i, r) {\n        const s = null !== t ? t.length : 0;\n        let c = null;\n        if (0 !== s) {\n          if (((c = l.value), !0 !== r || null === c)) {\n            const e = i + 4 * s,\n              r = n.matrixWorldInverse;\n            o.getNormalMatrix(r),\n              (null === c || c.length < e) && (c = new Float32Array(e));\n            for (let e = 0, n = i; e !== s; ++e, n += 4)\n              a.copy(t[e]).applyMatrix4(r, o),\n                a.normal.toArray(c, n),\n                (c[n + 3] = a.constant);\n          }\n          (l.value = c), (l.needsUpdate = !0);\n        }\n        return (e.numPlanes = s), (e.numIntersection = 0), c;\n      }\n      (this.uniform = l),\n        (this.numPlanes = 0),\n        (this.numIntersection = 0),\n        (this.init = function (t, e, s) {\n          const a = 0 !== t.length || e || 0 !== i || r;\n          return (r = e), (n = h(t, s, 0)), (i = t.length), a;\n        }),\n        (this.beginShadows = function () {\n          (s = !0), h(null);\n        }),\n        (this.endShadows = function () {\n          (s = !1), c();\n        }),\n        (this.setState = function (e, a, o) {\n          const u = e.clippingPlanes,\n            d = e.clipIntersection,\n            p = e.clipShadows,\n            m = t.get(e);\n          if (!r || null === u || 0 === u.length || (s && !p))\n            s ? h(null) : c();\n          else {\n            const t = s ? 0 : i,\n              e = 4 * t;\n            let r = m.clippingState || null;\n            (l.value = r), (r = h(u, a, e, o));\n            for (let t = 0; t !== e; ++t) r[t] = n[t];\n            (m.clippingState = r),\n              (this.numIntersection = d ? this.numPlanes : 0),\n              (this.numPlanes += t);\n          }\n        });\n    }\n    function Mi(t) {\n      let e = new WeakMap();\n      function n(t, e) {\n        return e === a ? (t.mapping = r) : e === o && (t.mapping = s), t;\n      }\n      function i(t) {\n        const n = t.target;\n        n.removeEventListener(\"dispose\", i);\n        const r = e.get(n);\n        void 0 !== r && (e.delete(n), r.dispose());\n      }\n      return {\n        get: function (r) {\n          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {\n            const s = r.mapping;\n            if (s === a || s === o) {\n              if (e.has(r)) {\n                return n(e.get(r).texture, r.mapping);\n              }\n              {\n                const s = r.image;\n                if (s && s.height > 0) {\n                  const a = t.getRenderTarget(),\n                    o = new ni(s.height / 2);\n                  return (\n                    o.fromEquirectangularTexture(t, r),\n                    e.set(r, o),\n                    t.setRenderTarget(a),\n                    r.addEventListener(\"dispose\", i),\n                    n(o.texture, r.mapping)\n                  );\n                }\n                return null;\n              }\n            }\n          }\n          return r;\n        },\n        dispose: function () {\n          e = new WeakMap();\n        },\n      };\n    }\n    fi.physical = {\n      uniforms: Yn([\n        fi.standard.uniforms,\n        {\n          clearcoat: { value: 0 },\n          clearcoatMap: { value: null },\n          clearcoatRoughness: { value: 0 },\n          clearcoatRoughnessMap: { value: null },\n          clearcoatNormalScale: { value: new yt(1, 1) },\n          clearcoatNormalMap: { value: null },\n          sheen: { value: 0 },\n          sheenColor: { value: new rn(0) },\n          sheenColorMap: { value: null },\n          sheenRoughness: { value: 0 },\n          sheenRoughnessMap: { value: null },\n          transmission: { value: 0 },\n          transmissionMap: { value: null },\n          transmissionSamplerSize: { value: new yt() },\n          transmissionSamplerMap: { value: null },\n          thickness: { value: 0 },\n          thicknessMap: { value: null },\n          attenuationDistance: { value: 0 },\n          attenuationColor: { value: new rn(0) },\n          specularIntensity: { value: 0 },\n          specularIntensityMap: { value: null },\n          specularColor: { value: new rn(1, 1, 1) },\n          specularColorMap: { value: null },\n        },\n      ]),\n      vertexShader: pi.meshphysical_vert,\n      fragmentShader: pi.meshphysical_frag,\n    };\n    class bi extends Qn {\n      constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {\n        super(),\n          (this.type = \"OrthographicCamera\"),\n          (this.zoom = 1),\n          (this.view = null),\n          (this.left = t),\n          (this.right = e),\n          (this.top = n),\n          (this.bottom = i),\n          (this.near = r),\n          (this.far = s),\n          this.updateProjectionMatrix();\n      }\n      copy(t, e) {\n        return (\n          super.copy(t, e),\n          (this.left = t.left),\n          (this.right = t.right),\n          (this.top = t.top),\n          (this.bottom = t.bottom),\n          (this.near = t.near),\n          (this.far = t.far),\n          (this.zoom = t.zoom),\n          (this.view = null === t.view ? null : Object.assign({}, t.view)),\n          this\n        );\n      }\n      setViewOffset(t, e, n, i, r, s) {\n        null === this.view &&\n          (this.view = {\n            enabled: !0,\n            fullWidth: 1,\n            fullHeight: 1,\n            offsetX: 0,\n            offsetY: 0,\n            width: 1,\n            height: 1,\n          }),\n          (this.view.enabled = !0),\n          (this.view.fullWidth = t),\n          (this.view.fullHeight = e),\n          (this.view.offsetX = n),\n          (this.view.offsetY = i),\n          (this.view.width = r),\n          (this.view.height = s),\n          this.updateProjectionMatrix();\n      }\n      clearViewOffset() {\n        null !== this.view && (this.view.enabled = !1),\n          this.updateProjectionMatrix();\n      }\n      updateProjectionMatrix() {\n        const t = (this.right - this.left) / (2 * this.zoom),\n          e = (this.top - this.bottom) / (2 * this.zoom),\n          n = (this.right + this.left) / 2,\n          i = (this.top + this.bottom) / 2;\n        let r = n - t,\n          s = n + t,\n          a = i + e,\n          o = i - e;\n        if (null !== this.view && this.view.enabled) {\n          const t = (this.right - this.left) / this.view.fullWidth / this.zoom,\n            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n          (r += t * this.view.offsetX),\n            (s = r + t * this.view.width),\n            (a -= e * this.view.offsetY),\n            (o = a - e * this.view.height);\n        }\n        this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),\n          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (\n          (e.object.zoom = this.zoom),\n          (e.object.left = this.left),\n          (e.object.right = this.right),\n          (e.object.top = this.top),\n          (e.object.bottom = this.bottom),\n          (e.object.near = this.near),\n          (e.object.far = this.far),\n          null !== this.view && (e.object.view = Object.assign({}, this.view)),\n          e\n        );\n      }\n    }\n    bi.prototype.isOrthographicCamera = !0;\n    class wi extends Zn {\n      constructor(t) {\n        super(t), (this.type = \"RawShaderMaterial\");\n      }\n    }\n    wi.prototype.isRawShaderMaterial = !0;\n    const Si = Math.pow(2, 8),\n      Ti = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],\n      Ei = 5 + Ti.length,\n      Ai = 20,\n      Li = { [X]: 0, [Y]: 1, [Z]: 2, [Q]: 3, [K]: 4, [$]: 5, [J]: 6 },\n      Ri = new bi(),\n      { _lodPlanes: Ci, _sizeLods: Pi, _sigmas: Ii } = Hi(),\n      Di = new rn();\n    let Ni = null;\n    const zi = (1 + Math.sqrt(5)) / 2,\n      Bi = 1 / zi,\n      Fi = [\n        new zt(1, 1, 1),\n        new zt(-1, 1, 1),\n        new zt(1, 1, -1),\n        new zt(-1, 1, -1),\n        new zt(0, zi, Bi),\n        new zt(0, zi, -Bi),\n        new zt(Bi, 0, zi),\n        new zt(-Bi, 0, zi),\n        new zt(zi, Bi, 0),\n        new zt(-zi, Bi, 0),\n      ];\n    class Oi {\n      constructor(t) {\n        (this._renderer = t),\n          (this._pingPongRenderTarget = null),\n          (this._blurMaterial = (function (t) {\n            const e = new Float32Array(t),\n              n = new zt(0, 1, 0);\n            return new wi({\n              name: \"SphericalGaussianBlur\",\n              defines: { n: t },\n              uniforms: {\n                envMap: { value: null },\n                samples: { value: 1 },\n                weights: { value: e },\n                latitudinal: { value: !1 },\n                dTheta: { value: 0 },\n                mipInt: { value: 0 },\n                poleAxis: { value: n },\n                inputEncoding: { value: Li[3e3] },\n                outputEncoding: { value: Li[3e3] },\n              },\n              vertexShader: ji(),\n              fragmentShader: `\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform int samples;\\n\\t\\t\\tuniform float weights[ n ];\\n\\t\\t\\tuniform bool latitudinal;\\n\\t\\t\\tuniform float dTheta;\\n\\t\\t\\tuniform float mipInt;\\n\\t\\t\\tuniform vec3 poleAxis;\\n\\n\\t\\t\\t${qi()}\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t#include <cube_uv_reflection_fragment>\\n\\n\\t\\t\\tvec3 getSample( float theta, vec3 axis ) {\\n\\n\\t\\t\\t\\tfloat cosTheta = cos( theta );\\n\\t\\t\\t\\t// Rodrigues' axis-angle rotation\\n\\t\\t\\t\\tvec3 sampleDirection = vOutputDirection * cosTheta\\n\\t\\t\\t\\t\\t+ cross( axis, vOutputDirection ) * sin( theta )\\n\\t\\t\\t\\t\\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\\n\\n\\t\\t\\t\\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\\n\\n\\t\\t\\t\\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\\n\\n\\t\\t\\t\\t\\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taxis = normalize( axis );\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\\n\\n\\t\\t\\t\\tfor ( int i = 1; i < n; i++ ) {\\n\\n\\t\\t\\t\\t\\tif ( i >= samples ) {\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfloat theta = dTheta * float( i );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t`,\n              blending: 0,\n              depthTest: !1,\n              depthWrite: !1,\n            });\n          })(Ai)),\n          (this._equirectShader = null),\n          (this._cubemapShader = null),\n          this._compileMaterial(this._blurMaterial);\n      }\n      fromScene(t, e = 0, n = 0.1, i = 100) {\n        Ni = this._renderer.getRenderTarget();\n        const r = this._allocateTargets();\n        return (\n          this._sceneToCubeUV(t, n, i, r),\n          e > 0 && this._blur(r, 0, 0, e),\n          this._applyPMREM(r),\n          this._cleanup(r),\n          r\n        );\n      }\n      fromEquirectangular(t) {\n        return this._fromTexture(t);\n      }\n      fromCubemap(t) {\n        return this._fromTexture(t);\n      }\n      compileCubemapShader() {\n        null === this._cubemapShader &&\n          ((this._cubemapShader = Wi()),\n          this._compileMaterial(this._cubemapShader));\n      }\n      compileEquirectangularShader() {\n        null === this._equirectShader &&\n          ((this._equirectShader = Vi()),\n          this._compileMaterial(this._equirectShader));\n      }\n      dispose() {\n        this._blurMaterial.dispose(),\n          null !== this._cubemapShader && this._cubemapShader.dispose(),\n          null !== this._equirectShader && this._equirectShader.dispose();\n        for (let t = 0; t < Ci.length; t++) Ci[t].dispose();\n      }\n      _cleanup(t) {\n        this._pingPongRenderTarget.dispose(),\n          this._renderer.setRenderTarget(Ni),\n          (t.scissorTest = !1),\n          ki(t, 0, 0, t.width, t.height);\n      }\n      _fromTexture(t) {\n        Ni = this._renderer.getRenderTarget();\n        const e = this._allocateTargets(t);\n        return (\n          this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e\n        );\n      }\n      _allocateTargets(t) {\n        const e = {\n            magFilter: p,\n            minFilter: p,\n            generateMipmaps: !1,\n            type: x,\n            format: 1023,\n            encoding: Ui(t) ? t.encoding : Z,\n            depthBuffer: !1,\n          },\n          n = Gi(e);\n        return (n.depthBuffer = !t), (this._pingPongRenderTarget = Gi(e)), n;\n      }\n      _compileMaterial(t) {\n        const e = new Wn(Ci[0], t);\n        this._renderer.compile(e, Ri);\n      }\n      _sceneToCubeUV(t, e, n, i) {\n        const r = new Kn(90, 1, e, n),\n          s = [1, -1, 1, 1, 1, 1],\n          a = [1, 1, 1, -1, -1, -1],\n          o = this._renderer,\n          l = o.autoClear,\n          c = o.outputEncoding,\n          h = o.toneMapping;\n        o.getClearColor(Di),\n          (o.toneMapping = 0),\n          (o.outputEncoding = X),\n          (o.autoClear = !1);\n        const u = new sn({\n            name: \"PMREM.Background\",\n            side: 1,\n            depthWrite: !1,\n            depthTest: !1,\n          }),\n          d = new Wn(new qn(), u);\n        let p = !1;\n        const m = t.background;\n        m\n          ? m.isColor && (u.color.copy(m), (t.background = null), (p = !0))\n          : (u.color.copy(Di), (p = !0));\n        for (let e = 0; e < 6; e++) {\n          const n = e % 3;\n          0 == n\n            ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))\n            : 1 == n\n            ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))\n            : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])),\n            ki(i, n * Si, e > 2 ? Si : 0, Si, Si),\n            o.setRenderTarget(i),\n            p && o.render(d, r),\n            o.render(t, r);\n        }\n        d.geometry.dispose(),\n          d.material.dispose(),\n          (o.toneMapping = h),\n          (o.outputEncoding = c),\n          (o.autoClear = l),\n          (t.background = m);\n      }\n      _setEncoding(t, e) {\n        !0 === this._renderer.capabilities.isWebGL2 &&\n        e.format === E &&\n        e.type === x &&\n        e.encoding === Y\n          ? (t.value = Li[3e3])\n          : (t.value = Li[e.encoding]);\n      }\n      _textureToCubeUV(t, e) {\n        const n = this._renderer,\n          i = t.mapping === r || t.mapping === s;\n        i\n          ? null == this._cubemapShader && (this._cubemapShader = Wi())\n          : null == this._equirectShader && (this._equirectShader = Vi());\n        const a = i ? this._cubemapShader : this._equirectShader,\n          o = new Wn(Ci[0], a),\n          l = a.uniforms;\n        (l.envMap.value = t),\n          i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height),\n          this._setEncoding(l.inputEncoding, t),\n          this._setEncoding(l.outputEncoding, e.texture),\n          ki(e, 0, 0, 3 * Si, 2 * Si),\n          n.setRenderTarget(e),\n          n.render(o, Ri);\n      }\n      _applyPMREM(t) {\n        const e = this._renderer,\n          n = e.autoClear;\n        e.autoClear = !1;\n        for (let e = 1; e < Ei; e++) {\n          const n = Math.sqrt(Ii[e] * Ii[e] - Ii[e - 1] * Ii[e - 1]),\n            i = Fi[(e - 1) % Fi.length];\n          this._blur(t, e - 1, e, n, i);\n        }\n        e.autoClear = n;\n      }\n      _blur(t, e, n, i, r) {\n        const s = this._pingPongRenderTarget;\n        this._halfBlur(t, s, e, n, i, \"latitudinal\", r),\n          this._halfBlur(s, t, n, n, i, \"longitudinal\", r);\n      }\n      _halfBlur(t, e, n, i, r, s, a) {\n        const o = this._renderer,\n          l = this._blurMaterial;\n        \"latitudinal\" !== s &&\n          \"longitudinal\" !== s &&\n          console.error(\n            \"blur direction must be either latitudinal or longitudinal!\"\n          );\n        const c = new Wn(Ci[i], l),\n          h = l.uniforms,\n          u = Pi[n] - 1,\n          d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,\n          p = r / d,\n          m = isFinite(r) ? 1 + Math.floor(3 * p) : Ai;\n        m > Ai &&\n          console.warn(\n            `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`\n          );\n        const f = [];\n        let g = 0;\n        for (let t = 0; t < Ai; ++t) {\n          const e = t / p,\n            n = Math.exp((-e * e) / 2);\n          f.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n);\n        }\n        for (let t = 0; t < f.length; t++) f[t] = f[t] / g;\n        (h.envMap.value = t.texture),\n          (h.samples.value = m),\n          (h.weights.value = f),\n          (h.latitudinal.value = \"latitudinal\" === s),\n          a && (h.poleAxis.value = a),\n          (h.dTheta.value = d),\n          (h.mipInt.value = 8 - n),\n          this._setEncoding(h.inputEncoding, t.texture),\n          this._setEncoding(h.outputEncoding, t.texture);\n        const v = Pi[i];\n        ki(\n          e,\n          3 * Math.max(0, Si - 2 * v),\n          (0 === i ? 0 : 2 * Si) + 2 * v * (i > 4 ? i - 8 + 4 : 0),\n          3 * v,\n          2 * v\n        ),\n          o.setRenderTarget(e),\n          o.render(c, Ri);\n      }\n    }\n    function Ui(t) {\n      return (\n        void 0 !== t &&\n        t.type === x &&\n        (t.encoding === X || t.encoding === Y || t.encoding === J)\n      );\n    }\n    function Hi() {\n      const t = [],\n        e = [],\n        n = [];\n      let i = 8;\n      for (let r = 0; r < Ei; r++) {\n        const s = Math.pow(2, i);\n        e.push(s);\n        let a = 1 / s;\n        r > 4 ? (a = Ti[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);\n        const o = 1 / (s - 1),\n          l = -o / 2,\n          c = 1 + o / 2,\n          h = [l, l, c, l, c, c, l, l, c, c, l, c],\n          u = 6,\n          d = 6,\n          p = 3,\n          m = 2,\n          f = 1,\n          g = new Float32Array(p * d * u),\n          v = new Float32Array(m * d * u),\n          y = new Float32Array(f * d * u);\n        for (let t = 0; t < u; t++) {\n          const e = ((t % 3) * 2) / 3 - 1,\n            n = t > 2 ? 0 : -1,\n            i = [\n              e,\n              n,\n              0,\n              e + 2 / 3,\n              n,\n              0,\n              e + 2 / 3,\n              n + 1,\n              0,\n              e,\n              n,\n              0,\n              e + 2 / 3,\n              n + 1,\n              0,\n              e,\n              n + 1,\n              0,\n            ];\n          g.set(i, p * d * t), v.set(h, m * d * t);\n          const r = [t, t, t, t, t, t];\n          y.set(r, f * d * t);\n        }\n        const x = new En();\n        x.setAttribute(\"position\", new ln(g, p)),\n          x.setAttribute(\"uv\", new ln(v, m)),\n          x.setAttribute(\"faceIndex\", new ln(y, f)),\n          t.push(x),\n          i > 4 && i--;\n      }\n      return { _lodPlanes: t, _sizeLods: e, _sigmas: n };\n    }\n    function Gi(t) {\n      const e = new Pt(3 * Si, 3 * Si, t);\n      return (\n        (e.texture.mapping = l),\n        (e.texture.name = \"PMREM.cubeUv\"),\n        (e.scissorTest = !0),\n        e\n      );\n    }\n    function ki(t, e, n, i, r) {\n      t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);\n    }\n    function Vi() {\n      const t = new yt(1, 1);\n      return new wi({\n        name: \"EquirectangularToCubeUV\",\n        uniforms: {\n          envMap: { value: null },\n          texelSize: { value: t },\n          inputEncoding: { value: Li[3e3] },\n          outputEncoding: { value: Li[3e3] },\n        },\n        vertexShader: ji(),\n        fragmentShader: `\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform vec2 texelSize;\\n\\n\\t\\t\\t${qi()}\\n\\n\\t\\t\\t#include <common>\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\n\\t\\t\\t\\tvec3 outputDirection = normalize( vOutputDirection );\\n\\t\\t\\t\\tvec2 uv = equirectUv( outputDirection );\\n\\n\\t\\t\\t\\tvec2 f = fract( uv / texelSize - 0.5 );\\n\\t\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\t\\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x += texelSize.x;\\n\\t\\t\\t\\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.y += texelSize.y;\\n\\t\\t\\t\\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x -= texelSize.x;\\n\\t\\t\\t\\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\n\\t\\t\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\t\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\t\\t\\tgl_FragColor.rgb = mix( tm, bm, f.y );\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t`,\n        blending: 0,\n        depthTest: !1,\n        depthWrite: !1,\n      });\n    }\n    function Wi() {\n      return new wi({\n        name: \"CubemapToCubeUV\",\n        uniforms: {\n          envMap: { value: null },\n          inputEncoding: { value: Li[3e3] },\n          outputEncoding: { value: Li[3e3] },\n        },\n        vertexShader: ji(),\n        fragmentShader: `\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform samplerCube envMap;\\n\\n\\t\\t\\t${qi()}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t`,\n        blending: 0,\n        depthTest: !1,\n        depthWrite: !1,\n      });\n    }\n    function ji() {\n      return \"\\n\\n\\t\\tprecision mediump float;\\n\\t\\tprecision mediump int;\\n\\n\\t\\tattribute vec3 position;\\n\\t\\tattribute vec2 uv;\\n\\t\\tattribute float faceIndex;\\n\\n\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t// RH coordinate system; PMREM face-indexing convention\\n\\t\\tvec3 getDirection( vec2 uv, float face ) {\\n\\n\\t\\t\\tuv = 2.0 * uv - 1.0;\\n\\n\\t\\t\\tvec3 direction = vec3( uv, 1.0 );\\n\\n\\t\\t\\tif ( face == 0.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx; // ( 1, v, u ) pos x\\n\\n\\t\\t\\t} else if ( face == 1.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\\n\\n\\t\\t\\t} else if ( face == 2.0 ) {\\n\\n\\t\\t\\t\\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\\n\\n\\t\\t\\t} else if ( face == 3.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\\n\\n\\t\\t\\t} else if ( face == 4.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\\n\\n\\t\\t\\t} else if ( face == 5.0 ) {\\n\\n\\t\\t\\t\\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn direction;\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvOutputDirection = getDirection( uv, faceIndex );\\n\\t\\t\\tgl_Position = vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\t\";\n    }\n    function qi() {\n      return \"\\n\\n\\t\\tuniform int inputEncoding;\\n\\t\\tuniform int outputEncoding;\\n\\n\\t\\t#include <encodings_pars_fragment>\\n\\n\\t\\tvec4 inputTexelToLinear( vec4 value ) {\\n\\n\\t\\t\\tif ( inputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( inputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn sRGBToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn RGBEToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 7.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 16.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn RGBDToLinear( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn GammaToLinear( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 linearToOutputTexel( vec4 value ) {\\n\\n\\t\\t\\tif ( outputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( outputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn LinearTosRGB( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBE( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 7.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 16.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBD( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn LinearToGamma( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 envMapTexelToLinear( vec4 color ) {\\n\\n\\t\\t\\treturn inputTexelToLinear( color );\\n\\n\\t\\t}\\n\\t\";\n    }\n    function Xi(t) {\n      let e = new WeakMap(),\n        n = null;\n      function i(t) {\n        const n = t.target;\n        n.removeEventListener(\"dispose\", i);\n        const r = e.get(n);\n        void 0 !== r && (e.delete(n), r.dispose());\n      }\n      return {\n        get: function (l) {\n          if (l && l.isTexture && !1 === l.isRenderTargetTexture) {\n            const c = l.mapping,\n              h = c === a || c === o,\n              u = c === r || c === s;\n            if (h || u) {\n              if (e.has(l)) return e.get(l).texture;\n              {\n                const r = l.image;\n                if (\n                  (h && r && r.height > 0) ||\n                  (u &&\n                    r &&\n                    (function (t) {\n                      let e = 0;\n                      const n = 6;\n                      for (let i = 0; i < n; i++) void 0 !== t[i] && e++;\n                      return e === n;\n                    })(r))\n                ) {\n                  const r = t.getRenderTarget();\n                  null === n && (n = new Oi(t));\n                  const s = h ? n.fromEquirectangular(l) : n.fromCubemap(l);\n                  return (\n                    e.set(l, s),\n                    t.setRenderTarget(r),\n                    l.addEventListener(\"dispose\", i),\n                    s.texture\n                  );\n                }\n                return null;\n              }\n            }\n          }\n          return l;\n        },\n        dispose: function () {\n          (e = new WeakMap()), null !== n && (n.dispose(), (n = null));\n        },\n      };\n    }\n    function Yi(t) {\n      const e = {};\n      function n(n) {\n        if (void 0 !== e[n]) return e[n];\n        let i;\n        switch (n) {\n          case \"WEBGL_depth_texture\":\n            i =\n              t.getExtension(\"WEBGL_depth_texture\") ||\n              t.getExtension(\"MOZ_WEBGL_depth_texture\") ||\n              t.getExtension(\"WEBKIT_WEBGL_depth_texture\");\n            break;\n          case \"EXT_texture_filter_anisotropic\":\n            i =\n              t.getExtension(\"EXT_texture_filter_anisotropic\") ||\n              t.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") ||\n              t.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n            break;\n          case \"WEBGL_compressed_texture_s3tc\":\n            i =\n              t.getExtension(\"WEBGL_compressed_texture_s3tc\") ||\n              t.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") ||\n              t.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n            break;\n          case \"WEBGL_compressed_texture_pvrtc\":\n            i =\n              t.getExtension(\"WEBGL_compressed_texture_pvrtc\") ||\n              t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n            break;\n          default:\n            i = t.getExtension(n);\n        }\n        return (e[n] = i), i;\n      }\n      return {\n        has: function (t) {\n          return null !== n(t);\n        },\n        init: function (t) {\n          t.isWebGL2\n            ? n(\"EXT_color_buffer_float\")\n            : (n(\"WEBGL_depth_texture\"),\n              n(\"OES_texture_float\"),\n              n(\"OES_texture_half_float\"),\n              n(\"OES_texture_half_float_linear\"),\n              n(\"OES_standard_derivatives\"),\n              n(\"OES_element_index_uint\"),\n              n(\"OES_vertex_array_object\"),\n              n(\"ANGLE_instanced_arrays\")),\n            n(\"OES_texture_float_linear\"),\n            n(\"EXT_color_buffer_half_float\");\n        },\n        get: function (t) {\n          const e = n(t);\n          return (\n            null === e &&\n              console.warn(\n                \"THREE.WebGLRenderer: \" + t + \" extension not supported.\"\n              ),\n            e\n          );\n        },\n      };\n    }\n    function Ji(t, e, n, i) {\n      const r = {},\n        s = new WeakMap();\n      function a(t) {\n        const o = t.target;\n        null !== o.index && e.remove(o.index);\n        for (const t in o.attributes) e.remove(o.attributes[t]);\n        o.removeEventListener(\"dispose\", a), delete r[o.id];\n        const l = s.get(o);\n        l && (e.remove(l), s.delete(o)),\n          i.releaseStatesOfGeometry(o),\n          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,\n          n.memory.geometries--;\n      }\n      function o(t) {\n        const n = [],\n          i = t.index,\n          r = t.attributes.position;\n        let a = 0;\n        if (null !== i) {\n          const t = i.array;\n          a = i.version;\n          for (let e = 0, i = t.length; e < i; e += 3) {\n            const i = t[e + 0],\n              r = t[e + 1],\n              s = t[e + 2];\n            n.push(i, r, r, s, s, i);\n          }\n        } else {\n          const t = r.array;\n          a = r.version;\n          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {\n            const t = e + 0,\n              i = e + 1,\n              r = e + 2;\n            n.push(t, i, i, r, r, t);\n          }\n        }\n        const o = new (_t(n) > 65535 ? fn : pn)(n, 1);\n        o.version = a;\n        const l = s.get(t);\n        l && e.remove(l), s.set(t, o);\n      }\n      return {\n        get: function (t, e) {\n          return (\n            !0 === r[e.id] ||\n              (e.addEventListener(\"dispose\", a),\n              (r[e.id] = !0),\n              n.memory.geometries++),\n            e\n          );\n        },\n        update: function (t) {\n          const n = t.attributes;\n          for (const t in n) e.update(n[t], 34962);\n          const i = t.morphAttributes;\n          for (const t in i) {\n            const n = i[t];\n            for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);\n          }\n        },\n        getWireframeAttribute: function (t) {\n          const e = s.get(t);\n          if (e) {\n            const n = t.index;\n            null !== n && e.version < n.version && o(t);\n          } else o(t);\n          return s.get(t);\n        },\n      };\n    }\n    function Zi(t, e, n, i) {\n      const r = i.isWebGL2;\n      let s, a, o;\n      (this.setMode = function (t) {\n        s = t;\n      }),\n        (this.setIndex = function (t) {\n          (a = t.type), (o = t.bytesPerElement);\n        }),\n        (this.render = function (e, i) {\n          t.drawElements(s, i, a, e * o), n.update(i, s, 1);\n        }),\n        (this.renderInstances = function (i, l, c) {\n          if (0 === c) return;\n          let h, u;\n          if (r) (h = t), (u = \"drawElementsInstanced\");\n          else if (\n            ((h = e.get(\"ANGLE_instanced_arrays\")),\n            (u = \"drawElementsInstancedANGLE\"),\n            null === h)\n          )\n            return void console.error(\n              \"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\"\n            );\n          h[u](s, l, a, i * o, c), n.update(l, s, c);\n        });\n    }\n    function Qi(t) {\n      const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };\n      return {\n        memory: { geometries: 0, textures: 0 },\n        render: e,\n        programs: null,\n        autoReset: !0,\n        reset: function () {\n          e.frame++,\n            (e.calls = 0),\n            (e.triangles = 0),\n            (e.points = 0),\n            (e.lines = 0);\n        },\n        update: function (t, n, i) {\n          switch ((e.calls++, n)) {\n            case 4:\n              e.triangles += i * (t / 3);\n              break;\n            case 1:\n              e.lines += i * (t / 2);\n              break;\n            case 3:\n              e.lines += i * (t - 1);\n              break;\n            case 2:\n              e.lines += i * t;\n              break;\n            case 0:\n              e.points += i * t;\n              break;\n            default:\n              console.error(\"THREE.WebGLInfo: Unknown draw mode:\", n);\n          }\n        },\n      };\n    }\n    class Ki extends Lt {\n      constructor(t = null, e = 1, n = 1, i = 1) {\n        super(null),\n          (this.image = { data: t, width: e, height: n, depth: i }),\n          (this.magFilter = p),\n          (this.minFilter = p),\n          (this.wrapR = u),\n          (this.generateMipmaps = !1),\n          (this.flipY = !1),\n          (this.unpackAlignment = 1),\n          (this.needsUpdate = !0);\n      }\n    }\n    function $i(t, e) {\n      return t[0] - e[0];\n    }\n    function tr(t, e) {\n      return Math.abs(e[1]) - Math.abs(t[1]);\n    }\n    function er(t, e) {\n      let n = 1;\n      const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;\n      i instanceof Int8Array\n        ? (n = 127)\n        : i instanceof Int16Array\n        ? (n = 32767)\n        : i instanceof Int32Array\n        ? (n = 2147483647)\n        : console.error(\n            \"THREE.WebGLMorphtargets: Unsupported morph attribute data type: \",\n            i\n          ),\n        t.divideScalar(n);\n    }\n    function nr(t, e, n) {\n      const i = {},\n        r = new Float32Array(8),\n        s = new WeakMap(),\n        a = new zt(),\n        o = [];\n      for (let t = 0; t < 8; t++) o[t] = [t, 0];\n      return {\n        update: function (l, c, h, u) {\n          const d = l.morphTargetInfluences;\n          if (!0 === e.isWebGL2) {\n            const i = c.morphAttributes.position.length;\n            let r = s.get(c);\n            if (void 0 === r || r.count !== i) {\n              void 0 !== r && r.texture.dispose();\n              const t = void 0 !== c.morphAttributes.normal,\n                n = c.morphAttributes.position,\n                o = c.morphAttributes.normal || [],\n                l = !0 === t ? 2 : 1;\n              let h = c.attributes.position.count * l,\n                u = 1;\n              h > e.maxTextureSize &&\n                ((u = Math.ceil(h / e.maxTextureSize)), (h = e.maxTextureSize));\n              const d = new Float32Array(h * u * 4 * i),\n                p = new Ki(d, h, u, i);\n              (p.format = E), (p.type = b);\n              const m = 4 * l;\n              for (let e = 0; e < i; e++) {\n                const i = n[e],\n                  r = o[e],\n                  s = h * u * 4 * e;\n                for (let e = 0; e < i.count; e++) {\n                  a.fromBufferAttribute(i, e), !0 === i.normalized && er(a, i);\n                  const n = e * m;\n                  (d[s + n + 0] = a.x),\n                    (d[s + n + 1] = a.y),\n                    (d[s + n + 2] = a.z),\n                    (d[s + n + 3] = 0),\n                    !0 === t &&\n                      (a.fromBufferAttribute(r, e),\n                      !0 === r.normalized && er(a, r),\n                      (d[s + n + 4] = a.x),\n                      (d[s + n + 5] = a.y),\n                      (d[s + n + 6] = a.z),\n                      (d[s + n + 7] = 0));\n                }\n              }\n              (r = { count: i, texture: p, size: new yt(h, u) }), s.set(c, r);\n            }\n            let o = 0;\n            for (let t = 0; t < d.length; t++) o += d[t];\n            const l = c.morphTargetsRelative ? 1 : 1 - o;\n            u.getUniforms().setValue(t, \"morphTargetBaseInfluence\", l),\n              u.getUniforms().setValue(t, \"morphTargetInfluences\", d),\n              u.getUniforms().setValue(t, \"morphTargetsTexture\", r.texture, n),\n              u.getUniforms().setValue(t, \"morphTargetsTextureSize\", r.size);\n          } else {\n            const e = void 0 === d ? 0 : d.length;\n            let n = i[c.id];\n            if (void 0 === n || n.length !== e) {\n              n = [];\n              for (let t = 0; t < e; t++) n[t] = [t, 0];\n              i[c.id] = n;\n            }\n            for (let t = 0; t < e; t++) {\n              const e = n[t];\n              (e[0] = t), (e[1] = d[t]);\n            }\n            n.sort(tr);\n            for (let t = 0; t < 8; t++)\n              t < e && n[t][1]\n                ? ((o[t][0] = n[t][0]), (o[t][1] = n[t][1]))\n                : ((o[t][0] = Number.MAX_SAFE_INTEGER), (o[t][1] = 0));\n            o.sort($i);\n            const s = c.morphAttributes.position,\n              a = c.morphAttributes.normal;\n            let l = 0;\n            for (let t = 0; t < 8; t++) {\n              const e = o[t],\n                n = e[0],\n                i = e[1];\n              n !== Number.MAX_SAFE_INTEGER && i\n                ? (s &&\n                    c.getAttribute(\"morphTarget\" + t) !== s[n] &&\n                    c.setAttribute(\"morphTarget\" + t, s[n]),\n                  a &&\n                    c.getAttribute(\"morphNormal\" + t) !== a[n] &&\n                    c.setAttribute(\"morphNormal\" + t, a[n]),\n                  (r[t] = i),\n                  (l += i))\n                : (s &&\n                    !0 === c.hasAttribute(\"morphTarget\" + t) &&\n                    c.deleteAttribute(\"morphTarget\" + t),\n                  a &&\n                    !0 === c.hasAttribute(\"morphNormal\" + t) &&\n                    c.deleteAttribute(\"morphNormal\" + t),\n                  (r[t] = 0));\n            }\n            const h = c.morphTargetsRelative ? 1 : 1 - l;\n            u.getUniforms().setValue(t, \"morphTargetBaseInfluence\", h),\n              u.getUniforms().setValue(t, \"morphTargetInfluences\", r);\n          }\n        },\n      };\n    }\n    function ir(t, e, n, i) {\n      let r = new WeakMap();\n      function s(t) {\n        const e = t.target;\n        e.removeEventListener(\"dispose\", s),\n          n.remove(e.instanceMatrix),\n          null !== e.instanceColor && n.remove(e.instanceColor);\n      }\n      return {\n        update: function (t) {\n          const a = i.render.frame,\n            o = t.geometry,\n            l = e.get(t, o);\n          return (\n            r.get(l) !== a && (e.update(l), r.set(l, a)),\n            t.isInstancedMesh &&\n              (!1 === t.hasEventListener(\"dispose\", s) &&\n                t.addEventListener(\"dispose\", s),\n              n.update(t.instanceMatrix, 34962),\n              null !== t.instanceColor && n.update(t.instanceColor, 34962)),\n            l\n          );\n        },\n        dispose: function () {\n          r = new WeakMap();\n        },\n      };\n    }\n    Ki.prototype.isDataTexture2DArray = !0;\n    class rr extends Lt {\n      constructor(t = null, e = 1, n = 1, i = 1) {\n        super(null),\n          (this.image = { data: t, width: e, height: n, depth: i }),\n          (this.magFilter = p),\n          (this.minFilter = p),\n          (this.wrapR = u),\n          (this.generateMipmaps = !1),\n          (this.flipY = !1),\n          (this.unpackAlignment = 1),\n          (this.needsUpdate = !0);\n      }\n    }\n    rr.prototype.isDataTexture3D = !0;\n    const sr = new Lt(),\n      ar = new Ki(),\n      or = new rr(),\n      lr = new ei(),\n      cr = [],\n      hr = [],\n      ur = new Float32Array(16),\n      dr = new Float32Array(9),\n      pr = new Float32Array(4);\n    function mr(t, e, n) {\n      const i = t[0];\n      if (i <= 0 || i > 0) return t;\n      const r = e * n;\n      let s = cr[r];\n      if ((void 0 === s && ((s = new Float32Array(r)), (cr[r] = s)), 0 !== e)) {\n        i.toArray(s, 0);\n        for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);\n      }\n      return s;\n    }\n    function fr(t, e) {\n      if (t.length !== e.length) return !1;\n      for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;\n      return !0;\n    }\n    function gr(t, e) {\n      for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];\n    }\n    function vr(t, e) {\n      let n = hr[e];\n      void 0 === n && ((n = new Int32Array(e)), (hr[e] = n));\n      for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();\n      return n;\n    }\n    function yr(t, e) {\n      const n = this.cache;\n      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));\n    }\n    function xr(t, e) {\n      const n = this.cache;\n      if (void 0 !== e.x)\n        (n[0] === e.x && n[1] === e.y) ||\n          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));\n      else {\n        if (fr(n, e)) return;\n        t.uniform2fv(this.addr, e), gr(n, e);\n      }\n    }\n    function _r(t, e) {\n      const n = this.cache;\n      if (void 0 !== e.x)\n        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||\n          (t.uniform3f(this.addr, e.x, e.y, e.z),\n          (n[0] = e.x),\n          (n[1] = e.y),\n          (n[2] = e.z));\n      else if (void 0 !== e.r)\n        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||\n          (t.uniform3f(this.addr, e.r, e.g, e.b),\n          (n[0] = e.r),\n          (n[1] = e.g),\n          (n[2] = e.b));\n      else {\n        if (fr(n, e)) return;\n        t.uniform3fv(this.addr, e), gr(n, e);\n      }\n    }\n    function Mr(t, e) {\n      const n = this.cache;\n      if (void 0 !== e.x)\n        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||\n          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),\n          (n[0] = e.x),\n          (n[1] = e.y),\n          (n[2] = e.z),\n          (n[3] = e.w));\n      else {\n        if (fr(n, e)) return;\n        t.uniform4fv(this.addr, e), gr(n, e);\n      }\n    }\n    function br(t, e) {\n      const n = this.cache,\n        i = e.elements;\n      if (void 0 === i) {\n        if (fr(n, e)) return;\n        t.uniformMatrix2fv(this.addr, !1, e), gr(n, e);\n      } else {\n        if (fr(n, i)) return;\n        pr.set(i), t.uniformMatrix2fv(this.addr, !1, pr), gr(n, i);\n      }\n    }\n    function wr(t, e) {\n      const n = this.cache,\n        i = e.elements;\n      if (void 0 === i) {\n        if (fr(n, e)) return;\n        t.uniformMatrix3fv(this.addr, !1, e), gr(n, e);\n      } else {\n        if (fr(n, i)) return;\n        dr.set(i), t.uniformMatrix3fv(this.addr, !1, dr), gr(n, i);\n      }\n    }\n    function Sr(t, e) {\n      const n = this.cache,\n        i = e.elements;\n      if (void 0 === i) {\n        if (fr(n, e)) return;\n        t.uniformMatrix4fv(this.addr, !1, e), gr(n, e);\n      } else {\n        if (fr(n, i)) return;\n        ur.set(i), t.uniformMatrix4fv(this.addr, !1, ur), gr(n, i);\n      }\n    }\n    function Tr(t, e) {\n      const n = this.cache;\n      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));\n    }\n    function Er(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform2iv(this.addr, e), gr(n, e));\n    }\n    function Ar(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform3iv(this.addr, e), gr(n, e));\n    }\n    function Lr(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform4iv(this.addr, e), gr(n, e));\n    }\n    function Rr(t, e) {\n      const n = this.cache;\n      n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));\n    }\n    function Cr(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform2uiv(this.addr, e), gr(n, e));\n    }\n    function Pr(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform3uiv(this.addr, e), gr(n, e));\n    }\n    function Ir(t, e) {\n      const n = this.cache;\n      fr(n, e) || (t.uniform4uiv(this.addr, e), gr(n, e));\n    }\n    function Dr(t, e, n) {\n      const i = this.cache,\n        r = n.allocateTextureUnit();\n      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),\n        n.safeSetTexture2D(e || sr, r);\n    }\n    function Nr(t, e, n) {\n      const i = this.cache,\n        r = n.allocateTextureUnit();\n      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),\n        n.setTexture3D(e || or, r);\n    }\n    function zr(t, e, n) {\n      const i = this.cache,\n        r = n.allocateTextureUnit();\n      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),\n        n.safeSetTextureCube(e || lr, r);\n    }\n    function Br(t, e, n) {\n      const i = this.cache,\n        r = n.allocateTextureUnit();\n      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),\n        n.setTexture2DArray(e || ar, r);\n    }\n    function Fr(t, e) {\n      t.uniform1fv(this.addr, e);\n    }\n    function Or(t, e) {\n      const n = mr(e, this.size, 2);\n      t.uniform2fv(this.addr, n);\n    }\n    function Ur(t, e) {\n      const n = mr(e, this.size, 3);\n      t.uniform3fv(this.addr, n);\n    }\n    function Hr(t, e) {\n      const n = mr(e, this.size, 4);\n      t.uniform4fv(this.addr, n);\n    }\n    function Gr(t, e) {\n      const n = mr(e, this.size, 4);\n      t.uniformMatrix2fv(this.addr, !1, n);\n    }\n    function kr(t, e) {\n      const n = mr(e, this.size, 9);\n      t.uniformMatrix3fv(this.addr, !1, n);\n    }\n    function Vr(t, e) {\n      const n = mr(e, this.size, 16);\n      t.uniformMatrix4fv(this.addr, !1, n);\n    }\n    function Wr(t, e) {\n      t.uniform1iv(this.addr, e);\n    }\n    function jr(t, e) {\n      t.uniform2iv(this.addr, e);\n    }\n    function qr(t, e) {\n      t.uniform3iv(this.addr, e);\n    }\n    function Xr(t, e) {\n      t.uniform4iv(this.addr, e);\n    }\n    function Yr(t, e) {\n      t.uniform1uiv(this.addr, e);\n    }\n    function Jr(t, e) {\n      t.uniform2uiv(this.addr, e);\n    }\n    function Zr(t, e) {\n      t.uniform3uiv(this.addr, e);\n    }\n    function Qr(t, e) {\n      t.uniform4uiv(this.addr, e);\n    }\n    function Kr(t, e, n) {\n      const i = e.length,\n        r = vr(n, i);\n      t.uniform1iv(this.addr, r);\n      for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || sr, r[t]);\n    }\n    function $r(t, e, n) {\n      const i = e.length,\n        r = vr(n, i);\n      t.uniform1iv(this.addr, r);\n      for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || lr, r[t]);\n    }\n    function ts(t, e, n) {\n      (this.id = t),\n        (this.addr = n),\n        (this.cache = []),\n        (this.setValue = (function (t) {\n          switch (t) {\n            case 5126:\n              return yr;\n            case 35664:\n              return xr;\n            case 35665:\n              return _r;\n            case 35666:\n              return Mr;\n            case 35674:\n              return br;\n            case 35675:\n              return wr;\n            case 35676:\n              return Sr;\n            case 5124:\n            case 35670:\n              return Tr;\n            case 35667:\n            case 35671:\n              return Er;\n            case 35668:\n            case 35672:\n              return Ar;\n            case 35669:\n            case 35673:\n              return Lr;\n            case 5125:\n              return Rr;\n            case 36294:\n              return Cr;\n            case 36295:\n              return Pr;\n            case 36296:\n              return Ir;\n            case 35678:\n            case 36198:\n            case 36298:\n            case 36306:\n            case 35682:\n              return Dr;\n            case 35679:\n            case 36299:\n            case 36307:\n              return Nr;\n            case 35680:\n            case 36300:\n            case 36308:\n            case 36293:\n              return zr;\n            case 36289:\n            case 36303:\n            case 36311:\n            case 36292:\n              return Br;\n          }\n        })(e.type));\n    }\n    function es(t, e, n) {\n      (this.id = t),\n        (this.addr = n),\n        (this.cache = []),\n        (this.size = e.size),\n        (this.setValue = (function (t) {\n          switch (t) {\n            case 5126:\n              return Fr;\n            case 35664:\n              return Or;\n            case 35665:\n              return Ur;\n            case 35666:\n              return Hr;\n            case 35674:\n              return Gr;\n            case 35675:\n              return kr;\n            case 35676:\n              return Vr;\n            case 5124:\n            case 35670:\n              return Wr;\n            case 35667:\n            case 35671:\n              return jr;\n            case 35668:\n            case 35672:\n              return qr;\n            case 35669:\n            case 35673:\n              return Xr;\n            case 5125:\n              return Yr;\n            case 36294:\n              return Jr;\n            case 36295:\n              return Zr;\n            case 36296:\n              return Qr;\n            case 35678:\n            case 36198:\n            case 36298:\n            case 36306:\n            case 35682:\n              return Kr;\n            case 35680:\n            case 36300:\n            case 36308:\n            case 36293:\n              return $r;\n          }\n        })(e.type));\n    }\n    function ns(t) {\n      (this.id = t), (this.seq = []), (this.map = {});\n    }\n    (es.prototype.updateCache = function (t) {\n      const e = this.cache;\n      t instanceof Float32Array &&\n        e.length !== t.length &&\n        (this.cache = new Float32Array(t.length)),\n        gr(e, t);\n    }),\n      (ns.prototype.setValue = function (t, e, n) {\n        const i = this.seq;\n        for (let r = 0, s = i.length; r !== s; ++r) {\n          const s = i[r];\n          s.setValue(t, e[s.id], n);\n        }\n      });\n    const is = /(\\w+)(\\])?(\\[|\\.)?/g;\n    function rs(t, e) {\n      t.seq.push(e), (t.map[e.id] = e);\n    }\n    function ss(t, e, n) {\n      const i = t.name,\n        r = i.length;\n      for (is.lastIndex = 0; ; ) {\n        const s = is.exec(i),\n          a = is.lastIndex;\n        let o = s[1];\n        const l = \"]\" === s[2],\n          c = s[3];\n        if ((l && (o |= 0), void 0 === c || (\"[\" === c && a + 2 === r))) {\n          rs(n, void 0 === c ? new ts(o, t, e) : new es(o, t, e));\n          break;\n        }\n        {\n          let t = n.map[o];\n          void 0 === t && ((t = new ns(o)), rs(n, t)), (n = t);\n        }\n      }\n    }\n    function as(t, e) {\n      (this.seq = []), (this.map = {});\n      const n = t.getProgramParameter(e, 35718);\n      for (let i = 0; i < n; ++i) {\n        const n = t.getActiveUniform(e, i);\n        ss(n, t.getUniformLocation(e, n.name), this);\n      }\n    }\n    function os(t, e, n) {\n      const i = t.createShader(e);\n      return t.shaderSource(i, n), t.compileShader(i), i;\n    }\n    (as.prototype.setValue = function (t, e, n, i) {\n      const r = this.map[e];\n      void 0 !== r && r.setValue(t, n, i);\n    }),\n      (as.prototype.setOptional = function (t, e, n) {\n        const i = e[n];\n        void 0 !== i && this.setValue(t, n, i);\n      }),\n      (as.upload = function (t, e, n, i) {\n        for (let r = 0, s = e.length; r !== s; ++r) {\n          const s = e[r],\n            a = n[s.id];\n          !1 !== a.needsUpdate && s.setValue(t, a.value, i);\n        }\n      }),\n      (as.seqWithValue = function (t, e) {\n        const n = [];\n        for (let i = 0, r = t.length; i !== r; ++i) {\n          const r = t[i];\n          r.id in e && n.push(r);\n        }\n        return n;\n      });\n    let ls = 0;\n    function cs(t) {\n      switch (t) {\n        case X:\n          return [\"Linear\", \"( value )\"];\n        case Y:\n          return [\"sRGB\", \"( value )\"];\n        case Z:\n          return [\"RGBE\", \"( value )\"];\n        case Q:\n          return [\"RGBM\", \"( value, 7.0 )\"];\n        case K:\n          return [\"RGBM\", \"( value, 16.0 )\"];\n        case $:\n          return [\"RGBD\", \"( value, 256.0 )\"];\n        case J:\n          return [\"Gamma\", \"( value, float( GAMMA_FACTOR ) )\"];\n        case 3003:\n          return [\"LogLuv\", \"( value )\"];\n        default:\n          return (\n            console.warn(\"THREE.WebGLProgram: Unsupported encoding:\", t),\n            [\"Linear\", \"( value )\"]\n          );\n      }\n    }\n    function hs(t, e, n) {\n      const i = t.getShaderParameter(e, 35713),\n        r = t.getShaderInfoLog(e).trim();\n      return i && \"\" === r\n        ? \"\"\n        : n.toUpperCase() +\n            \"\\n\\n\" +\n            r +\n            \"\\n\\n\" +\n            (function (t) {\n              const e = t.split(\"\\n\");\n              for (let t = 0; t < e.length; t++) e[t] = t + 1 + \": \" + e[t];\n              return e.join(\"\\n\");\n            })(t.getShaderSource(e));\n    }\n    function us(t, e) {\n      const n = cs(e);\n      return (\n        \"vec4 \" +\n        t +\n        \"( vec4 value ) { return \" +\n        n[0] +\n        \"ToLinear\" +\n        n[1] +\n        \"; }\"\n      );\n    }\n    function ds(t, e) {\n      const n = cs(e);\n      return (\n        \"vec4 \" + t + \"( vec4 value ) { return LinearTo\" + n[0] + n[1] + \"; }\"\n      );\n    }\n    function ps(t, e) {\n      let n;\n      switch (e) {\n        case 1:\n          n = \"Linear\";\n          break;\n        case 2:\n          n = \"Reinhard\";\n          break;\n        case 3:\n          n = \"OptimizedCineon\";\n          break;\n        case 4:\n          n = \"ACESFilmic\";\n          break;\n        case 5:\n          n = \"Custom\";\n          break;\n        default:\n          console.warn(\"THREE.WebGLProgram: Unsupported toneMapping:\", e),\n            (n = \"Linear\");\n      }\n      return (\n        \"vec3 \" + t + \"( vec3 color ) { return \" + n + \"ToneMapping( color ); }\"\n      );\n    }\n    function ms(t) {\n      return \"\" !== t;\n    }\n    function fs(t, e) {\n      return t\n        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)\n        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)\n        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)\n        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)\n        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)\n        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)\n        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)\n        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);\n    }\n    function gs(t, e) {\n      return t\n        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)\n        .replace(\n          /UNION_CLIPPING_PLANES/g,\n          e.numClippingPlanes - e.numClipIntersection\n        );\n    }\n    const vs = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function ys(t) {\n      return t.replace(vs, xs);\n    }\n    function xs(t, e) {\n      const n = pi[e];\n      if (void 0 === n) throw new Error(\"Can not resolve #include <\" + e + \">\");\n      return ys(n);\n    }\n    const _s =\n        /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g,\n      Ms =\n        /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n    function bs(t) {\n      return t.replace(Ms, Ss).replace(_s, ws);\n    }\n    function ws(t, e, n, i) {\n      return (\n        console.warn(\n          \"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.\"\n        ),\n        Ss(t, e, n, i)\n      );\n    }\n    function Ss(t, e, n, i) {\n      let r = \"\";\n      for (let t = parseInt(e); t < parseInt(n); t++)\n        r += i\n          .replace(/\\[\\s*i\\s*\\]/g, \"[ \" + t + \" ]\")\n          .replace(/UNROLLED_LOOP_INDEX/g, t);\n      return r;\n    }\n    function Ts(t) {\n      let e =\n        \"precision \" +\n        t.precision +\n        \" float;\\nprecision \" +\n        t.precision +\n        \" int;\";\n      return (\n        \"highp\" === t.precision\n          ? (e += \"\\n#define HIGH_PRECISION\")\n          : \"mediump\" === t.precision\n          ? (e += \"\\n#define MEDIUM_PRECISION\")\n          : \"lowp\" === t.precision && (e += \"\\n#define LOW_PRECISION\"),\n        e\n      );\n    }\n    function Es(t, e, n, i) {\n      const a = t.getContext(),\n        o = n.defines;\n      let h = n.vertexShader,\n        u = n.fragmentShader;\n      const d = (function (t) {\n          let e = \"SHADOWMAP_TYPE_BASIC\";\n          return (\n            1 === t.shadowMapType\n              ? (e = \"SHADOWMAP_TYPE_PCF\")\n              : 2 === t.shadowMapType\n              ? (e = \"SHADOWMAP_TYPE_PCF_SOFT\")\n              : 3 === t.shadowMapType && (e = \"SHADOWMAP_TYPE_VSM\"),\n            e\n          );\n        })(n),\n        p = (function (t) {\n          let e = \"ENVMAP_TYPE_CUBE\";\n          if (t.envMap)\n            switch (t.envMapMode) {\n              case r:\n              case s:\n                e = \"ENVMAP_TYPE_CUBE\";\n                break;\n              case l:\n              case c:\n                e = \"ENVMAP_TYPE_CUBE_UV\";\n            }\n          return e;\n        })(n),\n        m = (function (t) {\n          let e = \"ENVMAP_MODE_REFLECTION\";\n          if (t.envMap)\n            switch (t.envMapMode) {\n              case s:\n              case c:\n                e = \"ENVMAP_MODE_REFRACTION\";\n            }\n          return e;\n        })(n),\n        f = (function (t) {\n          let e = \"ENVMAP_BLENDING_NONE\";\n          if (t.envMap)\n            switch (t.combine) {\n              case 0:\n                e = \"ENVMAP_BLENDING_MULTIPLY\";\n                break;\n              case 1:\n                e = \"ENVMAP_BLENDING_MIX\";\n                break;\n              case 2:\n                e = \"ENVMAP_BLENDING_ADD\";\n            }\n          return e;\n        })(n),\n        g = t.gammaFactor > 0 ? t.gammaFactor : 1,\n        v = n.isWebGL2\n          ? \"\"\n          : (function (t) {\n              return [\n                t.extensionDerivatives ||\n                t.envMapCubeUV ||\n                t.bumpMap ||\n                t.tangentSpaceNormalMap ||\n                t.clearcoatNormalMap ||\n                t.flatShading ||\n                \"physical\" === t.shaderID\n                  ? \"#extension GL_OES_standard_derivatives : enable\"\n                  : \"\",\n                (t.extensionFragDepth || t.logarithmicDepthBuffer) &&\n                t.rendererExtensionFragDepth\n                  ? \"#extension GL_EXT_frag_depth : enable\"\n                  : \"\",\n                t.extensionDrawBuffers && t.rendererExtensionDrawBuffers\n                  ? \"#extension GL_EXT_draw_buffers : require\"\n                  : \"\",\n                (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&\n                t.rendererExtensionShaderTextureLod\n                  ? \"#extension GL_EXT_shader_texture_lod : enable\"\n                  : \"\",\n              ]\n                .filter(ms)\n                .join(\"\\n\");\n            })(n),\n        y = (function (t) {\n          const e = [];\n          for (const n in t) {\n            const i = t[n];\n            !1 !== i && e.push(\"#define \" + n + \" \" + i);\n          }\n          return e.join(\"\\n\");\n        })(o),\n        x = a.createProgram();\n      let _,\n        M,\n        b = n.glslVersion ? \"#version \" + n.glslVersion + \"\\n\" : \"\";\n      n.isRawShaderMaterial\n        ? ((_ = [y].filter(ms).join(\"\\n\")),\n          _.length > 0 && (_ += \"\\n\"),\n          (M = [v, y].filter(ms).join(\"\\n\")),\n          M.length > 0 && (M += \"\\n\"))\n        : ((_ = [\n            Ts(n),\n            \"#define SHADER_NAME \" + n.shaderName,\n            y,\n            n.instancing ? \"#define USE_INSTANCING\" : \"\",\n            n.instancingColor ? \"#define USE_INSTANCING_COLOR\" : \"\",\n            n.supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n            \"#define GAMMA_FACTOR \" + g,\n            \"#define MAX_BONES \" + n.maxBones,\n            n.useFog && n.fog ? \"#define USE_FOG\" : \"\",\n            n.useFog && n.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n            n.map ? \"#define USE_MAP\" : \"\",\n            n.envMap ? \"#define USE_ENVMAP\" : \"\",\n            n.envMap ? \"#define \" + m : \"\",\n            n.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n            n.aoMap ? \"#define USE_AOMAP\" : \"\",\n            n.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n            n.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n            n.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n            n.normalMap && n.objectSpaceNormalMap\n              ? \"#define OBJECTSPACE_NORMALMAP\"\n              : \"\",\n            n.normalMap && n.tangentSpaceNormalMap\n              ? \"#define TANGENTSPACE_NORMALMAP\"\n              : \"\",\n            n.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n            n.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n            n.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n            n.displacementMap && n.supportsVertexTextures\n              ? \"#define USE_DISPLACEMENTMAP\"\n              : \"\",\n            n.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n            n.specularIntensityMap ? \"#define USE_SPECULARINTENSITYMAP\" : \"\",\n            n.specularColorMap ? \"#define USE_SPECULARCOLORMAP\" : \"\",\n            n.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n            n.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n            n.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n            n.transmission ? \"#define USE_TRANSMISSION\" : \"\",\n            n.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n            n.thicknessMap ? \"#define USE_THICKNESSMAP\" : \"\",\n            n.sheenColorMap ? \"#define USE_SHEENCOLORMAP\" : \"\",\n            n.sheenRoughnessMap ? \"#define USE_SHEENROUGHNESSMAP\" : \"\",\n            n.vertexTangents ? \"#define USE_TANGENT\" : \"\",\n            n.vertexColors ? \"#define USE_COLOR\" : \"\",\n            n.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n            n.vertexUvs ? \"#define USE_UV\" : \"\",\n            n.uvsVertexOnly ? \"#define UVS_VERTEX_ONLY\" : \"\",\n            n.flatShading ? \"#define FLAT_SHADED\" : \"\",\n            n.skinning ? \"#define USE_SKINNING\" : \"\",\n            n.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n            n.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n            n.morphNormals && !1 === n.flatShading\n              ? \"#define USE_MORPHNORMALS\"\n              : \"\",\n            n.morphTargets && n.isWebGL2 ? \"#define MORPHTARGETS_TEXTURE\" : \"\",\n            n.morphTargets && n.isWebGL2\n              ? \"#define MORPHTARGETS_COUNT \" + n.morphTargetsCount\n              : \"\",\n            n.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n            n.flipSided ? \"#define FLIP_SIDED\" : \"\",\n            n.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n            n.shadowMapEnabled ? \"#define \" + d : \"\",\n            n.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n            n.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth\n              ? \"#define USE_LOGDEPTHBUF_EXT\"\n              : \"\",\n            \"uniform mat4 modelMatrix;\",\n            \"uniform mat4 modelViewMatrix;\",\n            \"uniform mat4 projectionMatrix;\",\n            \"uniform mat4 viewMatrix;\",\n            \"uniform mat3 normalMatrix;\",\n            \"uniform vec3 cameraPosition;\",\n            \"uniform bool isOrthographic;\",\n            \"#ifdef USE_INSTANCING\",\n            \"\\tattribute mat4 instanceMatrix;\",\n            \"#endif\",\n            \"#ifdef USE_INSTANCING_COLOR\",\n            \"\\tattribute vec3 instanceColor;\",\n            \"#endif\",\n            \"attribute vec3 position;\",\n            \"attribute vec3 normal;\",\n            \"attribute vec2 uv;\",\n            \"#ifdef USE_TANGENT\",\n            \"\\tattribute vec4 tangent;\",\n            \"#endif\",\n            \"#if defined( USE_COLOR_ALPHA )\",\n            \"\\tattribute vec4 color;\",\n            \"#elif defined( USE_COLOR )\",\n            \"\\tattribute vec3 color;\",\n            \"#endif\",\n            \"#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\",\n            \"\\tattribute vec3 morphTarget0;\",\n            \"\\tattribute vec3 morphTarget1;\",\n            \"\\tattribute vec3 morphTarget2;\",\n            \"\\tattribute vec3 morphTarget3;\",\n            \"\\t#ifdef USE_MORPHNORMALS\",\n            \"\\t\\tattribute vec3 morphNormal0;\",\n            \"\\t\\tattribute vec3 morphNormal1;\",\n            \"\\t\\tattribute vec3 morphNormal2;\",\n            \"\\t\\tattribute vec3 morphNormal3;\",\n            \"\\t#else\",\n            \"\\t\\tattribute vec3 morphTarget4;\",\n            \"\\t\\tattribute vec3 morphTarget5;\",\n            \"\\t\\tattribute vec3 morphTarget6;\",\n            \"\\t\\tattribute vec3 morphTarget7;\",\n            \"\\t#endif\",\n            \"#endif\",\n            \"#ifdef USE_SKINNING\",\n            \"\\tattribute vec4 skinIndex;\",\n            \"\\tattribute vec4 skinWeight;\",\n            \"#endif\",\n            \"\\n\",\n          ]\n            .filter(ms)\n            .join(\"\\n\")),\n          (M = [\n            v,\n            Ts(n),\n            \"#define SHADER_NAME \" + n.shaderName,\n            y,\n            \"#define GAMMA_FACTOR \" + g,\n            n.useFog && n.fog ? \"#define USE_FOG\" : \"\",\n            n.useFog && n.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n            n.map ? \"#define USE_MAP\" : \"\",\n            n.matcap ? \"#define USE_MATCAP\" : \"\",\n            n.envMap ? \"#define USE_ENVMAP\" : \"\",\n            n.envMap ? \"#define \" + p : \"\",\n            n.envMap ? \"#define \" + m : \"\",\n            n.envMap ? \"#define \" + f : \"\",\n            n.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n            n.aoMap ? \"#define USE_AOMAP\" : \"\",\n            n.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n            n.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n            n.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n            n.normalMap && n.objectSpaceNormalMap\n              ? \"#define OBJECTSPACE_NORMALMAP\"\n              : \"\",\n            n.normalMap && n.tangentSpaceNormalMap\n              ? \"#define TANGENTSPACE_NORMALMAP\"\n              : \"\",\n            n.clearcoat ? \"#define USE_CLEARCOAT\" : \"\",\n            n.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n            n.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n            n.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n            n.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n            n.specularIntensityMap ? \"#define USE_SPECULARINTENSITYMAP\" : \"\",\n            n.specularColorMap ? \"#define USE_SPECULARCOLORMAP\" : \"\",\n            n.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n            n.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n            n.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n            n.alphaTest ? \"#define USE_ALPHATEST\" : \"\",\n            n.sheen ? \"#define USE_SHEEN\" : \"\",\n            n.sheenColorMap ? \"#define USE_SHEENCOLORMAP\" : \"\",\n            n.sheenRoughnessMap ? \"#define USE_SHEENROUGHNESSMAP\" : \"\",\n            n.transmission ? \"#define USE_TRANSMISSION\" : \"\",\n            n.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n            n.thicknessMap ? \"#define USE_THICKNESSMAP\" : \"\",\n            n.vertexTangents ? \"#define USE_TANGENT\" : \"\",\n            n.vertexColors || n.instancingColor ? \"#define USE_COLOR\" : \"\",\n            n.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n            n.vertexUvs ? \"#define USE_UV\" : \"\",\n            n.uvsVertexOnly ? \"#define UVS_VERTEX_ONLY\" : \"\",\n            n.gradientMap ? \"#define USE_GRADIENTMAP\" : \"\",\n            n.flatShading ? \"#define FLAT_SHADED\" : \"\",\n            n.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n            n.flipSided ? \"#define FLIP_SIDED\" : \"\",\n            n.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n            n.shadowMapEnabled ? \"#define \" + d : \"\",\n            n.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : \"\",\n            n.physicallyCorrectLights\n              ? \"#define PHYSICALLY_CORRECT_LIGHTS\"\n              : \"\",\n            n.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth\n              ? \"#define USE_LOGDEPTHBUF_EXT\"\n              : \"\",\n            (n.extensionShaderTextureLOD || n.envMap) &&\n            n.rendererExtensionShaderTextureLod\n              ? \"#define TEXTURE_LOD_EXT\"\n              : \"\",\n            \"uniform mat4 viewMatrix;\",\n            \"uniform vec3 cameraPosition;\",\n            \"uniform bool isOrthographic;\",\n            0 !== n.toneMapping ? \"#define TONE_MAPPING\" : \"\",\n            0 !== n.toneMapping ? pi.tonemapping_pars_fragment : \"\",\n            0 !== n.toneMapping ? ps(\"toneMapping\", n.toneMapping) : \"\",\n            n.dithering ? \"#define DITHERING\" : \"\",\n            n.format === T ? \"#define OPAQUE\" : \"\",\n            pi.encodings_pars_fragment,\n            n.map ? us(\"mapTexelToLinear\", n.mapEncoding) : \"\",\n            n.matcap ? us(\"matcapTexelToLinear\", n.matcapEncoding) : \"\",\n            n.envMap ? us(\"envMapTexelToLinear\", n.envMapEncoding) : \"\",\n            n.emissiveMap\n              ? us(\"emissiveMapTexelToLinear\", n.emissiveMapEncoding)\n              : \"\",\n            n.specularColorMap\n              ? us(\"specularColorMapTexelToLinear\", n.specularColorMapEncoding)\n              : \"\",\n            n.sheenColorMap\n              ? us(\"sheenColorMapTexelToLinear\", n.sheenColorMapEncoding)\n              : \"\",\n            n.lightMap ? us(\"lightMapTexelToLinear\", n.lightMapEncoding) : \"\",\n            ds(\"linearToOutputTexel\", n.outputEncoding),\n            n.depthPacking ? \"#define DEPTH_PACKING \" + n.depthPacking : \"\",\n            \"\\n\",\n          ]\n            .filter(ms)\n            .join(\"\\n\"))),\n        (h = ys(h)),\n        (h = fs(h, n)),\n        (h = gs(h, n)),\n        (u = ys(u)),\n        (u = fs(u, n)),\n        (u = gs(u, n)),\n        (h = bs(h)),\n        (u = bs(u)),\n        n.isWebGL2 &&\n          !0 !== n.isRawShaderMaterial &&\n          ((b = \"#version 300 es\\n\"),\n          (_ =\n            [\n              \"precision mediump sampler2DArray;\",\n              \"#define attribute in\",\n              \"#define varying out\",\n              \"#define texture2D texture\",\n            ].join(\"\\n\") +\n            \"\\n\" +\n            _),\n          (M =\n            [\n              \"#define varying in\",\n              n.glslVersion === it ? \"\" : \"out highp vec4 pc_fragColor;\",\n              n.glslVersion === it ? \"\" : \"#define gl_FragColor pc_fragColor\",\n              \"#define gl_FragDepthEXT gl_FragDepth\",\n              \"#define texture2D texture\",\n              \"#define textureCube texture\",\n              \"#define texture2DProj textureProj\",\n              \"#define texture2DLodEXT textureLod\",\n              \"#define texture2DProjLodEXT textureProjLod\",\n              \"#define textureCubeLodEXT textureLod\",\n              \"#define texture2DGradEXT textureGrad\",\n              \"#define texture2DProjGradEXT textureProjGrad\",\n              \"#define textureCubeGradEXT textureGrad\",\n            ].join(\"\\n\") +\n            \"\\n\" +\n            M));\n      const w = b + M + u,\n        S = os(a, 35633, b + _ + h),\n        E = os(a, 35632, w);\n      if (\n        (a.attachShader(x, S),\n        a.attachShader(x, E),\n        void 0 !== n.index0AttributeName\n          ? a.bindAttribLocation(x, 0, n.index0AttributeName)\n          : !0 === n.morphTargets && a.bindAttribLocation(x, 0, \"position\"),\n        a.linkProgram(x),\n        t.debug.checkShaderErrors)\n      ) {\n        const t = a.getProgramInfoLog(x).trim(),\n          e = a.getShaderInfoLog(S).trim(),\n          n = a.getShaderInfoLog(E).trim();\n        let i = !0,\n          r = !0;\n        if (!1 === a.getProgramParameter(x, 35714)) {\n          i = !1;\n          const e = hs(a, S, \"vertex\"),\n            n = hs(a, E, \"fragment\");\n          console.error(\n            \"THREE.WebGLProgram: Shader Error \" +\n              a.getError() +\n              \" - VALIDATE_STATUS \" +\n              a.getProgramParameter(x, 35715) +\n              \"\\n\\nProgram Info Log: \" +\n              t +\n              \"\\n\" +\n              e +\n              \"\\n\" +\n              n\n          );\n        } else\n          \"\" !== t\n            ? console.warn(\"THREE.WebGLProgram: Program Info Log:\", t)\n            : (\"\" !== e && \"\" !== n) || (r = !1);\n        r &&\n          (this.diagnostics = {\n            runnable: i,\n            programLog: t,\n            vertexShader: { log: e, prefix: _ },\n            fragmentShader: { log: n, prefix: M },\n          });\n      }\n      let A, L;\n      return (\n        a.deleteShader(S),\n        a.deleteShader(E),\n        (this.getUniforms = function () {\n          return void 0 === A && (A = new as(a, x)), A;\n        }),\n        (this.getAttributes = function () {\n          return (\n            void 0 === L &&\n              (L = (function (t, e) {\n                const n = {},\n                  i = t.getProgramParameter(e, 35721);\n                for (let r = 0; r < i; r++) {\n                  const i = t.getActiveAttrib(e, r),\n                    s = i.name;\n                  let a = 1;\n                  35674 === i.type && (a = 2),\n                    35675 === i.type && (a = 3),\n                    35676 === i.type && (a = 4),\n                    (n[s] = {\n                      type: i.type,\n                      location: t.getAttribLocation(e, s),\n                      locationSize: a,\n                    });\n                }\n                return n;\n              })(a, x)),\n            L\n          );\n        }),\n        (this.destroy = function () {\n          i.releaseStatesOfProgram(this),\n            a.deleteProgram(x),\n            (this.program = void 0);\n        }),\n        (this.name = n.shaderName),\n        (this.id = ls++),\n        (this.cacheKey = e),\n        (this.usedTimes = 1),\n        (this.program = x),\n        (this.vertexShader = S),\n        (this.fragmentShader = E),\n        this\n      );\n    }\n    function As(t, e, n, i, r, s, a) {\n      const o = [],\n        h = r.isWebGL2,\n        u = r.logarithmicDepthBuffer,\n        d = r.floatVertexTextures,\n        p = r.maxVertexUniforms,\n        m = r.vertexTextures;\n      let f = r.precision;\n      const g = {\n          MeshDepthMaterial: \"depth\",\n          MeshDistanceMaterial: \"distanceRGBA\",\n          MeshNormalMaterial: \"normal\",\n          MeshBasicMaterial: \"basic\",\n          MeshLambertMaterial: \"lambert\",\n          MeshPhongMaterial: \"phong\",\n          MeshToonMaterial: \"toon\",\n          MeshStandardMaterial: \"physical\",\n          MeshPhysicalMaterial: \"physical\",\n          MeshMatcapMaterial: \"matcap\",\n          LineBasicMaterial: \"basic\",\n          LineDashedMaterial: \"dashed\",\n          PointsMaterial: \"points\",\n          ShadowMaterial: \"shadow\",\n          SpriteMaterial: \"sprite\",\n        },\n        v = [\n          \"precision\",\n          \"isWebGL2\",\n          \"supportsVertexTextures\",\n          \"outputEncoding\",\n          \"instancing\",\n          \"instancingColor\",\n          \"map\",\n          \"mapEncoding\",\n          \"matcap\",\n          \"matcapEncoding\",\n          \"envMap\",\n          \"envMapMode\",\n          \"envMapEncoding\",\n          \"envMapCubeUV\",\n          \"lightMap\",\n          \"lightMapEncoding\",\n          \"aoMap\",\n          \"emissiveMap\",\n          \"emissiveMapEncoding\",\n          \"bumpMap\",\n          \"normalMap\",\n          \"objectSpaceNormalMap\",\n          \"tangentSpaceNormalMap\",\n          \"clearcoat\",\n          \"clearcoatMap\",\n          \"clearcoatRoughnessMap\",\n          \"clearcoatNormalMap\",\n          \"displacementMap\",\n          \"specularMap\",\n          ,\n          \"roughnessMap\",\n          \"metalnessMap\",\n          \"gradientMap\",\n          \"alphaMap\",\n          \"alphaTest\",\n          \"combine\",\n          \"vertexColors\",\n          \"vertexAlphas\",\n          \"vertexTangents\",\n          \"vertexUvs\",\n          \"uvsVertexOnly\",\n          \"fog\",\n          \"useFog\",\n          \"fogExp2\",\n          \"flatShading\",\n          \"sizeAttenuation\",\n          \"logarithmicDepthBuffer\",\n          \"skinning\",\n          \"maxBones\",\n          \"useVertexTexture\",\n          \"morphTargets\",\n          \"morphNormals\",\n          \"morphTargetsCount\",\n          \"premultipliedAlpha\",\n          \"numDirLights\",\n          \"numPointLights\",\n          \"numSpotLights\",\n          \"numHemiLights\",\n          \"numRectAreaLights\",\n          \"numDirLightShadows\",\n          \"numPointLightShadows\",\n          \"numSpotLightShadows\",\n          \"shadowMapEnabled\",\n          \"shadowMapType\",\n          \"toneMapping\",\n          \"physicallyCorrectLights\",\n          \"doubleSided\",\n          \"flipSided\",\n          \"numClippingPlanes\",\n          \"numClipIntersection\",\n          \"depthPacking\",\n          \"dithering\",\n          \"format\",\n          \"specularIntensityMap\",\n          \"specularColorMap\",\n          \"specularColorMapEncoding\",\n          \"transmission\",\n          \"transmissionMap\",\n          \"thicknessMap\",\n          \"sheen\",\n          \"sheenColorMap\",\n          \"sheenColorMapEncoding\",\n          \"sheenRoughnessMap\",\n        ];\n      function y(t) {\n        let e;\n        return (\n          t && t.isTexture\n            ? (e = t.encoding)\n            : t && t.isWebGLRenderTarget\n            ? (console.warn(\n                \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\"\n              ),\n              (e = t.texture.encoding))\n            : (e = X),\n          h &&\n            t &&\n            t.isTexture &&\n            t.format === E &&\n            t.type === x &&\n            t.encoding === Y &&\n            (e = X),\n          e\n        );\n      }\n      return {\n        getParameters: function (s, o, v, x, _) {\n          const M = x.fog,\n            b = s.isMeshStandardMaterial ? x.environment : null,\n            w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b),\n            S = g[s.type],\n            T = _.isSkinnedMesh\n              ? (function (t) {\n                  const e = t.skeleton.bones;\n                  if (d) return 1024;\n                  {\n                    const t = p,\n                      n = Math.floor((t - 20) / 4),\n                      i = Math.min(n, e.length);\n                    return i < e.length\n                      ? (console.warn(\n                          \"THREE.WebGLRenderer: Skeleton has \" +\n                            e.length +\n                            \" bones. This GPU supports \" +\n                            i +\n                            \".\"\n                        ),\n                        0)\n                      : i;\n                  }\n                })(_)\n              : 0;\n          let E, A;\n          if (\n            (null !== s.precision &&\n              ((f = r.getMaxPrecision(s.precision)),\n              f !== s.precision &&\n                console.warn(\n                  \"THREE.WebGLProgram.getParameters:\",\n                  s.precision,\n                  \"not supported, using\",\n                  f,\n                  \"instead.\"\n                )),\n            S)\n          ) {\n            const t = fi[S];\n            (E = t.vertexShader), (A = t.fragmentShader);\n          } else (E = s.vertexShader), (A = s.fragmentShader);\n          const L = t.getRenderTarget(),\n            R = s.alphaTest > 0,\n            C = s.clearcoat > 0;\n          return {\n            isWebGL2: h,\n            shaderID: S,\n            shaderName: s.type,\n            vertexShader: E,\n            fragmentShader: A,\n            defines: s.defines,\n            isRawShaderMaterial: !0 === s.isRawShaderMaterial,\n            glslVersion: s.glslVersion,\n            precision: f,\n            instancing: !0 === _.isInstancedMesh,\n            instancingColor:\n              !0 === _.isInstancedMesh && null !== _.instanceColor,\n            supportsVertexTextures: m,\n            outputEncoding: null !== L ? y(L.texture) : t.outputEncoding,\n            map: !!s.map,\n            mapEncoding: y(s.map),\n            matcap: !!s.matcap,\n            matcapEncoding: y(s.matcap),\n            envMap: !!w,\n            envMapMode: w && w.mapping,\n            envMapEncoding: y(w),\n            envMapCubeUV: !!w && (w.mapping === l || w.mapping === c),\n            lightMap: !!s.lightMap,\n            lightMapEncoding: y(s.lightMap),\n            aoMap: !!s.aoMap,\n            emissiveMap: !!s.emissiveMap,\n            emissiveMapEncoding: y(s.emissiveMap),\n            bumpMap: !!s.bumpMap,\n            normalMap: !!s.normalMap,\n            objectSpaceNormalMap: 1 === s.normalMapType,\n            tangentSpaceNormalMap: 0 === s.normalMapType,\n            clearcoat: C,\n            clearcoatMap: C && !!s.clearcoatMap,\n            clearcoatRoughnessMap: C && !!s.clearcoatRoughnessMap,\n            clearcoatNormalMap: C && !!s.clearcoatNormalMap,\n            displacementMap: !!s.displacementMap,\n            roughnessMap: !!s.roughnessMap,\n            metalnessMap: !!s.metalnessMap,\n            specularMap: !!s.specularMap,\n            specularIntensityMap: !!s.specularIntensityMap,\n            specularColorMap: !!s.specularColorMap,\n            specularColorMapEncoding: y(s.specularColorMap),\n            alphaMap: !!s.alphaMap,\n            alphaTest: R,\n            gradientMap: !!s.gradientMap,\n            sheen: s.sheen > 0,\n            sheenColorMap: !!s.sheenColorMap,\n            sheenColorMapEncoding: y(s.sheenColorMap),\n            sheenRoughnessMap: !!s.sheenRoughnessMap,\n            transmission: s.transmission > 0,\n            transmissionMap: !!s.transmissionMap,\n            thicknessMap: !!s.thicknessMap,\n            combine: s.combine,\n            vertexTangents:\n              !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,\n            vertexColors: s.vertexColors,\n            vertexAlphas:\n              !0 === s.vertexColors &&\n              !!_.geometry &&\n              !!_.geometry.attributes.color &&\n              4 === _.geometry.attributes.color.itemSize,\n            vertexUvs:\n              !!s.map ||\n              !!s.bumpMap ||\n              !!s.normalMap ||\n              !!s.specularMap ||\n              !!s.alphaMap ||\n              !!s.emissiveMap ||\n              !!s.roughnessMap ||\n              !!s.metalnessMap ||\n              !!s.clearcoatMap ||\n              !!s.clearcoatRoughnessMap ||\n              !!s.clearcoatNormalMap ||\n              !!s.displacementMap ||\n              !!s.transmissionMap ||\n              !!s.thicknessMap ||\n              !!s.specularIntensityMap ||\n              !!s.specularColorMap ||\n              !!s.sheenColorMap ||\n              s.sheenRoughnessMap,\n            uvsVertexOnly: !(\n              s.map ||\n              s.bumpMap ||\n              s.normalMap ||\n              s.specularMap ||\n              s.alphaMap ||\n              s.emissiveMap ||\n              s.roughnessMap ||\n              s.metalnessMap ||\n              s.clearcoatNormalMap ||\n              s.transmission > 0 ||\n              s.transmissionMap ||\n              s.thicknessMap ||\n              s.specularIntensityMap ||\n              s.specularColorMap ||\n              !!s.sheen > 0 ||\n              s.sheenColorMap ||\n              s.sheenRoughnessMap ||\n              !s.displacementMap\n            ),\n            fog: !!M,\n            useFog: s.fog,\n            fogExp2: M && M.isFogExp2,\n            flatShading: !!s.flatShading,\n            sizeAttenuation: s.sizeAttenuation,\n            logarithmicDepthBuffer: u,\n            skinning: !0 === _.isSkinnedMesh && T > 0,\n            maxBones: T,\n            useVertexTexture: d,\n            morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,\n            morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,\n            morphTargetsCount:\n              _.geometry && _.geometry.morphAttributes.position\n                ? _.geometry.morphAttributes.position.length\n                : 0,\n            numDirLights: o.directional.length,\n            numPointLights: o.point.length,\n            numSpotLights: o.spot.length,\n            numRectAreaLights: o.rectArea.length,\n            numHemiLights: o.hemi.length,\n            numDirLightShadows: o.directionalShadowMap.length,\n            numPointLightShadows: o.pointShadowMap.length,\n            numSpotLightShadows: o.spotShadowMap.length,\n            numClippingPlanes: a.numPlanes,\n            numClipIntersection: a.numIntersection,\n            format: s.format,\n            dithering: s.dithering,\n            shadowMapEnabled: t.shadowMap.enabled && v.length > 0,\n            shadowMapType: t.shadowMap.type,\n            toneMapping: s.toneMapped ? t.toneMapping : 0,\n            physicallyCorrectLights: t.physicallyCorrectLights,\n            premultipliedAlpha: s.premultipliedAlpha,\n            doubleSided: 2 === s.side,\n            flipSided: 1 === s.side,\n            depthPacking: void 0 !== s.depthPacking && s.depthPacking,\n            index0AttributeName: s.index0AttributeName,\n            extensionDerivatives: s.extensions && s.extensions.derivatives,\n            extensionFragDepth: s.extensions && s.extensions.fragDepth,\n            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,\n            extensionShaderTextureLOD:\n              s.extensions && s.extensions.shaderTextureLOD,\n            rendererExtensionFragDepth: h || i.has(\"EXT_frag_depth\"),\n            rendererExtensionDrawBuffers: h || i.has(\"WEBGL_draw_buffers\"),\n            rendererExtensionShaderTextureLod:\n              h || i.has(\"EXT_shader_texture_lod\"),\n            customProgramCacheKey: s.customProgramCacheKey(),\n          };\n        },\n        getProgramCacheKey: function (e) {\n          const n = [];\n          if (\n            (e.shaderID\n              ? n.push(e.shaderID)\n              : (n.push(St(e.fragmentShader)), n.push(St(e.vertexShader))),\n            void 0 !== e.defines)\n          )\n            for (const t in e.defines) n.push(t), n.push(e.defines[t]);\n          if (!1 === e.isRawShaderMaterial) {\n            for (let t = 0; t < v.length; t++) n.push(e[v[t]]);\n            n.push(t.outputEncoding), n.push(t.gammaFactor);\n          }\n          return n.push(e.customProgramCacheKey), n.join();\n        },\n        getUniforms: function (t) {\n          const e = g[t.type];\n          let n;\n          if (e) {\n            const t = fi[e];\n            n = Jn.clone(t.uniforms);\n          } else n = t.uniforms;\n          return n;\n        },\n        acquireProgram: function (e, n) {\n          let i;\n          for (let t = 0, e = o.length; t < e; t++) {\n            const e = o[t];\n            if (e.cacheKey === n) {\n              (i = e), ++i.usedTimes;\n              break;\n            }\n          }\n          return void 0 === i && ((i = new Es(t, n, e, s)), o.push(i)), i;\n        },\n        releaseProgram: function (t) {\n          if (0 == --t.usedTimes) {\n            const e = o.indexOf(t);\n            (o[e] = o[o.length - 1]), o.pop(), t.destroy();\n          }\n        },\n        programs: o,\n      };\n    }\n    function Ls() {\n      let t = new WeakMap();\n      return {\n        get: function (e) {\n          let n = t.get(e);\n          return void 0 === n && ((n = {}), t.set(e, n)), n;\n        },\n        remove: function (e) {\n          t.delete(e);\n        },\n        update: function (e, n, i) {\n          t.get(e)[n] = i;\n        },\n        dispose: function () {\n          t = new WeakMap();\n        },\n      };\n    }\n    function Rs(t, e) {\n      return t.groupOrder !== e.groupOrder\n        ? t.groupOrder - e.groupOrder\n        : t.renderOrder !== e.renderOrder\n        ? t.renderOrder - e.renderOrder\n        : t.program !== e.program\n        ? t.program.id - e.program.id\n        : t.material.id !== e.material.id\n        ? t.material.id - e.material.id\n        : t.z !== e.z\n        ? t.z - e.z\n        : t.id - e.id;\n    }\n    function Cs(t, e) {\n      return t.groupOrder !== e.groupOrder\n        ? t.groupOrder - e.groupOrder\n        : t.renderOrder !== e.renderOrder\n        ? t.renderOrder - e.renderOrder\n        : t.z !== e.z\n        ? e.z - t.z\n        : t.id - e.id;\n    }\n    function Ps(t) {\n      const e = [];\n      let n = 0;\n      const i = [],\n        r = [],\n        s = [],\n        a = { id: -1 };\n      function o(i, r, s, o, l, c) {\n        let h = e[n];\n        const u = t.get(s);\n        return (\n          void 0 === h\n            ? ((h = {\n                id: i.id,\n                object: i,\n                geometry: r,\n                material: s,\n                program: u.program || a,\n                groupOrder: o,\n                renderOrder: i.renderOrder,\n                z: l,\n                group: c,\n              }),\n              (e[n] = h))\n            : ((h.id = i.id),\n              (h.object = i),\n              (h.geometry = r),\n              (h.material = s),\n              (h.program = u.program || a),\n              (h.groupOrder = o),\n              (h.renderOrder = i.renderOrder),\n              (h.z = l),\n              (h.group = c)),\n          n++,\n          h\n        );\n      }\n      return {\n        opaque: i,\n        transmissive: r,\n        transparent: s,\n        init: function () {\n          (n = 0), (i.length = 0), (r.length = 0), (s.length = 0);\n        },\n        push: function (t, e, n, a, l, c) {\n          const h = o(t, e, n, a, l, c);\n          n.transmission > 0\n            ? r.push(h)\n            : !0 === n.transparent\n            ? s.push(h)\n            : i.push(h);\n        },\n        unshift: function (t, e, n, a, l, c) {\n          const h = o(t, e, n, a, l, c);\n          n.transmission > 0\n            ? r.unshift(h)\n            : !0 === n.transparent\n            ? s.unshift(h)\n            : i.unshift(h);\n        },\n        finish: function () {\n          for (let t = n, i = e.length; t < i; t++) {\n            const n = e[t];\n            if (null === n.id) break;\n            (n.id = null),\n              (n.object = null),\n              (n.geometry = null),\n              (n.material = null),\n              (n.program = null),\n              (n.group = null);\n          }\n        },\n        sort: function (t, e) {\n          i.length > 1 && i.sort(t || Rs),\n            r.length > 1 && r.sort(e || Cs),\n            s.length > 1 && s.sort(e || Cs);\n        },\n      };\n    }\n    function Is(t) {\n      let e = new WeakMap();\n      return {\n        get: function (n, i) {\n          let r;\n          return (\n            !1 === e.has(n)\n              ? ((r = new Ps(t)), e.set(n, [r]))\n              : i >= e.get(n).length\n              ? ((r = new Ps(t)), e.get(n).push(r))\n              : (r = e.get(n)[i]),\n            r\n          );\n        },\n        dispose: function () {\n          e = new WeakMap();\n        },\n      };\n    }\n    function Ds() {\n      const t = {};\n      return {\n        get: function (e) {\n          if (void 0 !== t[e.id]) return t[e.id];\n          let n;\n          switch (e.type) {\n            case \"DirectionalLight\":\n              n = { direction: new zt(), color: new rn() };\n              break;\n            case \"SpotLight\":\n              n = {\n                position: new zt(),\n                direction: new zt(),\n                color: new rn(),\n                distance: 0,\n                coneCos: 0,\n                penumbraCos: 0,\n                decay: 0,\n              };\n              break;\n            case \"PointLight\":\n              n = {\n                position: new zt(),\n                color: new rn(),\n                distance: 0,\n                decay: 0,\n              };\n              break;\n            case \"HemisphereLight\":\n              n = {\n                direction: new zt(),\n                skyColor: new rn(),\n                groundColor: new rn(),\n              };\n              break;\n            case \"RectAreaLight\":\n              n = {\n                color: new rn(),\n                position: new zt(),\n                halfWidth: new zt(),\n                halfHeight: new zt(),\n              };\n          }\n          return (t[e.id] = n), n;\n        },\n      };\n    }\n    let Ns = 0;\n    function zs(t, e) {\n      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);\n    }\n    function Bs(t, e) {\n      const n = new Ds(),\n        i = (function () {\n          const t = {};\n          return {\n            get: function (e) {\n              if (void 0 !== t[e.id]) return t[e.id];\n              let n;\n              switch (e.type) {\n                case \"DirectionalLight\":\n                case \"SpotLight\":\n                  n = {\n                    shadowBias: 0,\n                    shadowNormalBias: 0,\n                    shadowRadius: 1,\n                    shadowMapSize: new yt(),\n                  };\n                  break;\n                case \"PointLight\":\n                  n = {\n                    shadowBias: 0,\n                    shadowNormalBias: 0,\n                    shadowRadius: 1,\n                    shadowMapSize: new yt(),\n                    shadowCameraNear: 1,\n                    shadowCameraFar: 1e3,\n                  };\n              }\n              return (t[e.id] = n), n;\n            },\n          };\n        })(),\n        r = {\n          version: 0,\n          hash: {\n            directionalLength: -1,\n            pointLength: -1,\n            spotLength: -1,\n            rectAreaLength: -1,\n            hemiLength: -1,\n            numDirectionalShadows: -1,\n            numPointShadows: -1,\n            numSpotShadows: -1,\n          },\n          ambient: [0, 0, 0],\n          probe: [],\n          directional: [],\n          directionalShadow: [],\n          directionalShadowMap: [],\n          directionalShadowMatrix: [],\n          spot: [],\n          spotShadow: [],\n          spotShadowMap: [],\n          spotShadowMatrix: [],\n          rectArea: [],\n          rectAreaLTC1: null,\n          rectAreaLTC2: null,\n          point: [],\n          pointShadow: [],\n          pointShadowMap: [],\n          pointShadowMatrix: [],\n          hemi: [],\n        };\n      for (let t = 0; t < 9; t++) r.probe.push(new zt());\n      const s = new zt(),\n        a = new de(),\n        o = new de();\n      return {\n        setup: function (s, a) {\n          let o = 0,\n            l = 0,\n            c = 0;\n          for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);\n          let h = 0,\n            u = 0,\n            d = 0,\n            p = 0,\n            m = 0,\n            f = 0,\n            g = 0,\n            v = 0;\n          s.sort(zs);\n          const y = !0 !== a ? Math.PI : 1;\n          for (let t = 0, e = s.length; t < e; t++) {\n            const e = s[t],\n              a = e.color,\n              x = e.intensity,\n              _ = e.distance,\n              M = e.shadow && e.shadow.map ? e.shadow.map.texture : null;\n            if (e.isAmbientLight)\n              (o += a.r * x * y), (l += a.g * x * y), (c += a.b * x * y);\n            else if (e.isLightProbe)\n              for (let t = 0; t < 9; t++)\n                r.probe[t].addScaledVector(e.sh.coefficients[t], x);\n            else if (e.isDirectionalLight) {\n              const t = n.get(e);\n              if (\n                (t.color.copy(e.color).multiplyScalar(e.intensity * y),\n                e.castShadow)\n              ) {\n                const t = e.shadow,\n                  n = i.get(e);\n                (n.shadowBias = t.bias),\n                  (n.shadowNormalBias = t.normalBias),\n                  (n.shadowRadius = t.radius),\n                  (n.shadowMapSize = t.mapSize),\n                  (r.directionalShadow[h] = n),\n                  (r.directionalShadowMap[h] = M),\n                  (r.directionalShadowMatrix[h] = e.shadow.matrix),\n                  f++;\n              }\n              (r.directional[h] = t), h++;\n            } else if (e.isSpotLight) {\n              const t = n.get(e);\n              if (\n                (t.position.setFromMatrixPosition(e.matrixWorld),\n                t.color.copy(a).multiplyScalar(x * y),\n                (t.distance = _),\n                (t.coneCos = Math.cos(e.angle)),\n                (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),\n                (t.decay = e.decay),\n                e.castShadow)\n              ) {\n                const t = e.shadow,\n                  n = i.get(e);\n                (n.shadowBias = t.bias),\n                  (n.shadowNormalBias = t.normalBias),\n                  (n.shadowRadius = t.radius),\n                  (n.shadowMapSize = t.mapSize),\n                  (r.spotShadow[d] = n),\n                  (r.spotShadowMap[d] = M),\n                  (r.spotShadowMatrix[d] = e.shadow.matrix),\n                  v++;\n              }\n              (r.spot[d] = t), d++;\n            } else if (e.isRectAreaLight) {\n              const t = n.get(e);\n              t.color.copy(a).multiplyScalar(x),\n                t.halfWidth.set(0.5 * e.width, 0, 0),\n                t.halfHeight.set(0, 0.5 * e.height, 0),\n                (r.rectArea[p] = t),\n                p++;\n            } else if (e.isPointLight) {\n              const t = n.get(e);\n              if (\n                (t.color.copy(e.color).multiplyScalar(e.intensity * y),\n                (t.distance = e.distance),\n                (t.decay = e.decay),\n                e.castShadow)\n              ) {\n                const t = e.shadow,\n                  n = i.get(e);\n                (n.shadowBias = t.bias),\n                  (n.shadowNormalBias = t.normalBias),\n                  (n.shadowRadius = t.radius),\n                  (n.shadowMapSize = t.mapSize),\n                  (n.shadowCameraNear = t.camera.near),\n                  (n.shadowCameraFar = t.camera.far),\n                  (r.pointShadow[u] = n),\n                  (r.pointShadowMap[u] = M),\n                  (r.pointShadowMatrix[u] = e.shadow.matrix),\n                  g++;\n              }\n              (r.point[u] = t), u++;\n            } else if (e.isHemisphereLight) {\n              const t = n.get(e);\n              t.skyColor.copy(e.color).multiplyScalar(x * y),\n                t.groundColor.copy(e.groundColor).multiplyScalar(x * y),\n                (r.hemi[m] = t),\n                m++;\n            }\n          }\n          p > 0 &&\n            (e.isWebGL2 || !0 === t.has(\"OES_texture_float_linear\")\n              ? ((r.rectAreaLTC1 = mi.LTC_FLOAT_1),\n                (r.rectAreaLTC2 = mi.LTC_FLOAT_2))\n              : !0 === t.has(\"OES_texture_half_float_linear\")\n              ? ((r.rectAreaLTC1 = mi.LTC_HALF_1),\n                (r.rectAreaLTC2 = mi.LTC_HALF_2))\n              : console.error(\n                  \"THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.\"\n                )),\n            (r.ambient[0] = o),\n            (r.ambient[1] = l),\n            (r.ambient[2] = c);\n          const x = r.hash;\n          (x.directionalLength === h &&\n            x.pointLength === u &&\n            x.spotLength === d &&\n            x.rectAreaLength === p &&\n            x.hemiLength === m &&\n            x.numDirectionalShadows === f &&\n            x.numPointShadows === g &&\n            x.numSpotShadows === v) ||\n            ((r.directional.length = h),\n            (r.spot.length = d),\n            (r.rectArea.length = p),\n            (r.point.length = u),\n            (r.hemi.length = m),\n            (r.directionalShadow.length = f),\n            (r.directionalShadowMap.length = f),\n            (r.pointShadow.length = g),\n            (r.pointShadowMap.length = g),\n            (r.spotShadow.length = v),\n            (r.spotShadowMap.length = v),\n            (r.directionalShadowMatrix.length = f),\n            (r.pointShadowMatrix.length = g),\n            (r.spotShadowMatrix.length = v),\n            (x.directionalLength = h),\n            (x.pointLength = u),\n            (x.spotLength = d),\n            (x.rectAreaLength = p),\n            (x.hemiLength = m),\n            (x.numDirectionalShadows = f),\n            (x.numPointShadows = g),\n            (x.numSpotShadows = v),\n            (r.version = Ns++));\n        },\n        setupView: function (t, e) {\n          let n = 0,\n            i = 0,\n            l = 0,\n            c = 0,\n            h = 0;\n          const u = e.matrixWorldInverse;\n          for (let e = 0, d = t.length; e < d; e++) {\n            const d = t[e];\n            if (d.isDirectionalLight) {\n              const t = r.directional[n];\n              t.direction.setFromMatrixPosition(d.matrixWorld),\n                s.setFromMatrixPosition(d.target.matrixWorld),\n                t.direction.sub(s),\n                t.direction.transformDirection(u),\n                n++;\n            } else if (d.isSpotLight) {\n              const t = r.spot[l];\n              t.position.setFromMatrixPosition(d.matrixWorld),\n                t.position.applyMatrix4(u),\n                t.direction.setFromMatrixPosition(d.matrixWorld),\n                s.setFromMatrixPosition(d.target.matrixWorld),\n                t.direction.sub(s),\n                t.direction.transformDirection(u),\n                l++;\n            } else if (d.isRectAreaLight) {\n              const t = r.rectArea[c];\n              t.position.setFromMatrixPosition(d.matrixWorld),\n                t.position.applyMatrix4(u),\n                o.identity(),\n                a.copy(d.matrixWorld),\n                a.premultiply(u),\n                o.extractRotation(a),\n                t.halfWidth.set(0.5 * d.width, 0, 0),\n                t.halfHeight.set(0, 0.5 * d.height, 0),\n                t.halfWidth.applyMatrix4(o),\n                t.halfHeight.applyMatrix4(o),\n                c++;\n            } else if (d.isPointLight) {\n              const t = r.point[i];\n              t.position.setFromMatrixPosition(d.matrixWorld),\n                t.position.applyMatrix4(u),\n                i++;\n            } else if (d.isHemisphereLight) {\n              const t = r.hemi[h];\n              t.direction.setFromMatrixPosition(d.matrixWorld),\n                t.direction.transformDirection(u),\n                t.direction.normalize(),\n                h++;\n            }\n          }\n        },\n        state: r,\n      };\n    }\n    function Fs(t, e) {\n      const n = new Bs(t, e),\n        i = [],\n        r = [];\n      return {\n        init: function () {\n          (i.length = 0), (r.length = 0);\n        },\n        state: { lightsArray: i, shadowsArray: r, lights: n },\n        setupLights: function (t) {\n          n.setup(i, t);\n        },\n        setupLightsView: function (t) {\n          n.setupView(i, t);\n        },\n        pushLight: function (t) {\n          i.push(t);\n        },\n        pushShadow: function (t) {\n          r.push(t);\n        },\n      };\n    }\n    function Os(t, e) {\n      let n = new WeakMap();\n      return {\n        get: function (i, r = 0) {\n          let s;\n          return (\n            !1 === n.has(i)\n              ? ((s = new Fs(t, e)), n.set(i, [s]))\n              : r >= n.get(i).length\n              ? ((s = new Fs(t, e)), n.get(i).push(s))\n              : (s = n.get(i)[r]),\n            s\n          );\n        },\n        dispose: function () {\n          n = new WeakMap();\n        },\n      };\n    }\n    class Us extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshDepthMaterial\"),\n          (this.depthPacking = 3200),\n          (this.map = null),\n          (this.alphaMap = null),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.fog = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.depthPacking = t.depthPacking),\n          (this.map = t.map),\n          (this.alphaMap = t.alphaMap),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          this\n        );\n      }\n    }\n    Us.prototype.isMeshDepthMaterial = !0;\n    class Hs extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshDistanceMaterial\"),\n          (this.referencePosition = new zt()),\n          (this.nearDistance = 1),\n          (this.farDistance = 1e3),\n          (this.map = null),\n          (this.alphaMap = null),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.fog = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.referencePosition.copy(t.referencePosition),\n          (this.nearDistance = t.nearDistance),\n          (this.farDistance = t.farDistance),\n          (this.map = t.map),\n          (this.alphaMap = t.alphaMap),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          this\n        );\n      }\n    }\n    Hs.prototype.isMeshDistanceMaterial = !0;\n    function Gs(t, e, n) {\n      let i = new ci();\n      const r = new yt(),\n        s = new yt(),\n        a = new Ct(),\n        o = new Us({ depthPacking: 3201 }),\n        l = new Hs(),\n        c = {},\n        h = n.maxTextureSize,\n        u = { 0: 1, 1: 0, 2: 2 },\n        d = new Zn({\n          defines: { VSM_SAMPLES: 8 },\n          uniforms: {\n            shadow_pass: { value: null },\n            resolution: { value: new yt() },\n            radius: { value: 4 },\n          },\n          vertexShader:\n            \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\",\n          fragmentShader:\n            \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\",\n        }),\n        m = d.clone();\n      m.defines.HORIZONTAL_PASS = 1;\n      const f = new En();\n      f.setAttribute(\n        \"position\",\n        new ln(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)\n      );\n      const v = new Wn(f, d),\n        y = this;\n      function x(n, i) {\n        const r = e.update(v);\n        d.defines.VSM_SAMPLES !== n.blurSamples &&\n          ((d.defines.VSM_SAMPLES = n.blurSamples),\n          (m.defines.VSM_SAMPLES = n.blurSamples),\n          (d.needsUpdate = !0),\n          (m.needsUpdate = !0)),\n          (d.uniforms.shadow_pass.value = n.map.texture),\n          (d.uniforms.resolution.value = n.mapSize),\n          (d.uniforms.radius.value = n.radius),\n          t.setRenderTarget(n.mapPass),\n          t.clear(),\n          t.renderBufferDirect(i, null, r, d, v, null),\n          (m.uniforms.shadow_pass.value = n.mapPass.texture),\n          (m.uniforms.resolution.value = n.mapSize),\n          (m.uniforms.radius.value = n.radius),\n          t.setRenderTarget(n.map),\n          t.clear(),\n          t.renderBufferDirect(i, null, r, m, v, null);\n      }\n      function _(e, n, i, r, s, a, h) {\n        let d = null;\n        const p =\n          !0 === r.isPointLight\n            ? e.customDistanceMaterial\n            : e.customDepthMaterial;\n        if (\n          ((d = void 0 !== p ? p : !0 === r.isPointLight ? l : o),\n          (t.localClippingEnabled &&\n            !0 === i.clipShadows &&\n            0 !== i.clippingPlanes.length) ||\n            (i.displacementMap && 0 !== i.displacementScale) ||\n            (i.alphaMap && i.alphaTest > 0))\n        ) {\n          const t = d.uuid,\n            e = i.uuid;\n          let n = c[t];\n          void 0 === n && ((n = {}), (c[t] = n));\n          let r = n[e];\n          void 0 === r && ((r = d.clone()), (n[e] = r)), (d = r);\n        }\n        return (\n          (d.visible = i.visible),\n          (d.wireframe = i.wireframe),\n          (d.side =\n            3 === h\n              ? null !== i.shadowSide\n                ? i.shadowSide\n                : i.side\n              : null !== i.shadowSide\n              ? i.shadowSide\n              : u[i.side]),\n          (d.alphaMap = i.alphaMap),\n          (d.alphaTest = i.alphaTest),\n          (d.clipShadows = i.clipShadows),\n          (d.clippingPlanes = i.clippingPlanes),\n          (d.clipIntersection = i.clipIntersection),\n          (d.displacementMap = i.displacementMap),\n          (d.displacementScale = i.displacementScale),\n          (d.displacementBias = i.displacementBias),\n          (d.wireframeLinewidth = i.wireframeLinewidth),\n          (d.linewidth = i.linewidth),\n          !0 === r.isPointLight &&\n            !0 === d.isMeshDistanceMaterial &&\n            (d.referencePosition.setFromMatrixPosition(r.matrixWorld),\n            (d.nearDistance = s),\n            (d.farDistance = a)),\n          d\n        );\n      }\n      function M(n, r, s, a, o) {\n        if (!1 === n.visible) return;\n        if (\n          n.layers.test(r.layers) &&\n          (n.isMesh || n.isLine || n.isPoints) &&\n          (n.castShadow || (n.receiveShadow && 3 === o)) &&\n          (!n.frustumCulled || i.intersectsObject(n))\n        ) {\n          n.modelViewMatrix.multiplyMatrices(\n            s.matrixWorldInverse,\n            n.matrixWorld\n          );\n          const i = e.update(n),\n            r = n.material;\n          if (Array.isArray(r)) {\n            const e = i.groups;\n            for (let l = 0, c = e.length; l < c; l++) {\n              const c = e[l],\n                h = r[c.materialIndex];\n              if (h && h.visible) {\n                const e = _(n, 0, h, a, s.near, s.far, o);\n                t.renderBufferDirect(s, null, i, e, n, c);\n              }\n            }\n          } else if (r.visible) {\n            const e = _(n, 0, r, a, s.near, s.far, o);\n            t.renderBufferDirect(s, null, i, e, n, null);\n          }\n        }\n        const l = n.children;\n        for (let t = 0, e = l.length; t < e; t++) M(l[t], r, s, a, o);\n      }\n      (this.enabled = !1),\n        (this.autoUpdate = !0),\n        (this.needsUpdate = !1),\n        (this.type = 1),\n        (this.render = function (e, n, o) {\n          if (!1 === y.enabled) return;\n          if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;\n          if (0 === e.length) return;\n          const l = t.getRenderTarget(),\n            c = t.getActiveCubeFace(),\n            u = t.getActiveMipmapLevel(),\n            d = t.state;\n          d.setBlending(0),\n            d.buffers.color.setClear(1, 1, 1, 1),\n            d.buffers.depth.setTest(!0),\n            d.setScissorTest(!1);\n          for (let l = 0, c = e.length; l < c; l++) {\n            const c = e[l],\n              u = c.shadow;\n            if (void 0 === u) {\n              console.warn(\"THREE.WebGLShadowMap:\", c, \"has no shadow.\");\n              continue;\n            }\n            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;\n            r.copy(u.mapSize);\n            const m = u.getFrameExtents();\n            if (\n              (r.multiply(m),\n              s.copy(u.mapSize),\n              (r.x > h || r.y > h) &&\n                (r.x > h &&\n                  ((s.x = Math.floor(h / m.x)),\n                  (r.x = s.x * m.x),\n                  (u.mapSize.x = s.x)),\n                r.y > h &&\n                  ((s.y = Math.floor(h / m.y)),\n                  (r.y = s.y * m.y),\n                  (u.mapSize.y = s.y))),\n              null === u.map && !u.isPointLightShadow && 3 === this.type)\n            ) {\n              const t = { minFilter: g, magFilter: g, format: E };\n              (u.map = new Pt(r.x, r.y, t)),\n                (u.map.texture.name = c.name + \".shadowMap\"),\n                (u.mapPass = new Pt(r.x, r.y, t)),\n                u.camera.updateProjectionMatrix();\n            }\n            if (null === u.map) {\n              const t = { minFilter: p, magFilter: p, format: E };\n              (u.map = new Pt(r.x, r.y, t)),\n                (u.map.texture.name = c.name + \".shadowMap\"),\n                u.camera.updateProjectionMatrix();\n            }\n            t.setRenderTarget(u.map), t.clear();\n            const f = u.getViewportCount();\n            for (let t = 0; t < f; t++) {\n              const e = u.getViewport(t);\n              a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),\n                d.viewport(a),\n                u.updateMatrices(c, t),\n                (i = u.getFrustum()),\n                M(n, o, u.camera, c, this.type);\n            }\n            u.isPointLightShadow || 3 !== this.type || x(u, o),\n              (u.needsUpdate = !1);\n          }\n          (y.needsUpdate = !1), t.setRenderTarget(l, c, u);\n        });\n    }\n    function ks(t, e, i) {\n      const r = i.isWebGL2;\n      const s = new (function () {\n          let e = !1;\n          const n = new Ct();\n          let i = null;\n          const r = new Ct(0, 0, 0, 0);\n          return {\n            setMask: function (n) {\n              i === n || e || (t.colorMask(n, n, n, n), (i = n));\n            },\n            setLocked: function (t) {\n              e = t;\n            },\n            setClear: function (e, i, s, a, o) {\n              !0 === o && ((e *= a), (i *= a), (s *= a)),\n                n.set(e, i, s, a),\n                !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));\n            },\n            reset: function () {\n              (e = !1), (i = null), r.set(-1, 0, 0, 0);\n            },\n          };\n        })(),\n        a = new (function () {\n          let e = !1,\n            n = null,\n            i = null,\n            r = null;\n          return {\n            setTest: function (t) {\n              t ? O(2929) : U(2929);\n            },\n            setMask: function (i) {\n              n === i || e || (t.depthMask(i), (n = i));\n            },\n            setFunc: function (e) {\n              if (i !== e) {\n                if (e)\n                  switch (e) {\n                    case 0:\n                      t.depthFunc(512);\n                      break;\n                    case 1:\n                      t.depthFunc(519);\n                      break;\n                    case 2:\n                      t.depthFunc(513);\n                      break;\n                    default:\n                      t.depthFunc(515);\n                      break;\n                    case 4:\n                      t.depthFunc(514);\n                      break;\n                    case 5:\n                      t.depthFunc(518);\n                      break;\n                    case 6:\n                      t.depthFunc(516);\n                      break;\n                    case 7:\n                      t.depthFunc(517);\n                  }\n                else t.depthFunc(515);\n                i = e;\n              }\n            },\n            setLocked: function (t) {\n              e = t;\n            },\n            setClear: function (e) {\n              r !== e && (t.clearDepth(e), (r = e));\n            },\n            reset: function () {\n              (e = !1), (n = null), (i = null), (r = null);\n            },\n          };\n        })(),\n        o = new (function () {\n          let e = !1,\n            n = null,\n            i = null,\n            r = null,\n            s = null,\n            a = null,\n            o = null,\n            l = null,\n            c = null;\n          return {\n            setTest: function (t) {\n              e || (t ? O(2960) : U(2960));\n            },\n            setMask: function (i) {\n              n === i || e || (t.stencilMask(i), (n = i));\n            },\n            setFunc: function (e, n, a) {\n              (i === e && r === n && s === a) ||\n                (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));\n            },\n            setOp: function (e, n, i) {\n              (a === e && o === n && l === i) ||\n                (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));\n            },\n            setLocked: function (t) {\n              e = t;\n            },\n            setClear: function (e) {\n              c !== e && (t.clearStencil(e), (c = e));\n            },\n            reset: function () {\n              (e = !1),\n                (n = null),\n                (i = null),\n                (r = null),\n                (s = null),\n                (a = null),\n                (o = null),\n                (l = null),\n                (c = null);\n            },\n          };\n        })();\n      let l = {},\n        c = null,\n        h = {},\n        u = null,\n        d = !1,\n        p = null,\n        m = null,\n        f = null,\n        g = null,\n        v = null,\n        y = null,\n        x = null,\n        _ = !1,\n        M = null,\n        b = null,\n        w = null,\n        S = null,\n        T = null;\n      const E = t.getParameter(35661);\n      let A = !1,\n        L = 0;\n      const R = t.getParameter(7938);\n      -1 !== R.indexOf(\"WebGL\")\n        ? ((L = parseFloat(/^WebGL (\\d)/.exec(R)[1])), (A = L >= 1))\n        : -1 !== R.indexOf(\"OpenGL ES\") &&\n          ((L = parseFloat(/^OpenGL ES (\\d)/.exec(R)[1])), (A = L >= 2));\n      let C = null,\n        P = {};\n      const I = t.getParameter(3088),\n        D = t.getParameter(2978),\n        N = new Ct().fromArray(I),\n        z = new Ct().fromArray(D);\n      function B(e, n, i) {\n        const r = new Uint8Array(4),\n          s = t.createTexture();\n        t.bindTexture(e, s),\n          t.texParameteri(e, 10241, 9728),\n          t.texParameteri(e, 10240, 9728);\n        for (let e = 0; e < i; e++)\n          t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);\n        return s;\n      }\n      const F = {};\n      function O(e) {\n        !0 !== l[e] && (t.enable(e), (l[e] = !0));\n      }\n      function U(e) {\n        !1 !== l[e] && (t.disable(e), (l[e] = !1));\n      }\n      (F[3553] = B(3553, 3553, 1)),\n        (F[34067] = B(34067, 34069, 6)),\n        s.setClear(0, 0, 0, 1),\n        a.setClear(1),\n        o.setClear(0),\n        O(2929),\n        a.setFunc(3),\n        V(!1),\n        W(1),\n        O(2884),\n        k(0);\n      const H = { [n]: 32774, 101: 32778, 102: 32779 };\n      if (r) (H[103] = 32775), (H[104] = 32776);\n      else {\n        const t = e.get(\"EXT_blend_minmax\");\n        null !== t && ((H[103] = t.MIN_EXT), (H[104] = t.MAX_EXT));\n      }\n      const G = {\n        200: 0,\n        201: 1,\n        202: 768,\n        204: 770,\n        210: 776,\n        208: 774,\n        206: 772,\n        203: 769,\n        205: 771,\n        209: 775,\n        207: 773,\n      };\n      function k(e, i, r, s, a, o, l, c) {\n        if (0 !== e) {\n          if ((!1 === d && (O(3042), (d = !0)), 5 === e))\n            (a = a || i),\n              (o = o || r),\n              (l = l || s),\n              (i === m && a === v) ||\n                (t.blendEquationSeparate(H[i], H[a]), (m = i), (v = a)),\n              (r === f && s === g && o === y && l === x) ||\n                (t.blendFuncSeparate(G[r], G[s], G[o], G[l]),\n                (f = r),\n                (g = s),\n                (y = o),\n                (x = l)),\n              (p = e),\n              (_ = null);\n          else if (e !== p || c !== _) {\n            if (\n              ((m === n && v === n) ||\n                (t.blendEquation(32774), (m = n), (v = n)),\n              c)\n            )\n              switch (e) {\n                case 1:\n                  t.blendFuncSeparate(1, 771, 1, 771);\n                  break;\n                case 2:\n                  t.blendFunc(1, 1);\n                  break;\n                case 3:\n                  t.blendFuncSeparate(0, 0, 769, 771);\n                  break;\n                case 4:\n                  t.blendFuncSeparate(0, 768, 0, 770);\n                  break;\n                default:\n                  console.error(\"THREE.WebGLState: Invalid blending: \", e);\n              }\n            else\n              switch (e) {\n                case 1:\n                  t.blendFuncSeparate(770, 771, 1, 771);\n                  break;\n                case 2:\n                  t.blendFunc(770, 1);\n                  break;\n                case 3:\n                  t.blendFunc(0, 769);\n                  break;\n                case 4:\n                  t.blendFunc(0, 768);\n                  break;\n                default:\n                  console.error(\"THREE.WebGLState: Invalid blending: \", e);\n              }\n            (f = null), (g = null), (y = null), (x = null), (p = e), (_ = c);\n          }\n        } else !0 === d && (U(3042), (d = !1));\n      }\n      function V(e) {\n        M !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (M = e));\n      }\n      function W(e) {\n        0 !== e\n          ? (O(2884),\n            e !== b &&\n              (1 === e\n                ? t.cullFace(1029)\n                : 2 === e\n                ? t.cullFace(1028)\n                : t.cullFace(1032)))\n          : U(2884),\n          (b = e);\n      }\n      function j(e, n, i) {\n        e\n          ? (O(32823),\n            (S === n && T === i) || (t.polygonOffset(n, i), (S = n), (T = i)))\n          : U(32823);\n      }\n      function q(e) {\n        void 0 === e && (e = 33984 + E - 1),\n          C !== e && (t.activeTexture(e), (C = e));\n      }\n      return {\n        buffers: { color: s, depth: a, stencil: o },\n        enable: O,\n        disable: U,\n        bindFramebuffer: function (e, n) {\n          return (\n            null === n && null !== c && (n = c),\n            h[e] !== n &&\n              (t.bindFramebuffer(e, n),\n              (h[e] = n),\n              r &&\n                (36009 === e && (h[36160] = n), 36160 === e && (h[36009] = n)),\n              !0)\n          );\n        },\n        bindXRFramebuffer: function (e) {\n          e !== c && (t.bindFramebuffer(36160, e), (c = e));\n        },\n        useProgram: function (e) {\n          return u !== e && (t.useProgram(e), (u = e), !0);\n        },\n        setBlending: k,\n        setMaterial: function (t, e) {\n          2 === t.side ? U(2884) : O(2884);\n          let n = 1 === t.side;\n          e && (n = !n),\n            V(n),\n            1 === t.blending && !1 === t.transparent\n              ? k(0)\n              : k(\n                  t.blending,\n                  t.blendEquation,\n                  t.blendSrc,\n                  t.blendDst,\n                  t.blendEquationAlpha,\n                  t.blendSrcAlpha,\n                  t.blendDstAlpha,\n                  t.premultipliedAlpha\n                ),\n            a.setFunc(t.depthFunc),\n            a.setTest(t.depthTest),\n            a.setMask(t.depthWrite),\n            s.setMask(t.colorWrite);\n          const i = t.stencilWrite;\n          o.setTest(i),\n            i &&\n              (o.setMask(t.stencilWriteMask),\n              o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),\n              o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),\n            j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),\n            !0 === t.alphaToCoverage ? O(32926) : U(32926);\n        },\n        setFlipSided: V,\n        setCullFace: W,\n        setLineWidth: function (e) {\n          e !== w && (A && t.lineWidth(e), (w = e));\n        },\n        setPolygonOffset: j,\n        setScissorTest: function (t) {\n          t ? O(3089) : U(3089);\n        },\n        activeTexture: q,\n        bindTexture: function (e, n) {\n          null === C && q();\n          let i = P[C];\n          void 0 === i && ((i = { type: void 0, texture: void 0 }), (P[C] = i)),\n            (i.type === e && i.texture === n) ||\n              (t.bindTexture(e, n || F[e]), (i.type = e), (i.texture = n));\n        },\n        unbindTexture: function () {\n          const e = P[C];\n          void 0 !== e &&\n            void 0 !== e.type &&\n            (t.bindTexture(e.type, null),\n            (e.type = void 0),\n            (e.texture = void 0));\n        },\n        compressedTexImage2D: function () {\n          try {\n            t.compressedTexImage2D.apply(t, arguments);\n          } catch (t) {\n            console.error(\"THREE.WebGLState:\", t);\n          }\n        },\n        texImage2D: function () {\n          try {\n            t.texImage2D.apply(t, arguments);\n          } catch (t) {\n            console.error(\"THREE.WebGLState:\", t);\n          }\n        },\n        texImage3D: function () {\n          try {\n            t.texImage3D.apply(t, arguments);\n          } catch (t) {\n            console.error(\"THREE.WebGLState:\", t);\n          }\n        },\n        scissor: function (e) {\n          !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e));\n        },\n        viewport: function (e) {\n          !1 === z.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), z.copy(e));\n        },\n        reset: function () {\n          t.disable(3042),\n            t.disable(2884),\n            t.disable(2929),\n            t.disable(32823),\n            t.disable(3089),\n            t.disable(2960),\n            t.disable(32926),\n            t.blendEquation(32774),\n            t.blendFunc(1, 0),\n            t.blendFuncSeparate(1, 0, 1, 0),\n            t.colorMask(!0, !0, !0, !0),\n            t.clearColor(0, 0, 0, 0),\n            t.depthMask(!0),\n            t.depthFunc(513),\n            t.clearDepth(1),\n            t.stencilMask(4294967295),\n            t.stencilFunc(519, 0, 4294967295),\n            t.stencilOp(7680, 7680, 7680),\n            t.clearStencil(0),\n            t.cullFace(1029),\n            t.frontFace(2305),\n            t.polygonOffset(0, 0),\n            t.activeTexture(33984),\n            t.bindFramebuffer(36160, null),\n            !0 === r &&\n              (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),\n            t.useProgram(null),\n            t.lineWidth(1),\n            t.scissor(0, 0, t.canvas.width, t.canvas.height),\n            t.viewport(0, 0, t.canvas.width, t.canvas.height),\n            (l = {}),\n            (C = null),\n            (P = {}),\n            (c = null),\n            (h = {}),\n            (u = null),\n            (d = !1),\n            (p = null),\n            (m = null),\n            (f = null),\n            (g = null),\n            (v = null),\n            (y = null),\n            (x = null),\n            (_ = !1),\n            (M = null),\n            (b = null),\n            (w = null),\n            (S = null),\n            (T = null),\n            N.set(0, 0, t.canvas.width, t.canvas.height),\n            z.set(0, 0, t.canvas.width, t.canvas.height),\n            s.reset(),\n            a.reset(),\n            o.reset();\n        },\n      };\n    }\n    function Vs(t, e, n, i, r, s, a) {\n      const o = r.isWebGL2,\n        l = r.maxTextures,\n        c = r.maxCubemapSize,\n        x = r.maxTextureSize,\n        R = r.maxSamples,\n        C = new WeakMap();\n      let P,\n        I = !1;\n      try {\n        I =\n          \"undefined\" != typeof OffscreenCanvas &&\n          null !== new OffscreenCanvas(1, 1).getContext(\"2d\");\n      } catch (t) {}\n      function D(t, e) {\n        return I ? new OffscreenCanvas(t, e) : wt(\"canvas\");\n      }\n      function N(t, e, n, i) {\n        let r = 1;\n        if (\n          ((t.width > i || t.height > i) &&\n            (r = i / Math.max(t.width, t.height)),\n          r < 1 || !0 === e)\n        ) {\n          if (\n            (\"undefined\" != typeof HTMLImageElement &&\n              t instanceof HTMLImageElement) ||\n            (\"undefined\" != typeof HTMLCanvasElement &&\n              t instanceof HTMLCanvasElement) ||\n            (\"undefined\" != typeof ImageBitmap && t instanceof ImageBitmap)\n          ) {\n            const i = e ? gt : Math.floor,\n              s = i(r * t.width),\n              a = i(r * t.height);\n            void 0 === P && (P = D(s, a));\n            const o = n ? D(s, a) : P;\n            (o.width = s), (o.height = a);\n            return (\n              o.getContext(\"2d\").drawImage(t, 0, 0, s, a),\n              console.warn(\n                \"THREE.WebGLRenderer: Texture has been resized from (\" +\n                  t.width +\n                  \"x\" +\n                  t.height +\n                  \") to (\" +\n                  s +\n                  \"x\" +\n                  a +\n                  \").\"\n              ),\n              o\n            );\n          }\n          return (\n            \"data\" in t &&\n              console.warn(\n                \"THREE.WebGLRenderer: Image in DataTexture is too big (\" +\n                  t.width +\n                  \"x\" +\n                  t.height +\n                  \").\"\n              ),\n            t\n          );\n        }\n        return t;\n      }\n      function z(t) {\n        return mt(t.width) && mt(t.height);\n      }\n      function B(t, e) {\n        return t.generateMipmaps && e && t.minFilter !== p && t.minFilter !== g;\n      }\n      function F(e, n, r, s, a = 1) {\n        t.generateMipmap(e);\n        i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a));\n      }\n      function O(n, i, r, s) {\n        if (!1 === o) return i;\n        if (null !== n) {\n          if (void 0 !== t[n]) return t[n];\n          console.warn(\n            \"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '\" +\n              n +\n              \"'\"\n          );\n        }\n        let a = i;\n        return (\n          6403 === i &&\n            (5126 === r && (a = 33326),\n            5131 === r && (a = 33325),\n            5121 === r && (a = 33321)),\n          6407 === i &&\n            (5126 === r && (a = 34837),\n            5131 === r && (a = 34843),\n            5121 === r && (a = 32849)),\n          6408 === i &&\n            (5126 === r && (a = 34836),\n            5131 === r && (a = 34842),\n            5121 === r && (a = s === Y ? 35907 : 32856)),\n          (33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) ||\n            e.get(\"EXT_color_buffer_float\"),\n          a\n        );\n      }\n      function U(t) {\n        return t === p || t === m || t === f ? 9728 : 9729;\n      }\n      function H(e) {\n        const n = e.target;\n        n.removeEventListener(\"dispose\", H),\n          (function (e) {\n            const n = i.get(e);\n            if (void 0 === n.__webglInit) return;\n            t.deleteTexture(n.__webglTexture), i.remove(e);\n          })(n),\n          n.isVideoTexture && C.delete(n),\n          a.memory.textures--;\n      }\n      function G(e) {\n        const n = e.target;\n        n.removeEventListener(\"dispose\", G),\n          (function (e) {\n            const n = e.texture,\n              r = i.get(e),\n              s = i.get(n);\n            if (!e) return;\n            void 0 !== s.__webglTexture &&\n              (t.deleteTexture(s.__webglTexture), a.memory.textures--);\n            e.depthTexture && e.depthTexture.dispose();\n            if (e.isWebGLCubeRenderTarget)\n              for (let e = 0; e < 6; e++)\n                t.deleteFramebuffer(r.__webglFramebuffer[e]),\n                  r.__webglDepthbuffer &&\n                    t.deleteRenderbuffer(r.__webglDepthbuffer[e]);\n            else\n              t.deleteFramebuffer(r.__webglFramebuffer),\n                r.__webglDepthbuffer &&\n                  t.deleteRenderbuffer(r.__webglDepthbuffer),\n                r.__webglMultisampledFramebuffer &&\n                  t.deleteFramebuffer(r.__webglMultisampledFramebuffer),\n                r.__webglColorRenderbuffer &&\n                  t.deleteRenderbuffer(r.__webglColorRenderbuffer),\n                r.__webglDepthRenderbuffer &&\n                  t.deleteRenderbuffer(r.__webglDepthRenderbuffer);\n            if (e.isWebGLMultipleRenderTargets)\n              for (let e = 0, r = n.length; e < r; e++) {\n                const r = i.get(n[e]);\n                r.__webglTexture &&\n                  (t.deleteTexture(r.__webglTexture), a.memory.textures--),\n                  i.remove(n[e]);\n              }\n            i.remove(n), i.remove(e);\n          })(n);\n      }\n      let k = 0;\n      function V(t, e) {\n        const r = i.get(t);\n        if (\n          (t.isVideoTexture &&\n            (function (t) {\n              const e = a.render.frame;\n              C.get(t) !== e && (C.set(t, e), t.update());\n            })(t),\n          t.version > 0 && r.__version !== t.version)\n        ) {\n          const n = t.image;\n          if (void 0 === n)\n            console.warn(\n              \"THREE.WebGLRenderer: Texture marked for update but image is undefined\"\n            );\n          else {\n            if (!1 !== n.complete) return void Z(r, t, e);\n            console.warn(\n              \"THREE.WebGLRenderer: Texture marked for update but image is incomplete\"\n            );\n          }\n        }\n        n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);\n      }\n      function W(e, r) {\n        const a = i.get(e);\n        e.version > 0 && a.__version !== e.version\n          ? (function (e, i, r) {\n              if (6 !== i.image.length) return;\n              J(e, i),\n                n.activeTexture(33984 + r),\n                n.bindTexture(34067, e.__webglTexture),\n                t.pixelStorei(37440, i.flipY),\n                t.pixelStorei(37441, i.premultiplyAlpha),\n                t.pixelStorei(3317, i.unpackAlignment),\n                t.pixelStorei(37443, 0);\n              const a =\n                  i &&\n                  (i.isCompressedTexture || i.image[0].isCompressedTexture),\n                l = i.image[0] && i.image[0].isDataTexture,\n                h = [];\n              for (let t = 0; t < 6; t++)\n                h[t] =\n                  a || l\n                    ? l\n                      ? i.image[t].image\n                      : i.image[t]\n                    : N(i.image[t], !1, !0, c);\n              const u = h[0],\n                d = z(u) || o,\n                p = s.convert(i.format),\n                m = s.convert(i.type),\n                f = O(i.internalFormat, p, m, i.encoding);\n              let g;\n              if ((X(34067, i, d), a)) {\n                for (let t = 0; t < 6; t++) {\n                  g = h[t].mipmaps;\n                  for (let e = 0; e < g.length; e++) {\n                    const r = g[e];\n                    i.format !== E && i.format !== T\n                      ? null !== p\n                        ? n.compressedTexImage2D(\n                            34069 + t,\n                            e,\n                            f,\n                            r.width,\n                            r.height,\n                            0,\n                            r.data\n                          )\n                        : console.warn(\n                            \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\"\n                          )\n                      : n.texImage2D(\n                          34069 + t,\n                          e,\n                          f,\n                          r.width,\n                          r.height,\n                          0,\n                          p,\n                          m,\n                          r.data\n                        );\n                  }\n                }\n                e.__maxMipLevel = g.length - 1;\n              } else {\n                g = i.mipmaps;\n                for (let t = 0; t < 6; t++)\n                  if (l) {\n                    n.texImage2D(\n                      34069 + t,\n                      0,\n                      f,\n                      h[t].width,\n                      h[t].height,\n                      0,\n                      p,\n                      m,\n                      h[t].data\n                    );\n                    for (let e = 0; e < g.length; e++) {\n                      const i = g[e].image[t].image;\n                      n.texImage2D(\n                        34069 + t,\n                        e + 1,\n                        f,\n                        i.width,\n                        i.height,\n                        0,\n                        p,\n                        m,\n                        i.data\n                      );\n                    }\n                  } else {\n                    n.texImage2D(34069 + t, 0, f, p, m, h[t]);\n                    for (let e = 0; e < g.length; e++) {\n                      const i = g[e];\n                      n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t]);\n                    }\n                  }\n                e.__maxMipLevel = g.length;\n              }\n              B(i, d) && F(34067, i, u.width, u.height);\n              (e.__version = i.version), i.onUpdate && i.onUpdate(i);\n            })(a, e, r)\n          : (n.activeTexture(33984 + r),\n            n.bindTexture(34067, a.__webglTexture));\n      }\n      const j = { [h]: 10497, [u]: 33071, [d]: 33648 },\n        q = {\n          [p]: 9728,\n          [m]: 9984,\n          [f]: 9986,\n          [g]: 9729,\n          [v]: 9985,\n          [y]: 9987,\n        };\n      function X(n, s, a) {\n        if (\n          (a\n            ? (t.texParameteri(n, 10242, j[s.wrapS]),\n              t.texParameteri(n, 10243, j[s.wrapT]),\n              (32879 !== n && 35866 !== n) ||\n                t.texParameteri(n, 32882, j[s.wrapR]),\n              t.texParameteri(n, 10240, q[s.magFilter]),\n              t.texParameteri(n, 10241, q[s.minFilter]))\n            : (t.texParameteri(n, 10242, 33071),\n              t.texParameteri(n, 10243, 33071),\n              (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),\n              (s.wrapS === u && s.wrapT === u) ||\n                console.warn(\n                  \"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.\"\n                ),\n              t.texParameteri(n, 10240, U(s.magFilter)),\n              t.texParameteri(n, 10241, U(s.minFilter)),\n              s.minFilter !== p &&\n                s.minFilter !== g &&\n                console.warn(\n                  \"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.\"\n                )),\n          !0 === e.has(\"EXT_texture_filter_anisotropic\"))\n        ) {\n          const a = e.get(\"EXT_texture_filter_anisotropic\");\n          if (s.type === b && !1 === e.has(\"OES_texture_float_linear\")) return;\n          if (\n            !1 === o &&\n            s.type === w &&\n            !1 === e.has(\"OES_texture_half_float_linear\")\n          )\n            return;\n          (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&\n            (t.texParameterf(\n              n,\n              a.TEXTURE_MAX_ANISOTROPY_EXT,\n              Math.min(s.anisotropy, r.getMaxAnisotropy())\n            ),\n            (i.get(s).__currentAnisotropy = s.anisotropy));\n        }\n      }\n      function J(e, n) {\n        void 0 === e.__webglInit &&\n          ((e.__webglInit = !0),\n          n.addEventListener(\"dispose\", H),\n          (e.__webglTexture = t.createTexture()),\n          a.memory.textures++);\n      }\n      function Z(e, i, r) {\n        let a = 3553;\n        i.isDataTexture2DArray && (a = 35866),\n          i.isDataTexture3D && (a = 32879),\n          J(e, i),\n          n.activeTexture(33984 + r),\n          n.bindTexture(a, e.__webglTexture),\n          t.pixelStorei(37440, i.flipY),\n          t.pixelStorei(37441, i.premultiplyAlpha),\n          t.pixelStorei(3317, i.unpackAlignment),\n          t.pixelStorei(37443, 0);\n        const l =\n            (function (t) {\n              return (\n                !o &&\n                (t.wrapS !== u ||\n                  t.wrapT !== u ||\n                  (t.minFilter !== p && t.minFilter !== g))\n              );\n            })(i) && !1 === z(i.image),\n          c = N(i.image, l, !1, x),\n          h = z(c) || o,\n          d = s.convert(i.format);\n        let m,\n          f = s.convert(i.type),\n          v = O(i.internalFormat, d, f, i.encoding);\n        X(a, i, h);\n        const y = i.mipmaps;\n        if (i.isDepthTexture)\n          (v = 6402),\n            o\n              ? (v =\n                  i.type === b\n                    ? 36012\n                    : i.type === M\n                    ? 33190\n                    : i.type === S\n                    ? 35056\n                    : 33189)\n              : i.type === b &&\n                console.error(\n                  \"WebGLRenderer: Floating point depth texture requires WebGL2.\"\n                ),\n            i.format === A &&\n              6402 === v &&\n              i.type !== _ &&\n              i.type !== M &&\n              (console.warn(\n                \"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.\"\n              ),\n              (i.type = _),\n              (f = s.convert(i.type))),\n            i.format === L &&\n              6402 === v &&\n              ((v = 34041),\n              i.type !== S &&\n                (console.warn(\n                  \"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.\"\n                ),\n                (i.type = S),\n                (f = s.convert(i.type)))),\n            n.texImage2D(3553, 0, v, c.width, c.height, 0, d, f, null);\n        else if (i.isDataTexture)\n          if (y.length > 0 && h) {\n            for (let t = 0, e = y.length; t < e; t++)\n              (m = y[t]),\n                n.texImage2D(3553, t, v, m.width, m.height, 0, d, f, m.data);\n            (i.generateMipmaps = !1), (e.__maxMipLevel = y.length - 1);\n          } else\n            n.texImage2D(3553, 0, v, c.width, c.height, 0, d, f, c.data),\n              (e.__maxMipLevel = 0);\n        else if (i.isCompressedTexture) {\n          for (let t = 0, e = y.length; t < e; t++)\n            (m = y[t]),\n              i.format !== E && i.format !== T\n                ? null !== d\n                  ? n.compressedTexImage2D(\n                      3553,\n                      t,\n                      v,\n                      m.width,\n                      m.height,\n                      0,\n                      m.data\n                    )\n                  : console.warn(\n                      \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\"\n                    )\n                : n.texImage2D(3553, t, v, m.width, m.height, 0, d, f, m.data);\n          e.__maxMipLevel = y.length - 1;\n        } else if (i.isDataTexture2DArray)\n          n.texImage3D(\n            35866,\n            0,\n            v,\n            c.width,\n            c.height,\n            c.depth,\n            0,\n            d,\n            f,\n            c.data\n          ),\n            (e.__maxMipLevel = 0);\n        else if (i.isDataTexture3D)\n          n.texImage3D(\n            32879,\n            0,\n            v,\n            c.width,\n            c.height,\n            c.depth,\n            0,\n            d,\n            f,\n            c.data\n          ),\n            (e.__maxMipLevel = 0);\n        else if (y.length > 0 && h) {\n          for (let t = 0, e = y.length; t < e; t++)\n            (m = y[t]), n.texImage2D(3553, t, v, d, f, m);\n          (i.generateMipmaps = !1), (e.__maxMipLevel = y.length - 1);\n        } else n.texImage2D(3553, 0, v, d, f, c), (e.__maxMipLevel = 0);\n        B(i, h) && F(a, i, c.width, c.height),\n          (e.__version = i.version),\n          i.onUpdate && i.onUpdate(i);\n      }\n      function Q(e, r, a, o, l) {\n        const c = s.convert(a.format),\n          h = s.convert(a.type),\n          u = O(a.internalFormat, c, h, a.encoding);\n        32879 === l || 35866 === l\n          ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null)\n          : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null),\n          n.bindFramebuffer(36160, e),\n          t.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),\n          n.bindFramebuffer(36160, null);\n      }\n      function K(e, n, i) {\n        if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {\n          let r = 33189;\n          if (i) {\n            const e = n.depthTexture;\n            e &&\n              e.isDepthTexture &&\n              (e.type === b ? (r = 36012) : e.type === M && (r = 33190));\n            const i = tt(n);\n            t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);\n          } else t.renderbufferStorage(36161, r, n.width, n.height);\n          t.framebufferRenderbuffer(36160, 36096, 36161, e);\n        } else if (n.depthBuffer && n.stencilBuffer) {\n          if (i) {\n            const e = tt(n);\n            t.renderbufferStorageMultisample(\n              36161,\n              e,\n              35056,\n              n.width,\n              n.height\n            );\n          } else t.renderbufferStorage(36161, 34041, n.width, n.height);\n          t.framebufferRenderbuffer(36160, 33306, 36161, e);\n        } else {\n          const e =\n              !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,\n            r = s.convert(e.format),\n            a = s.convert(e.type),\n            o = O(e.internalFormat, r, a, e.encoding);\n          if (i) {\n            const e = tt(n);\n            t.renderbufferStorageMultisample(36161, e, o, n.width, n.height);\n          } else t.renderbufferStorage(36161, o, n.width, n.height);\n        }\n        t.bindRenderbuffer(36161, null);\n      }\n      function $(e) {\n        const r = i.get(e),\n          s = !0 === e.isWebGLCubeRenderTarget;\n        if (e.depthTexture) {\n          if (s)\n            throw new Error(\n              \"target.depthTexture not supported in Cube render targets\"\n            );\n          !(function (e, r) {\n            if (r && r.isWebGLCubeRenderTarget)\n              throw new Error(\n                \"Depth Texture with cube render targets is not supported\"\n              );\n            if (\n              (n.bindFramebuffer(36160, e),\n              !r.depthTexture || !r.depthTexture.isDepthTexture)\n            )\n              throw new Error(\n                \"renderTarget.depthTexture must be an instance of THREE.DepthTexture\"\n              );\n            (i.get(r.depthTexture).__webglTexture &&\n              r.depthTexture.image.width === r.width &&\n              r.depthTexture.image.height === r.height) ||\n              ((r.depthTexture.image.width = r.width),\n              (r.depthTexture.image.height = r.height),\n              (r.depthTexture.needsUpdate = !0)),\n              V(r.depthTexture, 0);\n            const s = i.get(r.depthTexture).__webglTexture;\n            if (r.depthTexture.format === A)\n              t.framebufferTexture2D(36160, 36096, 3553, s, 0);\n            else {\n              if (r.depthTexture.format !== L)\n                throw new Error(\"Unknown depthTexture format\");\n              t.framebufferTexture2D(36160, 33306, 3553, s, 0);\n            }\n          })(r.__webglFramebuffer, e);\n        } else if (s) {\n          r.__webglDepthbuffer = [];\n          for (let i = 0; i < 6; i++)\n            n.bindFramebuffer(36160, r.__webglFramebuffer[i]),\n              (r.__webglDepthbuffer[i] = t.createRenderbuffer()),\n              K(r.__webglDepthbuffer[i], e, !1);\n        } else\n          n.bindFramebuffer(36160, r.__webglFramebuffer),\n            (r.__webglDepthbuffer = t.createRenderbuffer()),\n            K(r.__webglDepthbuffer, e, !1);\n        n.bindFramebuffer(36160, null);\n      }\n      function tt(t) {\n        return o && t.isWebGLMultisampleRenderTarget\n          ? Math.min(R, t.samples)\n          : 0;\n      }\n      let et = !1,\n        nt = !1;\n      (this.allocateTextureUnit = function () {\n        const t = k;\n        return (\n          t >= l &&\n            console.warn(\n              \"THREE.WebGLTextures: Trying to use \" +\n                t +\n                \" texture units while this GPU supports only \" +\n                l\n            ),\n          (k += 1),\n          t\n        );\n      }),\n        (this.resetTextureUnits = function () {\n          k = 0;\n        }),\n        (this.setTexture2D = V),\n        (this.setTexture2DArray = function (t, e) {\n          const r = i.get(t);\n          t.version > 0 && r.__version !== t.version\n            ? Z(r, t, e)\n            : (n.activeTexture(33984 + e),\n              n.bindTexture(35866, r.__webglTexture));\n        }),\n        (this.setTexture3D = function (t, e) {\n          const r = i.get(t);\n          t.version > 0 && r.__version !== t.version\n            ? Z(r, t, e)\n            : (n.activeTexture(33984 + e),\n              n.bindTexture(32879, r.__webglTexture));\n        }),\n        (this.setTextureCube = W),\n        (this.setupRenderTarget = function (e) {\n          const l = e.texture,\n            c = i.get(e),\n            h = i.get(l);\n          e.addEventListener(\"dispose\", G),\n            !0 !== e.isWebGLMultipleRenderTargets &&\n              ((h.__webglTexture = t.createTexture()),\n              (h.__version = l.version),\n              a.memory.textures++);\n          const u = !0 === e.isWebGLCubeRenderTarget,\n            d = !0 === e.isWebGLMultipleRenderTargets,\n            p = !0 === e.isWebGLMultisampleRenderTarget,\n            m = l.isDataTexture3D || l.isDataTexture2DArray,\n            f = z(e) || o;\n          if (\n            (!o ||\n              l.format !== T ||\n              (l.type !== b && l.type !== w) ||\n              ((l.format = E),\n              console.warn(\n                \"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.\"\n              )),\n            u)\n          ) {\n            c.__webglFramebuffer = [];\n            for (let e = 0; e < 6; e++)\n              c.__webglFramebuffer[e] = t.createFramebuffer();\n          } else if (((c.__webglFramebuffer = t.createFramebuffer()), d))\n            if (r.drawBuffers) {\n              const n = e.texture;\n              for (let e = 0, r = n.length; e < r; e++) {\n                const r = i.get(n[e]);\n                void 0 === r.__webglTexture &&\n                  ((r.__webglTexture = t.createTexture()), a.memory.textures++);\n              }\n            } else\n              console.warn(\n                \"THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.\"\n              );\n          else if (p)\n            if (o) {\n              (c.__webglMultisampledFramebuffer = t.createFramebuffer()),\n                (c.__webglColorRenderbuffer = t.createRenderbuffer()),\n                t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);\n              const i = s.convert(l.format),\n                r = s.convert(l.type),\n                a = O(l.internalFormat, i, r, l.encoding),\n                o = tt(e);\n              t.renderbufferStorageMultisample(36161, o, a, e.width, e.height),\n                n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),\n                t.framebufferRenderbuffer(\n                  36160,\n                  36064,\n                  36161,\n                  c.__webglColorRenderbuffer\n                ),\n                t.bindRenderbuffer(36161, null),\n                e.depthBuffer &&\n                  ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),\n                  K(c.__webglDepthRenderbuffer, e, !0)),\n                n.bindFramebuffer(36160, null);\n            } else\n              console.warn(\n                \"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.\"\n              );\n          if (u) {\n            n.bindTexture(34067, h.__webglTexture), X(34067, l, f);\n            for (let t = 0; t < 6; t++)\n              Q(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);\n            B(l, f) && F(34067, l, e.width, e.height), n.unbindTexture();\n          } else if (d) {\n            const t = e.texture;\n            for (let r = 0, s = t.length; r < s; r++) {\n              const s = t[r],\n                a = i.get(s);\n              n.bindTexture(3553, a.__webglTexture),\n                X(3553, s, f),\n                Q(c.__webglFramebuffer, e, s, 36064 + r, 3553),\n                B(s, f) && F(3553, s, e.width, e.height);\n            }\n            n.unbindTexture();\n          } else {\n            let t = 3553;\n            if (m)\n              if (o) {\n                t = l.isDataTexture3D ? 32879 : 35866;\n              } else\n                console.warn(\n                  \"THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.\"\n                );\n            n.bindTexture(t, h.__webglTexture),\n              X(t, l, f),\n              Q(c.__webglFramebuffer, e, l, 36064, t),\n              B(l, f) && F(t, l, e.width, e.height, e.depth),\n              n.unbindTexture();\n          }\n          e.depthBuffer && $(e);\n        }),\n        (this.updateRenderTargetMipmap = function (t) {\n          const e = z(t) || o,\n            r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];\n          for (let s = 0, a = r.length; s < a; s++) {\n            const a = r[s];\n            if (B(a, e)) {\n              const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,\n                r = i.get(a).__webglTexture;\n              n.bindTexture(e, r),\n                F(e, a, t.width, t.height),\n                n.unbindTexture();\n            }\n          }\n        }),\n        (this.updateMultisampleRenderTarget = function (e) {\n          if (e.isWebGLMultisampleRenderTarget)\n            if (o) {\n              const r = e.width,\n                s = e.height;\n              let a = 16384;\n              e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024);\n              const o = i.get(e);\n              n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),\n                n.bindFramebuffer(36009, o.__webglFramebuffer),\n                t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),\n                n.bindFramebuffer(36008, null),\n                n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);\n            } else\n              console.warn(\n                \"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.\"\n              );\n        }),\n        (this.safeSetTexture2D = function (t, e) {\n          t &&\n            t.isWebGLRenderTarget &&\n            (!1 === et &&\n              (console.warn(\n                \"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\"\n              ),\n              (et = !0)),\n            (t = t.texture)),\n            V(t, e);\n        }),\n        (this.safeSetTextureCube = function (t, e) {\n          t &&\n            t.isWebGLCubeRenderTarget &&\n            (!1 === nt &&\n              (console.warn(\n                \"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\"\n              ),\n              (nt = !0)),\n            (t = t.texture)),\n            W(t, e);\n        });\n    }\n    function Ws(t, e, n) {\n      const i = n.isWebGL2;\n      return {\n        convert: function (t) {\n          let n;\n          if (t === x) return 5121;\n          if (1017 === t) return 32819;\n          if (1018 === t) return 32820;\n          if (1019 === t) return 33635;\n          if (1010 === t) return 5120;\n          if (1011 === t) return 5122;\n          if (t === _) return 5123;\n          if (1013 === t) return 5124;\n          if (t === M) return 5125;\n          if (t === b) return 5126;\n          if (t === w)\n            return i\n              ? 5131\n              : ((n = e.get(\"OES_texture_half_float\")),\n                null !== n ? n.HALF_FLOAT_OES : null);\n          if (1021 === t) return 6406;\n          if (t === T) return 6407;\n          if (t === E) return 6408;\n          if (1024 === t) return 6409;\n          if (1025 === t) return 6410;\n          if (t === A) return 6402;\n          if (t === L) return 34041;\n          if (1028 === t) return 6403;\n          if (1029 === t) return 36244;\n          if (1030 === t) return 33319;\n          if (1031 === t) return 33320;\n          if (1032 === t) return 36248;\n          if (1033 === t) return 36249;\n          if (t === R || t === C || t === P || t === I) {\n            if (((n = e.get(\"WEBGL_compressed_texture_s3tc\")), null === n))\n              return null;\n            if (t === R) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;\n            if (t === C) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n            if (t === P) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n            if (t === I) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n          }\n          if (t === D || t === N || t === z || t === B) {\n            if (((n = e.get(\"WEBGL_compressed_texture_pvrtc\")), null === n))\n              return null;\n            if (t === D) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n            if (t === N) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n            if (t === z) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n            if (t === B) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n          }\n          if (36196 === t)\n            return (\n              (n = e.get(\"WEBGL_compressed_texture_etc1\")),\n              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null\n            );\n          if (\n            (t === F || t === O) &&\n            ((n = e.get(\"WEBGL_compressed_texture_etc\")), null !== n)\n          ) {\n            if (t === F) return n.COMPRESSED_RGB8_ETC2;\n            if (t === O) return n.COMPRESSED_RGBA8_ETC2_EAC;\n          }\n          return 37808 === t ||\n            37809 === t ||\n            37810 === t ||\n            37811 === t ||\n            37812 === t ||\n            37813 === t ||\n            37814 === t ||\n            37815 === t ||\n            37816 === t ||\n            37817 === t ||\n            37818 === t ||\n            37819 === t ||\n            37820 === t ||\n            37821 === t ||\n            37840 === t ||\n            37841 === t ||\n            37842 === t ||\n            37843 === t ||\n            37844 === t ||\n            37845 === t ||\n            37846 === t ||\n            37847 === t ||\n            37848 === t ||\n            37849 === t ||\n            37850 === t ||\n            37851 === t ||\n            37852 === t ||\n            37853 === t\n            ? ((n = e.get(\"WEBGL_compressed_texture_astc\")),\n              null !== n ? t : null)\n            : 36492 === t\n            ? ((n = e.get(\"EXT_texture_compression_bptc\")),\n              null !== n ? t : null)\n            : t === S\n            ? i\n              ? 34042\n              : ((n = e.get(\"WEBGL_depth_texture\")),\n                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)\n            : void 0;\n        },\n      };\n    }\n    class js extends Kn {\n      constructor(t = []) {\n        super(), (this.cameras = t);\n      }\n    }\n    js.prototype.isArrayCamera = !0;\n    class qs extends Fe {\n      constructor() {\n        super(), (this.type = \"Group\");\n      }\n    }\n    qs.prototype.isGroup = !0;\n    const Xs = { type: \"move\" };\n    class Ys {\n      constructor() {\n        (this._targetRay = null), (this._grip = null), (this._hand = null);\n      }\n      getHandSpace() {\n        return (\n          null === this._hand &&\n            ((this._hand = new qs()),\n            (this._hand.matrixAutoUpdate = !1),\n            (this._hand.visible = !1),\n            (this._hand.joints = {}),\n            (this._hand.inputState = { pinching: !1 })),\n          this._hand\n        );\n      }\n      getTargetRaySpace() {\n        return (\n          null === this._targetRay &&\n            ((this._targetRay = new qs()),\n            (this._targetRay.matrixAutoUpdate = !1),\n            (this._targetRay.visible = !1),\n            (this._targetRay.hasLinearVelocity = !1),\n            (this._targetRay.linearVelocity = new zt()),\n            (this._targetRay.hasAngularVelocity = !1),\n            (this._targetRay.angularVelocity = new zt())),\n          this._targetRay\n        );\n      }\n      getGripSpace() {\n        return (\n          null === this._grip &&\n            ((this._grip = new qs()),\n            (this._grip.matrixAutoUpdate = !1),\n            (this._grip.visible = !1),\n            (this._grip.hasLinearVelocity = !1),\n            (this._grip.linearVelocity = new zt()),\n            (this._grip.hasAngularVelocity = !1),\n            (this._grip.angularVelocity = new zt())),\n          this._grip\n        );\n      }\n      dispatchEvent(t) {\n        return (\n          null !== this._targetRay && this._targetRay.dispatchEvent(t),\n          null !== this._grip && this._grip.dispatchEvent(t),\n          null !== this._hand && this._hand.dispatchEvent(t),\n          this\n        );\n      }\n      disconnect(t) {\n        return (\n          this.dispatchEvent({ type: \"disconnected\", data: t }),\n          null !== this._targetRay && (this._targetRay.visible = !1),\n          null !== this._grip && (this._grip.visible = !1),\n          null !== this._hand && (this._hand.visible = !1),\n          this\n        );\n      }\n      update(t, e, n) {\n        let i = null,\n          r = null,\n          s = null;\n        const a = this._targetRay,\n          o = this._grip,\n          l = this._hand;\n        if (t && \"visible-blurred\" !== e.session.visibilityState)\n          if (\n            (null !== a &&\n              ((i = e.getPose(t.targetRaySpace, n)),\n              null !== i &&\n                (a.matrix.fromArray(i.transform.matrix),\n                a.matrix.decompose(a.position, a.rotation, a.scale),\n                i.linearVelocity\n                  ? ((a.hasLinearVelocity = !0),\n                    a.linearVelocity.copy(i.linearVelocity))\n                  : (a.hasLinearVelocity = !1),\n                i.angularVelocity\n                  ? ((a.hasAngularVelocity = !0),\n                    a.angularVelocity.copy(i.angularVelocity))\n                  : (a.hasAngularVelocity = !1),\n                this.dispatchEvent(Xs))),\n            l && t.hand)\n          ) {\n            s = !0;\n            for (const i of t.hand.values()) {\n              const t = e.getJointPose(i, n);\n              if (void 0 === l.joints[i.jointName]) {\n                const t = new qs();\n                (t.matrixAutoUpdate = !1),\n                  (t.visible = !1),\n                  (l.joints[i.jointName] = t),\n                  l.add(t);\n              }\n              const r = l.joints[i.jointName];\n              null !== t &&\n                (r.matrix.fromArray(t.transform.matrix),\n                r.matrix.decompose(r.position, r.rotation, r.scale),\n                (r.jointRadius = t.radius)),\n                (r.visible = null !== t);\n            }\n            const i = l.joints[\"index-finger-tip\"],\n              r = l.joints[\"thumb-tip\"],\n              a = i.position.distanceTo(r.position),\n              o = 0.02,\n              c = 0.005;\n            l.inputState.pinching && a > o + c\n              ? ((l.inputState.pinching = !1),\n                this.dispatchEvent({\n                  type: \"pinchend\",\n                  handedness: t.handedness,\n                  target: this,\n                }))\n              : !l.inputState.pinching &&\n                a <= o - c &&\n                ((l.inputState.pinching = !0),\n                this.dispatchEvent({\n                  type: \"pinchstart\",\n                  handedness: t.handedness,\n                  target: this,\n                }));\n          } else\n            null !== o &&\n              t.gripSpace &&\n              ((r = e.getPose(t.gripSpace, n)),\n              null !== r &&\n                (o.matrix.fromArray(r.transform.matrix),\n                o.matrix.decompose(o.position, o.rotation, o.scale),\n                r.linearVelocity\n                  ? ((o.hasLinearVelocity = !0),\n                    o.linearVelocity.copy(r.linearVelocity))\n                  : (o.hasLinearVelocity = !1),\n                r.angularVelocity\n                  ? ((o.hasAngularVelocity = !0),\n                    o.angularVelocity.copy(r.angularVelocity))\n                  : (o.hasAngularVelocity = !1)));\n        return (\n          null !== a && (a.visible = null !== i),\n          null !== o && (o.visible = null !== r),\n          null !== l && (l.visible = null !== s),\n          this\n        );\n      }\n    }\n    class Js extends rt {\n      constructor(t, e) {\n        super();\n        const n = this,\n          i = t.state;\n        let r = null,\n          s = 1,\n          a = null,\n          o = \"local-floor\",\n          l = null,\n          c = null,\n          h = null,\n          u = null,\n          d = null,\n          p = !1,\n          m = null,\n          f = null,\n          g = null,\n          v = null,\n          y = null,\n          x = null;\n        const _ = [],\n          M = new Map(),\n          b = new Kn();\n        b.layers.enable(1), (b.viewport = new Ct());\n        const w = new Kn();\n        w.layers.enable(2), (w.viewport = new Ct());\n        const S = [b, w],\n          T = new js();\n        T.layers.enable(1), T.layers.enable(2);\n        let E = null,\n          A = null;\n        function L(t) {\n          const e = M.get(t.inputSource);\n          e && e.dispatchEvent({ type: t.type, data: t.inputSource });\n        }\n        function R() {\n          M.forEach(function (t, e) {\n            t.disconnect(e);\n          }),\n            M.clear(),\n            (E = null),\n            (A = null),\n            i.bindXRFramebuffer(null),\n            t.setRenderTarget(t.getRenderTarget()),\n            h && e.deleteFramebuffer(h),\n            m && e.deleteFramebuffer(m),\n            f && e.deleteRenderbuffer(f),\n            g && e.deleteRenderbuffer(g),\n            (h = null),\n            (m = null),\n            (f = null),\n            (g = null),\n            (d = null),\n            (u = null),\n            (c = null),\n            (r = null),\n            z.stop(),\n            (n.isPresenting = !1),\n            n.dispatchEvent({ type: \"sessionend\" });\n        }\n        function C(t) {\n          const e = r.inputSources;\n          for (let t = 0; t < _.length; t++) M.set(e[t], _[t]);\n          for (let e = 0; e < t.removed.length; e++) {\n            const n = t.removed[e],\n              i = M.get(n);\n            i &&\n              (i.dispatchEvent({ type: \"disconnected\", data: n }), M.delete(n));\n          }\n          for (let e = 0; e < t.added.length; e++) {\n            const n = t.added[e],\n              i = M.get(n);\n            i && i.dispatchEvent({ type: \"connected\", data: n });\n          }\n        }\n        (this.cameraAutoUpdate = !0),\n          (this.enabled = !1),\n          (this.isPresenting = !1),\n          (this.getController = function (t) {\n            let e = _[t];\n            return (\n              void 0 === e && ((e = new Ys()), (_[t] = e)),\n              e.getTargetRaySpace()\n            );\n          }),\n          (this.getControllerGrip = function (t) {\n            let e = _[t];\n            return (\n              void 0 === e && ((e = new Ys()), (_[t] = e)), e.getGripSpace()\n            );\n          }),\n          (this.getHand = function (t) {\n            let e = _[t];\n            return (\n              void 0 === e && ((e = new Ys()), (_[t] = e)), e.getHandSpace()\n            );\n          }),\n          (this.setFramebufferScaleFactor = function (t) {\n            (s = t),\n              !0 === n.isPresenting &&\n                console.warn(\n                  \"THREE.WebXRManager: Cannot change framebuffer scale while presenting.\"\n                );\n          }),\n          (this.setReferenceSpaceType = function (t) {\n            (o = t),\n              !0 === n.isPresenting &&\n                console.warn(\n                  \"THREE.WebXRManager: Cannot change reference space type while presenting.\"\n                );\n          }),\n          (this.getReferenceSpace = function () {\n            return a;\n          }),\n          (this.getBaseLayer = function () {\n            return null !== u ? u : d;\n          }),\n          (this.getBinding = function () {\n            return c;\n          }),\n          (this.getFrame = function () {\n            return v;\n          }),\n          (this.getSession = function () {\n            return r;\n          }),\n          (this.setSession = async function (t) {\n            if (((r = t), null !== r)) {\n              r.addEventListener(\"select\", L),\n                r.addEventListener(\"selectstart\", L),\n                r.addEventListener(\"selectend\", L),\n                r.addEventListener(\"squeeze\", L),\n                r.addEventListener(\"squeezestart\", L),\n                r.addEventListener(\"squeezeend\", L),\n                r.addEventListener(\"end\", R),\n                r.addEventListener(\"inputsourceschange\", C);\n              const t = e.getContextAttributes();\n              if (\n                (!0 !== t.xrCompatible && (await e.makeXRCompatible()),\n                void 0 === r.renderState.layers)\n              ) {\n                const n = {\n                  antialias: t.antialias,\n                  alpha: t.alpha,\n                  depth: t.depth,\n                  stencil: t.stencil,\n                  framebufferScaleFactor: s,\n                };\n                (d = new XRWebGLLayer(r, e, n)),\n                  r.updateRenderState({ baseLayer: d });\n              } else if (e instanceof WebGLRenderingContext) {\n                const n = {\n                  antialias: !0,\n                  alpha: t.alpha,\n                  depth: t.depth,\n                  stencil: t.stencil,\n                  framebufferScaleFactor: s,\n                };\n                (d = new XRWebGLLayer(r, e, n)),\n                  r.updateRenderState({ layers: [d] });\n              } else {\n                p = t.antialias;\n                let n = null;\n                t.depth &&\n                  ((x = 256),\n                  t.stencil && (x |= 1024),\n                  (y = t.stencil ? 33306 : 36096),\n                  (n = t.stencil ? 35056 : 33190));\n                const a = {\n                  colorFormat: t.alpha ? 32856 : 32849,\n                  depthFormat: n,\n                  scaleFactor: s,\n                };\n                (c = new XRWebGLBinding(r, e)),\n                  (u = c.createProjectionLayer(a)),\n                  (h = e.createFramebuffer()),\n                  r.updateRenderState({ layers: [u] }),\n                  p &&\n                    ((m = e.createFramebuffer()),\n                    (f = e.createRenderbuffer()),\n                    e.bindRenderbuffer(36161, f),\n                    e.renderbufferStorageMultisample(\n                      36161,\n                      4,\n                      32856,\n                      u.textureWidth,\n                      u.textureHeight\n                    ),\n                    i.bindFramebuffer(36160, m),\n                    e.framebufferRenderbuffer(36160, 36064, 36161, f),\n                    e.bindRenderbuffer(36161, null),\n                    null !== n &&\n                      ((g = e.createRenderbuffer()),\n                      e.bindRenderbuffer(36161, g),\n                      e.renderbufferStorageMultisample(\n                        36161,\n                        4,\n                        n,\n                        u.textureWidth,\n                        u.textureHeight\n                      ),\n                      e.framebufferRenderbuffer(36160, y, 36161, g),\n                      e.bindRenderbuffer(36161, null)),\n                    i.bindFramebuffer(36160, null));\n              }\n              (a = await r.requestReferenceSpace(o)),\n                z.setContext(r),\n                z.start(),\n                (n.isPresenting = !0),\n                n.dispatchEvent({ type: \"sessionstart\" });\n            }\n          });\n        const P = new zt(),\n          I = new zt();\n        function D(t, e) {\n          null === e\n            ? t.matrixWorld.copy(t.matrix)\n            : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),\n            t.matrixWorldInverse.copy(t.matrixWorld).invert();\n        }\n        (this.updateCamera = function (t) {\n          if (null === r) return;\n          (T.near = w.near = b.near = t.near),\n            (T.far = w.far = b.far = t.far),\n            (E === T.near && A === T.far) ||\n              (r.updateRenderState({ depthNear: T.near, depthFar: T.far }),\n              (E = T.near),\n              (A = T.far));\n          const e = t.parent,\n            n = T.cameras;\n          D(T, e);\n          for (let t = 0; t < n.length; t++) D(n[t], e);\n          T.matrixWorld.decompose(T.position, T.quaternion, T.scale),\n            t.position.copy(T.position),\n            t.quaternion.copy(T.quaternion),\n            t.scale.copy(T.scale),\n            t.matrix.copy(T.matrix),\n            t.matrixWorld.copy(T.matrixWorld);\n          const i = t.children;\n          for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);\n          2 === n.length\n            ? (function (t, e, n) {\n                P.setFromMatrixPosition(e.matrixWorld),\n                  I.setFromMatrixPosition(n.matrixWorld);\n                const i = P.distanceTo(I),\n                  r = e.projectionMatrix.elements,\n                  s = n.projectionMatrix.elements,\n                  a = r[14] / (r[10] - 1),\n                  o = r[14] / (r[10] + 1),\n                  l = (r[9] + 1) / r[5],\n                  c = (r[9] - 1) / r[5],\n                  h = (r[8] - 1) / r[0],\n                  u = (s[8] + 1) / s[0],\n                  d = a * h,\n                  p = a * u,\n                  m = i / (-h + u),\n                  f = m * -h;\n                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),\n                  t.translateX(f),\n                  t.translateZ(m),\n                  t.matrixWorld.compose(t.position, t.quaternion, t.scale),\n                  t.matrixWorldInverse.copy(t.matrixWorld).invert();\n                const g = a + m,\n                  v = o + m,\n                  y = d - f,\n                  x = p + (i - f),\n                  _ = ((l * o) / v) * g,\n                  M = ((c * o) / v) * g;\n                t.projectionMatrix.makePerspective(y, x, _, M, g, v);\n              })(T, b, w)\n            : T.projectionMatrix.copy(b.projectionMatrix);\n        }),\n          (this.getCamera = function () {\n            return T;\n          }),\n          (this.getFoveation = function () {\n            return null !== u\n              ? u.fixedFoveation\n              : null !== d\n              ? d.fixedFoveation\n              : void 0;\n          }),\n          (this.setFoveation = function (t) {\n            null !== u && (u.fixedFoveation = t),\n              null !== d &&\n                void 0 !== d.fixedFoveation &&\n                (d.fixedFoveation = t);\n          });\n        let N = null;\n        const z = new hi();\n        z.setAnimationLoop(function (t, n) {\n          if (((l = n.getViewerPose(a)), (v = n), null !== l)) {\n            const t = l.views;\n            null !== d && i.bindXRFramebuffer(d.framebuffer);\n            let n = !1;\n            t.length !== T.cameras.length && ((T.cameras.length = 0), (n = !0));\n            for (let r = 0; r < t.length; r++) {\n              const s = t[r];\n              let a = null;\n              if (null !== d) a = d.getViewport(s);\n              else {\n                const t = c.getViewSubImage(u, s);\n                i.bindXRFramebuffer(h),\n                  void 0 !== t.depthStencilTexture &&\n                    e.framebufferTexture2D(\n                      36160,\n                      y,\n                      3553,\n                      t.depthStencilTexture,\n                      0\n                    ),\n                  e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0),\n                  (a = t.viewport);\n              }\n              const o = S[r];\n              o.matrix.fromArray(s.transform.matrix),\n                o.projectionMatrix.fromArray(s.projectionMatrix),\n                o.viewport.set(a.x, a.y, a.width, a.height),\n                0 === r && T.matrix.copy(o.matrix),\n                !0 === n && T.cameras.push(o);\n            }\n            p && (i.bindXRFramebuffer(m), null !== x && e.clear(x));\n          }\n          const s = r.inputSources;\n          for (let t = 0; t < _.length; t++) {\n            const e = _[t],\n              i = s[t];\n            e.update(i, n, a);\n          }\n          if ((N && N(t, n), p)) {\n            const t = u.textureWidth,\n              n = u.textureHeight;\n            i.bindFramebuffer(36008, m),\n              i.bindFramebuffer(36009, h),\n              e.invalidateFramebuffer(36008, [y]),\n              e.invalidateFramebuffer(36009, [y]),\n              e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728),\n              e.invalidateFramebuffer(36008, [36064]),\n              i.bindFramebuffer(36008, null),\n              i.bindFramebuffer(36009, null),\n              i.bindFramebuffer(36160, m);\n          }\n          v = null;\n        }),\n          (this.setAnimationLoop = function (t) {\n            N = t;\n          }),\n          (this.dispose = function () {});\n      }\n    }\n    function Zs(t) {\n      function e(e, n) {\n        (e.opacity.value = n.opacity),\n          n.color && e.diffuse.value.copy(n.color),\n          n.emissive &&\n            e.emissive.value\n              .copy(n.emissive)\n              .multiplyScalar(n.emissiveIntensity),\n          n.map && (e.map.value = n.map),\n          n.alphaMap && (e.alphaMap.value = n.alphaMap),\n          n.specularMap && (e.specularMap.value = n.specularMap),\n          n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);\n        const i = t.get(n).envMap;\n        if (i) {\n          (e.envMap.value = i),\n            (e.flipEnvMap.value =\n              i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),\n            (e.reflectivity.value = n.reflectivity),\n            (e.ior.value = n.ior),\n            (e.refractionRatio.value = n.refractionRatio);\n          const r = t.get(i).__maxMipLevel;\n          void 0 !== r && (e.maxMipLevel.value = r);\n        }\n        let r, s;\n        n.lightMap &&\n          ((e.lightMap.value = n.lightMap),\n          (e.lightMapIntensity.value = n.lightMapIntensity)),\n          n.aoMap &&\n            ((e.aoMap.value = n.aoMap),\n            (e.aoMapIntensity.value = n.aoMapIntensity)),\n          n.map\n            ? (r = n.map)\n            : n.specularMap\n            ? (r = n.specularMap)\n            : n.displacementMap\n            ? (r = n.displacementMap)\n            : n.normalMap\n            ? (r = n.normalMap)\n            : n.bumpMap\n            ? (r = n.bumpMap)\n            : n.roughnessMap\n            ? (r = n.roughnessMap)\n            : n.metalnessMap\n            ? (r = n.metalnessMap)\n            : n.alphaMap\n            ? (r = n.alphaMap)\n            : n.emissiveMap\n            ? (r = n.emissiveMap)\n            : n.clearcoatMap\n            ? (r = n.clearcoatMap)\n            : n.clearcoatNormalMap\n            ? (r = n.clearcoatNormalMap)\n            : n.clearcoatRoughnessMap\n            ? (r = n.clearcoatRoughnessMap)\n            : n.specularIntensityMap\n            ? (r = n.specularIntensityMap)\n            : n.specularColorMap\n            ? (r = n.specularColorMap)\n            : n.transmissionMap\n            ? (r = n.transmissionMap)\n            : n.thicknessMap\n            ? (r = n.thicknessMap)\n            : n.sheenColorMap\n            ? (r = n.sheenColorMap)\n            : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),\n          void 0 !== r &&\n            (r.isWebGLRenderTarget && (r = r.texture),\n            !0 === r.matrixAutoUpdate && r.updateMatrix(),\n            e.uvTransform.value.copy(r.matrix)),\n          n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),\n          void 0 !== s &&\n            (s.isWebGLRenderTarget && (s = s.texture),\n            !0 === s.matrixAutoUpdate && s.updateMatrix(),\n            e.uv2Transform.value.copy(s.matrix));\n      }\n      function n(e, n) {\n        (e.roughness.value = n.roughness),\n          (e.metalness.value = n.metalness),\n          n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),\n          n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),\n          n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),\n          n.bumpMap &&\n            ((e.bumpMap.value = n.bumpMap),\n            (e.bumpScale.value = n.bumpScale),\n            1 === n.side && (e.bumpScale.value *= -1)),\n          n.normalMap &&\n            ((e.normalMap.value = n.normalMap),\n            e.normalScale.value.copy(n.normalScale),\n            1 === n.side && e.normalScale.value.negate()),\n          n.displacementMap &&\n            ((e.displacementMap.value = n.displacementMap),\n            (e.displacementScale.value = n.displacementScale),\n            (e.displacementBias.value = n.displacementBias));\n        t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);\n      }\n      return {\n        refreshFogUniforms: function (t, e) {\n          t.fogColor.value.copy(e.color),\n            e.isFog\n              ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))\n              : e.isFogExp2 && (t.fogDensity.value = e.density);\n        },\n        refreshMaterialUniforms: function (t, i, r, s, a) {\n          i.isMeshBasicMaterial\n            ? e(t, i)\n            : i.isMeshLambertMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);\n              })(t, i))\n            : i.isMeshToonMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.gradientMap && (t.gradientMap.value = e.gradientMap);\n                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);\n                e.bumpMap &&\n                  ((t.bumpMap.value = e.bumpMap),\n                  (t.bumpScale.value = e.bumpScale),\n                  1 === e.side && (t.bumpScale.value *= -1));\n                e.normalMap &&\n                  ((t.normalMap.value = e.normalMap),\n                  t.normalScale.value.copy(e.normalScale),\n                  1 === e.side && t.normalScale.value.negate());\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n              })(t, i))\n            : i.isMeshPhongMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                t.specular.value.copy(e.specular),\n                  (t.shininess.value = Math.max(e.shininess, 1e-4)),\n                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);\n                e.bumpMap &&\n                  ((t.bumpMap.value = e.bumpMap),\n                  (t.bumpScale.value = e.bumpScale),\n                  1 === e.side && (t.bumpScale.value *= -1));\n                e.normalMap &&\n                  ((t.normalMap.value = e.normalMap),\n                  t.normalScale.value.copy(e.normalScale),\n                  1 === e.side && t.normalScale.value.negate());\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n              })(t, i))\n            : i.isMeshStandardMaterial\n            ? (e(t, i),\n              i.isMeshPhysicalMaterial\n                ? (function (t, e, i) {\n                    n(t, e),\n                      (t.ior.value = e.ior),\n                      e.sheen > 0 &&\n                        (t.sheenColor.value\n                          .copy(e.sheenColor)\n                          .multiplyScalar(e.sheen),\n                        (t.sheenRoughness.value = e.sheenRoughness),\n                        e.sheenColorMap &&\n                          (t.sheenColorMap.value = e.sheenColorMap),\n                        e.sheenRoughnessMap &&\n                          (t.sheenRoughnessMap.value = e.sheenRoughnessMap));\n                    e.clearcoat > 0 &&\n                      ((t.clearcoat.value = e.clearcoat),\n                      (t.clearcoatRoughness.value = e.clearcoatRoughness),\n                      e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),\n                      e.clearcoatRoughnessMap &&\n                        (t.clearcoatRoughnessMap.value =\n                          e.clearcoatRoughnessMap),\n                      e.clearcoatNormalMap &&\n                        (t.clearcoatNormalScale.value.copy(\n                          e.clearcoatNormalScale\n                        ),\n                        (t.clearcoatNormalMap.value = e.clearcoatNormalMap),\n                        1 === e.side && t.clearcoatNormalScale.value.negate()));\n                    e.transmission > 0 &&\n                      ((t.transmission.value = e.transmission),\n                      (t.transmissionSamplerMap.value = i.texture),\n                      t.transmissionSamplerSize.value.set(i.width, i.height),\n                      e.transmissionMap &&\n                        (t.transmissionMap.value = e.transmissionMap),\n                      (t.thickness.value = e.thickness),\n                      e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),\n                      (t.attenuationDistance.value = e.attenuationDistance),\n                      t.attenuationColor.value.copy(e.attenuationColor));\n                    (t.specularIntensity.value = e.specularIntensity),\n                      t.specularColor.value.copy(e.specularColor),\n                      e.specularIntensityMap &&\n                        (t.specularIntensityMap.value = e.specularIntensityMap);\n                    e.specularColorMap &&\n                      (t.specularColorMap.value = e.specularColorMap);\n                  })(t, i, a)\n                : n(t, i))\n            : i.isMeshMatcapMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.matcap && (t.matcap.value = e.matcap);\n                e.bumpMap &&\n                  ((t.bumpMap.value = e.bumpMap),\n                  (t.bumpScale.value = e.bumpScale),\n                  1 === e.side && (t.bumpScale.value *= -1));\n                e.normalMap &&\n                  ((t.normalMap.value = e.normalMap),\n                  t.normalScale.value.copy(e.normalScale),\n                  1 === e.side && t.normalScale.value.negate());\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n              })(t, i))\n            : i.isMeshDepthMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n              })(t, i))\n            : i.isMeshDistanceMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n                t.referencePosition.value.copy(e.referencePosition),\n                  (t.nearDistance.value = e.nearDistance),\n                  (t.farDistance.value = e.farDistance);\n              })(t, i))\n            : i.isMeshNormalMaterial\n            ? (e(t, i),\n              (function (t, e) {\n                e.bumpMap &&\n                  ((t.bumpMap.value = e.bumpMap),\n                  (t.bumpScale.value = e.bumpScale),\n                  1 === e.side && (t.bumpScale.value *= -1));\n                e.normalMap &&\n                  ((t.normalMap.value = e.normalMap),\n                  t.normalScale.value.copy(e.normalScale),\n                  1 === e.side && t.normalScale.value.negate());\n                e.displacementMap &&\n                  ((t.displacementMap.value = e.displacementMap),\n                  (t.displacementScale.value = e.displacementScale),\n                  (t.displacementBias.value = e.displacementBias));\n              })(t, i))\n            : i.isLineBasicMaterial\n            ? ((function (t, e) {\n                t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);\n              })(t, i),\n              i.isLineDashedMaterial &&\n                (function (t, e) {\n                  (t.dashSize.value = e.dashSize),\n                    (t.totalSize.value = e.dashSize + e.gapSize),\n                    (t.scale.value = e.scale);\n                })(t, i))\n            : i.isPointsMaterial\n            ? (function (t, e, n, i) {\n                t.diffuse.value.copy(e.color),\n                  (t.opacity.value = e.opacity),\n                  (t.size.value = e.size * n),\n                  (t.scale.value = 0.5 * i),\n                  e.map && (t.map.value = e.map);\n                e.alphaMap && (t.alphaMap.value = e.alphaMap);\n                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);\n                let r;\n                e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);\n                void 0 !== r &&\n                  (!0 === r.matrixAutoUpdate && r.updateMatrix(),\n                  t.uvTransform.value.copy(r.matrix));\n              })(t, i, r, s)\n            : i.isSpriteMaterial\n            ? (function (t, e) {\n                t.diffuse.value.copy(e.color),\n                  (t.opacity.value = e.opacity),\n                  (t.rotation.value = e.rotation),\n                  e.map && (t.map.value = e.map);\n                e.alphaMap && (t.alphaMap.value = e.alphaMap);\n                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);\n                let n;\n                e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);\n                void 0 !== n &&\n                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),\n                  t.uvTransform.value.copy(n.matrix));\n              })(t, i)\n            : i.isShadowMaterial\n            ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))\n            : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);\n        },\n      };\n    }\n    function Qs(t = {}) {\n      const e =\n          void 0 !== t.canvas\n            ? t.canvas\n            : (function () {\n                const t = wt(\"canvas\");\n                return (t.style.display = \"block\"), t;\n              })(),\n        n = void 0 !== t.context ? t.context : null,\n        i = void 0 !== t.alpha && t.alpha,\n        r = void 0 === t.depth || t.depth,\n        s = void 0 === t.stencil || t.stencil,\n        a = void 0 !== t.antialias && t.antialias,\n        o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,\n        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,\n        c = void 0 !== t.powerPreference ? t.powerPreference : \"default\",\n        h =\n          void 0 !== t.failIfMajorPerformanceCaveat &&\n          t.failIfMajorPerformanceCaveat;\n      let d = null,\n        m = null;\n      const f = [],\n        g = [];\n      (this.domElement = e),\n        (this.debug = { checkShaderErrors: !0 }),\n        (this.autoClear = !0),\n        (this.autoClearColor = !0),\n        (this.autoClearDepth = !0),\n        (this.autoClearStencil = !0),\n        (this.sortObjects = !0),\n        (this.clippingPlanes = []),\n        (this.localClippingEnabled = !1),\n        (this.gammaFactor = 2),\n        (this.outputEncoding = X),\n        (this.physicallyCorrectLights = !1),\n        (this.toneMapping = 0),\n        (this.toneMappingExposure = 1);\n      const v = this;\n      let _ = !1,\n        M = 0,\n        S = 0,\n        T = null,\n        A = -1,\n        L = null;\n      const R = new Ct(),\n        C = new Ct();\n      let P = null,\n        I = e.width,\n        D = e.height,\n        N = 1,\n        z = null,\n        B = null;\n      const F = new Ct(0, 0, I, D),\n        O = new Ct(0, 0, I, D);\n      let U = !1;\n      const H = [],\n        G = new ci();\n      let k = !1,\n        V = !1,\n        W = null;\n      const j = new de(),\n        q = new zt(),\n        Y = {\n          background: null,\n          fog: null,\n          environment: null,\n          overrideMaterial: null,\n          isScene: !0,\n        };\n      function J() {\n        return null === T ? N : 1;\n      }\n      let Z,\n        Q,\n        K,\n        $,\n        tt,\n        et,\n        nt,\n        it,\n        rt,\n        st,\n        at,\n        ot,\n        lt,\n        ct,\n        ht,\n        ut,\n        dt,\n        pt,\n        mt,\n        ft,\n        gt,\n        vt,\n        yt,\n        xt = n;\n      function _t(t, n) {\n        for (let i = 0; i < t.length; i++) {\n          const r = t[i],\n            s = e.getContext(r, n);\n          if (null !== s) return s;\n        }\n        return null;\n      }\n      try {\n        const t = {\n          alpha: i,\n          depth: r,\n          stencil: s,\n          antialias: a,\n          premultipliedAlpha: o,\n          preserveDrawingBuffer: l,\n          powerPreference: c,\n          failIfMajorPerformanceCaveat: h,\n        };\n        if (\n          (e.addEventListener(\"webglcontextlost\", St, !1),\n          e.addEventListener(\"webglcontextrestored\", Tt, !1),\n          null === xt)\n        ) {\n          const e = [\"webgl2\", \"webgl\", \"experimental-webgl\"];\n          if (\n            (!0 === v.isWebGL1Renderer && e.shift(),\n            (xt = _t(e, t)),\n            null === xt)\n          )\n            throw _t(e)\n              ? new Error(\n                  \"Error creating WebGL context with your selected attributes.\"\n                )\n              : new Error(\"Error creating WebGL context.\");\n        }\n        void 0 === xt.getShaderPrecisionFormat &&\n          (xt.getShaderPrecisionFormat = function () {\n            return { rangeMin: 1, rangeMax: 1, precision: 1 };\n          });\n      } catch (t) {\n        throw (console.error(\"THREE.WebGLRenderer: \" + t.message), t);\n      }\n      function Mt() {\n        (Z = new Yi(xt)),\n          (Q = new xi(xt, Z, t)),\n          Z.init(Q),\n          (vt = new Ws(xt, Z, Q)),\n          (K = new ks(xt, Z, Q)),\n          (H[0] = 1029),\n          ($ = new Qi(xt)),\n          (tt = new Ls()),\n          (et = new Vs(xt, Z, K, tt, Q, vt, $)),\n          (nt = new Mi(v)),\n          (it = new Xi(v)),\n          (rt = new ui(xt, Q)),\n          (yt = new vi(xt, Z, rt, Q)),\n          (st = new Ji(xt, rt, $, yt)),\n          (at = new ir(xt, st, rt, $)),\n          (mt = new nr(xt, Q, et)),\n          (ut = new _i(tt)),\n          (ot = new As(v, nt, it, Z, Q, yt, ut)),\n          (lt = new Zs(tt)),\n          (ct = new Is(tt)),\n          (ht = new Os(Z, Q)),\n          (pt = new gi(v, nt, K, at, o)),\n          (dt = new Gs(v, at, Q)),\n          (ft = new yi(xt, Z, $, Q)),\n          (gt = new Zi(xt, Z, $, Q)),\n          ($.programs = ot.programs),\n          (v.capabilities = Q),\n          (v.extensions = Z),\n          (v.properties = tt),\n          (v.renderLists = ct),\n          (v.shadowMap = dt),\n          (v.state = K),\n          (v.info = $);\n      }\n      Mt();\n      const bt = new Js(v, xt);\n      function St(t) {\n        t.preventDefault(),\n          console.log(\"THREE.WebGLRenderer: Context Lost.\"),\n          (_ = !0);\n      }\n      function Tt() {\n        console.log(\"THREE.WebGLRenderer: Context Restored.\"), (_ = !1);\n        const t = $.autoReset,\n          e = dt.enabled,\n          n = dt.autoUpdate,\n          i = dt.needsUpdate,\n          r = dt.type;\n        Mt(),\n          ($.autoReset = t),\n          (dt.enabled = e),\n          (dt.autoUpdate = n),\n          (dt.needsUpdate = i),\n          (dt.type = r);\n      }\n      function Et(t) {\n        const e = t.target;\n        e.removeEventListener(\"dispose\", Et),\n          (function (t) {\n            (function (t) {\n              const e = tt.get(t).programs;\n              void 0 !== e &&\n                e.forEach(function (t) {\n                  ot.releaseProgram(t);\n                });\n            })(t),\n              tt.remove(t);\n          })(e);\n      }\n      (this.xr = bt),\n        (this.getContext = function () {\n          return xt;\n        }),\n        (this.getContextAttributes = function () {\n          return xt.getContextAttributes();\n        }),\n        (this.forceContextLoss = function () {\n          const t = Z.get(\"WEBGL_lose_context\");\n          t && t.loseContext();\n        }),\n        (this.forceContextRestore = function () {\n          const t = Z.get(\"WEBGL_lose_context\");\n          t && t.restoreContext();\n        }),\n        (this.getPixelRatio = function () {\n          return N;\n        }),\n        (this.setPixelRatio = function (t) {\n          void 0 !== t && ((N = t), this.setSize(I, D, !1));\n        }),\n        (this.getSize = function (t) {\n          return t.set(I, D);\n        }),\n        (this.setSize = function (t, n, i) {\n          bt.isPresenting\n            ? console.warn(\n                \"THREE.WebGLRenderer: Can't change size while VR device is presenting.\"\n              )\n            : ((I = t),\n              (D = n),\n              (e.width = Math.floor(t * N)),\n              (e.height = Math.floor(n * N)),\n              !1 !== i &&\n                ((e.style.width = t + \"px\"), (e.style.height = n + \"px\")),\n              this.setViewport(0, 0, t, n));\n        }),\n        (this.getDrawingBufferSize = function (t) {\n          return t.set(I * N, D * N).floor();\n        }),\n        (this.setDrawingBufferSize = function (t, n, i) {\n          (I = t),\n            (D = n),\n            (N = i),\n            (e.width = Math.floor(t * i)),\n            (e.height = Math.floor(n * i)),\n            this.setViewport(0, 0, t, n);\n        }),\n        (this.getCurrentViewport = function (t) {\n          return t.copy(R);\n        }),\n        (this.getViewport = function (t) {\n          return t.copy(F);\n        }),\n        (this.setViewport = function (t, e, n, i) {\n          t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i),\n            K.viewport(R.copy(F).multiplyScalar(N).floor());\n        }),\n        (this.getScissor = function (t) {\n          return t.copy(O);\n        }),\n        (this.setScissor = function (t, e, n, i) {\n          t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i),\n            K.scissor(C.copy(O).multiplyScalar(N).floor());\n        }),\n        (this.getScissorTest = function () {\n          return U;\n        }),\n        (this.setScissorTest = function (t) {\n          K.setScissorTest((U = t));\n        }),\n        (this.setOpaqueSort = function (t) {\n          z = t;\n        }),\n        (this.setTransparentSort = function (t) {\n          B = t;\n        }),\n        (this.getClearColor = function (t) {\n          return t.copy(pt.getClearColor());\n        }),\n        (this.setClearColor = function () {\n          pt.setClearColor.apply(pt, arguments);\n        }),\n        (this.getClearAlpha = function () {\n          return pt.getClearAlpha();\n        }),\n        (this.setClearAlpha = function () {\n          pt.setClearAlpha.apply(pt, arguments);\n        }),\n        (this.clear = function (t, e, n) {\n          let i = 0;\n          (void 0 === t || t) && (i |= 16384),\n            (void 0 === e || e) && (i |= 256),\n            (void 0 === n || n) && (i |= 1024),\n            xt.clear(i);\n        }),\n        (this.clearColor = function () {\n          this.clear(!0, !1, !1);\n        }),\n        (this.clearDepth = function () {\n          this.clear(!1, !0, !1);\n        }),\n        (this.clearStencil = function () {\n          this.clear(!1, !1, !0);\n        }),\n        (this.dispose = function () {\n          e.removeEventListener(\"webglcontextlost\", St, !1),\n            e.removeEventListener(\"webglcontextrestored\", Tt, !1),\n            ct.dispose(),\n            ht.dispose(),\n            tt.dispose(),\n            nt.dispose(),\n            it.dispose(),\n            at.dispose(),\n            yt.dispose(),\n            bt.dispose(),\n            bt.removeEventListener(\"sessionstart\", Lt),\n            bt.removeEventListener(\"sessionend\", Rt),\n            W && (W.dispose(), (W = null)),\n            It.stop();\n        }),\n        (this.renderBufferDirect = function (t, e, n, i, r, s) {\n          null === e && (e = Y);\n          const a = r.isMesh && r.matrixWorld.determinant() < 0,\n            o = (function (t, e, n, i, r) {\n              !0 !== e.isScene && (e = Y);\n              et.resetTextureUnits();\n              const s = e.fog,\n                a = i.isMeshStandardMaterial ? e.environment : null,\n                o = null === T ? v.outputEncoding : T.texture.encoding,\n                l = (i.isMeshStandardMaterial ? it : nt).get(i.envMap || a),\n                c =\n                  !0 === i.vertexColors &&\n                  !!n.attributes.color &&\n                  4 === n.attributes.color.itemSize,\n                h = !!i.normalMap && !!n.attributes.tangent,\n                u = !!n.morphAttributes.position,\n                d = !!n.morphAttributes.normal,\n                p = n.morphAttributes.position\n                  ? n.morphAttributes.position.length\n                  : 0,\n                f = tt.get(i),\n                g = m.state.lights;\n              if (!0 === k && (!0 === V || t !== L)) {\n                const e = t === L && i.id === A;\n                ut.setState(i, t, e);\n              }\n              let y = !1;\n              i.version === f.__version\n                ? (f.needsLights && f.lightsStateVersion !== g.state.version) ||\n                  f.outputEncoding !== o ||\n                  (r.isInstancedMesh && !1 === f.instancing)\n                  ? (y = !0)\n                  : r.isInstancedMesh || !0 !== f.instancing\n                  ? r.isSkinnedMesh && !1 === f.skinning\n                    ? (y = !0)\n                    : r.isSkinnedMesh || !0 !== f.skinning\n                    ? f.envMap !== l || (i.fog && f.fog !== s)\n                      ? (y = !0)\n                      : void 0 === f.numClippingPlanes ||\n                        (f.numClippingPlanes === ut.numPlanes &&\n                          f.numIntersection === ut.numIntersection)\n                      ? (f.vertexAlphas !== c ||\n                          f.vertexTangents !== h ||\n                          f.morphTargets !== u ||\n                          f.morphNormals !== d ||\n                          (!0 === Q.isWebGL2 && f.morphTargetsCount !== p)) &&\n                        (y = !0)\n                      : (y = !0)\n                    : (y = !0)\n                  : (y = !0)\n                : ((y = !0), (f.__version = i.version));\n              let x = f.currentProgram;\n              !0 === y && (x = Ut(i, e, r));\n              let _ = !1,\n                M = !1,\n                b = !1;\n              const w = x.getUniforms(),\n                S = f.uniforms;\n              K.useProgram(x.program) && ((_ = !0), (M = !0), (b = !0));\n              i.id !== A && ((A = i.id), (M = !0));\n              if (_ || L !== t) {\n                if (\n                  (w.setValue(xt, \"projectionMatrix\", t.projectionMatrix),\n                  Q.logarithmicDepthBuffer &&\n                    w.setValue(\n                      xt,\n                      \"logDepthBufFC\",\n                      2 / (Math.log(t.far + 1) / Math.LN2)\n                    ),\n                  L !== t && ((L = t), (M = !0), (b = !0)),\n                  i.isShaderMaterial ||\n                    i.isMeshPhongMaterial ||\n                    i.isMeshToonMaterial ||\n                    i.isMeshStandardMaterial ||\n                    i.envMap)\n                ) {\n                  const e = w.map.cameraPosition;\n                  void 0 !== e &&\n                    e.setValue(xt, q.setFromMatrixPosition(t.matrixWorld));\n                }\n                (i.isMeshPhongMaterial ||\n                  i.isMeshToonMaterial ||\n                  i.isMeshLambertMaterial ||\n                  i.isMeshBasicMaterial ||\n                  i.isMeshStandardMaterial ||\n                  i.isShaderMaterial) &&\n                  w.setValue(\n                    xt,\n                    \"isOrthographic\",\n                    !0 === t.isOrthographicCamera\n                  ),\n                  (i.isMeshPhongMaterial ||\n                    i.isMeshToonMaterial ||\n                    i.isMeshLambertMaterial ||\n                    i.isMeshBasicMaterial ||\n                    i.isMeshStandardMaterial ||\n                    i.isShaderMaterial ||\n                    i.isShadowMaterial ||\n                    r.isSkinnedMesh) &&\n                    w.setValue(xt, \"viewMatrix\", t.matrixWorldInverse);\n              }\n              if (r.isSkinnedMesh) {\n                w.setOptional(xt, r, \"bindMatrix\"),\n                  w.setOptional(xt, r, \"bindMatrixInverse\");\n                const t = r.skeleton;\n                t &&\n                  (Q.floatVertexTextures\n                    ? (null === t.boneTexture && t.computeBoneTexture(),\n                      w.setValue(xt, \"boneTexture\", t.boneTexture, et),\n                      w.setValue(xt, \"boneTextureSize\", t.boneTextureSize))\n                    : w.setOptional(xt, t, \"boneMatrices\"));\n              }\n              !n ||\n                (void 0 === n.morphAttributes.position &&\n                  void 0 === n.morphAttributes.normal) ||\n                mt.update(r, n, i, x);\n              (M || f.receiveShadow !== r.receiveShadow) &&\n                ((f.receiveShadow = r.receiveShadow),\n                w.setValue(xt, \"receiveShadow\", r.receiveShadow));\n              M &&\n                (w.setValue(xt, \"toneMappingExposure\", v.toneMappingExposure),\n                f.needsLights &&\n                  ((R = b),\n                  ((E = S).ambientLightColor.needsUpdate = R),\n                  (E.lightProbe.needsUpdate = R),\n                  (E.directionalLights.needsUpdate = R),\n                  (E.directionalLightShadows.needsUpdate = R),\n                  (E.pointLights.needsUpdate = R),\n                  (E.pointLightShadows.needsUpdate = R),\n                  (E.spotLights.needsUpdate = R),\n                  (E.spotLightShadows.needsUpdate = R),\n                  (E.rectAreaLights.needsUpdate = R),\n                  (E.hemisphereLights.needsUpdate = R)),\n                s && i.fog && lt.refreshFogUniforms(S, s),\n                lt.refreshMaterialUniforms(S, i, N, D, W),\n                as.upload(xt, f.uniformsList, S, et));\n              var E, R;\n              i.isShaderMaterial &&\n                !0 === i.uniformsNeedUpdate &&\n                (as.upload(xt, f.uniformsList, S, et),\n                (i.uniformsNeedUpdate = !1));\n              i.isSpriteMaterial && w.setValue(xt, \"center\", r.center);\n              return (\n                w.setValue(xt, \"modelViewMatrix\", r.modelViewMatrix),\n                w.setValue(xt, \"normalMatrix\", r.normalMatrix),\n                w.setValue(xt, \"modelMatrix\", r.matrixWorld),\n                x\n              );\n            })(t, e, n, i, r);\n          K.setMaterial(i, a);\n          let l = n.index;\n          const c = n.attributes.position;\n          if (null === l) {\n            if (void 0 === c || 0 === c.count) return;\n          } else if (0 === l.count) return;\n          let h,\n            u = 1;\n          !0 === i.wireframe && ((l = st.getWireframeAttribute(n)), (u = 2)),\n            yt.setup(r, i, o, n, l);\n          let d = ft;\n          null !== l && ((h = rt.get(l)), (d = gt), d.setIndex(h));\n          const p = null !== l ? l.count : c.count,\n            f = n.drawRange.start * u,\n            g = n.drawRange.count * u,\n            y = null !== s ? s.start * u : 0,\n            x = null !== s ? s.count * u : 1 / 0,\n            _ = Math.max(f, y),\n            M = Math.min(p, f + g, y + x) - 1,\n            b = Math.max(0, M - _ + 1);\n          if (0 !== b) {\n            if (r.isMesh)\n              !0 === i.wireframe\n                ? (K.setLineWidth(i.wireframeLinewidth * J()), d.setMode(1))\n                : d.setMode(4);\n            else if (r.isLine) {\n              let t = i.linewidth;\n              void 0 === t && (t = 1),\n                K.setLineWidth(t * J()),\n                r.isLineSegments\n                  ? d.setMode(1)\n                  : r.isLineLoop\n                  ? d.setMode(2)\n                  : d.setMode(3);\n            } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);\n            if (r.isInstancedMesh) d.renderInstances(_, b, r.count);\n            else if (n.isInstancedBufferGeometry) {\n              const t = Math.min(n.instanceCount, n._maxInstanceCount);\n              d.renderInstances(_, b, t);\n            } else d.render(_, b);\n          }\n        }),\n        (this.compile = function (t, e) {\n          (m = ht.get(t)),\n            m.init(),\n            g.push(m),\n            t.traverseVisible(function (t) {\n              t.isLight &&\n                t.layers.test(e.layers) &&\n                (m.pushLight(t), t.castShadow && m.pushShadow(t));\n            }),\n            m.setupLights(v.physicallyCorrectLights),\n            t.traverse(function (e) {\n              const n = e.material;\n              if (n)\n                if (Array.isArray(n))\n                  for (let i = 0; i < n.length; i++) {\n                    Ut(n[i], t, e);\n                  }\n                else Ut(n, t, e);\n            }),\n            g.pop(),\n            (m = null);\n        });\n      let At = null;\n      function Lt() {\n        It.stop();\n      }\n      function Rt() {\n        It.start();\n      }\n      const It = new hi();\n      function Nt(t, e, n, i) {\n        if (!1 === t.visible) return;\n        if (t.layers.test(e.layers))\n          if (t.isGroup) n = t.renderOrder;\n          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);\n          else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);\n          else if (t.isSprite) {\n            if (!t.frustumCulled || G.intersectsSprite(t)) {\n              i && q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);\n              const e = at.update(t),\n                r = t.material;\n              r.visible && d.push(t, e, r, n, q.z, null);\n            }\n          } else if (\n            (t.isMesh || t.isLine || t.isPoints) &&\n            (t.isSkinnedMesh &&\n              t.skeleton.frame !== $.render.frame &&\n              (t.skeleton.update(), (t.skeleton.frame = $.render.frame)),\n            !t.frustumCulled || G.intersectsObject(t))\n          ) {\n            i && q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);\n            const e = at.update(t),\n              r = t.material;\n            if (Array.isArray(r)) {\n              const i = e.groups;\n              for (let s = 0, a = i.length; s < a; s++) {\n                const a = i[s],\n                  o = r[a.materialIndex];\n                o && o.visible && d.push(t, e, o, n, q.z, a);\n              }\n            } else r.visible && d.push(t, e, r, n, q.z, null);\n          }\n        const r = t.children;\n        for (let t = 0, s = r.length; t < s; t++) Nt(r[t], e, n, i);\n      }\n      function Bt(t, e, n, i) {\n        const r = t.opaque,\n          s = t.transmissive,\n          o = t.transparent;\n        m.setupLightsView(n),\n          s.length > 0 &&\n            (function (t, e, n) {\n              if (null === W) {\n                const t = !0 === a && !0 === Q.isWebGL2;\n                W = new (t ? Dt : Pt)(1024, 1024, {\n                  generateMipmaps: !0,\n                  type: null !== vt.convert(w) ? w : x,\n                  minFilter: y,\n                  magFilter: p,\n                  wrapS: u,\n                  wrapT: u,\n                });\n              }\n              const i = v.getRenderTarget();\n              v.setRenderTarget(W), v.clear();\n              const r = v.toneMapping;\n              (v.toneMapping = 0),\n                Ft(t, e, n),\n                (v.toneMapping = r),\n                et.updateMultisampleRenderTarget(W),\n                et.updateRenderTargetMipmap(W),\n                v.setRenderTarget(i);\n            })(r, e, n),\n          i && K.viewport(R.copy(i)),\n          r.length > 0 && Ft(r, e, n),\n          s.length > 0 && Ft(s, e, n),\n          o.length > 0 && Ft(o, e, n);\n      }\n      function Ft(t, e, n) {\n        const i = !0 === e.isScene ? e.overrideMaterial : null;\n        for (let r = 0, s = t.length; r < s; r++) {\n          const s = t[r],\n            a = s.object,\n            o = s.geometry,\n            l = null === i ? s.material : i,\n            c = s.group;\n          a.layers.test(n.layers) && Ot(a, e, n, o, l, c);\n        }\n      }\n      function Ot(t, e, n, i, r, s) {\n        t.onBeforeRender(v, e, n, i, r, s),\n          t.modelViewMatrix.multiplyMatrices(\n            n.matrixWorldInverse,\n            t.matrixWorld\n          ),\n          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),\n          r.onBeforeRender(v, e, n, i, t, s),\n          !0 === r.transparent && 2 === r.side\n            ? ((r.side = 1),\n              (r.needsUpdate = !0),\n              v.renderBufferDirect(n, e, i, r, t, s),\n              (r.side = 0),\n              (r.needsUpdate = !0),\n              v.renderBufferDirect(n, e, i, r, t, s),\n              (r.side = 2))\n            : v.renderBufferDirect(n, e, i, r, t, s),\n          t.onAfterRender(v, e, n, i, r, s);\n      }\n      function Ut(t, e, n) {\n        !0 !== e.isScene && (e = Y);\n        const i = tt.get(t),\n          r = m.state.lights,\n          s = m.state.shadowsArray,\n          a = r.state.version,\n          o = ot.getParameters(t, r.state, s, e, n),\n          l = ot.getProgramCacheKey(o);\n        let c = i.programs;\n        (i.environment = t.isMeshStandardMaterial ? e.environment : null),\n          (i.fog = e.fog),\n          (i.envMap = (t.isMeshStandardMaterial ? it : nt).get(\n            t.envMap || i.environment\n          )),\n          void 0 === c &&\n            (t.addEventListener(\"dispose\", Et),\n            (c = new Map()),\n            (i.programs = c));\n        let h = c.get(l);\n        if (void 0 !== h) {\n          if (i.currentProgram === h && i.lightsStateVersion === a)\n            return Ht(t, o), h;\n        } else (o.uniforms = ot.getUniforms(t)), t.onBuild(n, o, v), t.onBeforeCompile(o, v), (h = ot.acquireProgram(o, l)), c.set(l, h), (i.uniforms = o.uniforms);\n        const u = i.uniforms;\n        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||\n          (u.clippingPlanes = ut.uniform),\n          Ht(t, o),\n          (i.needsLights = (function (t) {\n            return (\n              t.isMeshLambertMaterial ||\n              t.isMeshToonMaterial ||\n              t.isMeshPhongMaterial ||\n              t.isMeshStandardMaterial ||\n              t.isShadowMaterial ||\n              (t.isShaderMaterial && !0 === t.lights)\n            );\n          })(t)),\n          (i.lightsStateVersion = a),\n          i.needsLights &&\n            ((u.ambientLightColor.value = r.state.ambient),\n            (u.lightProbe.value = r.state.probe),\n            (u.directionalLights.value = r.state.directional),\n            (u.directionalLightShadows.value = r.state.directionalShadow),\n            (u.spotLights.value = r.state.spot),\n            (u.spotLightShadows.value = r.state.spotShadow),\n            (u.rectAreaLights.value = r.state.rectArea),\n            (u.ltc_1.value = r.state.rectAreaLTC1),\n            (u.ltc_2.value = r.state.rectAreaLTC2),\n            (u.pointLights.value = r.state.point),\n            (u.pointLightShadows.value = r.state.pointShadow),\n            (u.hemisphereLights.value = r.state.hemi),\n            (u.directionalShadowMap.value = r.state.directionalShadowMap),\n            (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),\n            (u.spotShadowMap.value = r.state.spotShadowMap),\n            (u.spotShadowMatrix.value = r.state.spotShadowMatrix),\n            (u.pointShadowMap.value = r.state.pointShadowMap),\n            (u.pointShadowMatrix.value = r.state.pointShadowMatrix));\n        const d = h.getUniforms(),\n          p = as.seqWithValue(d.seq, u);\n        return (i.currentProgram = h), (i.uniformsList = p), h;\n      }\n      function Ht(t, e) {\n        const n = tt.get(t);\n        (n.outputEncoding = e.outputEncoding),\n          (n.instancing = e.instancing),\n          (n.skinning = e.skinning),\n          (n.morphTargets = e.morphTargets),\n          (n.morphNormals = e.morphNormals),\n          (n.morphTargetsCount = e.morphTargetsCount),\n          (n.numClippingPlanes = e.numClippingPlanes),\n          (n.numIntersection = e.numClipIntersection),\n          (n.vertexAlphas = e.vertexAlphas),\n          (n.vertexTangents = e.vertexTangents);\n      }\n      It.setAnimationLoop(function (t) {\n        At && At(t);\n      }),\n        \"undefined\" != typeof window && It.setContext(window),\n        (this.setAnimationLoop = function (t) {\n          (At = t), bt.setAnimationLoop(t), null === t ? It.stop() : It.start();\n        }),\n        bt.addEventListener(\"sessionstart\", Lt),\n        bt.addEventListener(\"sessionend\", Rt),\n        (this.render = function (t, e) {\n          if (void 0 !== e && !0 !== e.isCamera)\n            return void console.error(\n              \"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\"\n            );\n          if (!0 === _) return;\n          !0 === t.autoUpdate && t.updateMatrixWorld(),\n            null === e.parent && e.updateMatrixWorld(),\n            !0 === bt.enabled &&\n              !0 === bt.isPresenting &&\n              (!0 === bt.cameraAutoUpdate && bt.updateCamera(e),\n              (e = bt.getCamera())),\n            !0 === t.isScene && t.onBeforeRender(v, t, e, T),\n            (m = ht.get(t, g.length)),\n            m.init(),\n            g.push(m),\n            j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),\n            G.setFromProjectionMatrix(j),\n            (V = this.localClippingEnabled),\n            (k = ut.init(this.clippingPlanes, V, e)),\n            (d = ct.get(t, f.length)),\n            d.init(),\n            f.push(d),\n            Nt(t, e, 0, v.sortObjects),\n            d.finish(),\n            !0 === v.sortObjects && d.sort(z, B),\n            !0 === k && ut.beginShadows();\n          const n = m.state.shadowsArray;\n          if (\n            (dt.render(n, t, e),\n            !0 === k && ut.endShadows(),\n            !0 === this.info.autoReset && this.info.reset(),\n            pt.render(d, t),\n            m.setupLights(v.physicallyCorrectLights),\n            e.isArrayCamera)\n          ) {\n            const n = e.cameras;\n            for (let e = 0, i = n.length; e < i; e++) {\n              const i = n[e];\n              Bt(d, t, i, i.viewport);\n            }\n          } else Bt(d, t, e);\n          null !== T &&\n            (et.updateMultisampleRenderTarget(T),\n            et.updateRenderTargetMipmap(T)),\n            !0 === t.isScene && t.onAfterRender(v, t, e),\n            K.buffers.depth.setTest(!0),\n            K.buffers.depth.setMask(!0),\n            K.buffers.color.setMask(!0),\n            K.setPolygonOffset(!1),\n            yt.resetDefaultState(),\n            (A = -1),\n            (L = null),\n            g.pop(),\n            (m = g.length > 0 ? g[g.length - 1] : null),\n            f.pop(),\n            (d = f.length > 0 ? f[f.length - 1] : null);\n        }),\n        (this.getActiveCubeFace = function () {\n          return M;\n        }),\n        (this.getActiveMipmapLevel = function () {\n          return S;\n        }),\n        (this.getRenderTarget = function () {\n          return T;\n        }),\n        (this.setRenderTarget = function (t, e = 0, n = 0) {\n          (T = t),\n            (M = e),\n            (S = n),\n            t &&\n              void 0 === tt.get(t).__webglFramebuffer &&\n              et.setupRenderTarget(t);\n          let i = null,\n            r = !1,\n            s = !1;\n          if (t) {\n            const n = t.texture;\n            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);\n            const a = tt.get(t).__webglFramebuffer;\n            t.isWebGLCubeRenderTarget\n              ? ((i = a[e]), (r = !0))\n              : (i = t.isWebGLMultisampleRenderTarget\n                  ? tt.get(t).__webglMultisampledFramebuffer\n                  : a),\n              R.copy(t.viewport),\n              C.copy(t.scissor),\n              (P = t.scissorTest);\n          } else\n            R.copy(F).multiplyScalar(N).floor(),\n              C.copy(O).multiplyScalar(N).floor(),\n              (P = U);\n          if (K.bindFramebuffer(36160, i) && Q.drawBuffers) {\n            let e = !1;\n            if (t)\n              if (t.isWebGLMultipleRenderTargets) {\n                const n = t.texture;\n                if (H.length !== n.length || 36064 !== H[0]) {\n                  for (let t = 0, e = n.length; t < e; t++) H[t] = 36064 + t;\n                  (H.length = n.length), (e = !0);\n                }\n              } else\n                (1 === H.length && 36064 === H[0]) ||\n                  ((H[0] = 36064), (H.length = 1), (e = !0));\n            else\n              (1 === H.length && 1029 === H[0]) ||\n                ((H[0] = 1029), (H.length = 1), (e = !0));\n            e &&\n              (Q.isWebGL2\n                ? xt.drawBuffers(H)\n                : Z.get(\"WEBGL_draw_buffers\").drawBuffersWEBGL(H));\n          }\n          if ((K.viewport(R), K.scissor(C), K.setScissorTest(P), r)) {\n            const i = tt.get(t.texture);\n            xt.framebufferTexture2D(\n              36160,\n              36064,\n              34069 + e,\n              i.__webglTexture,\n              n\n            );\n          } else if (s) {\n            const i = tt.get(t.texture),\n              r = e || 0;\n            xt.framebufferTextureLayer(\n              36160,\n              36064,\n              i.__webglTexture,\n              n || 0,\n              r\n            );\n          }\n          A = -1;\n        }),\n        (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {\n          if (!t || !t.isWebGLRenderTarget)\n            return void console.error(\n              \"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\"\n            );\n          let o = tt.get(t).__webglFramebuffer;\n          if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {\n            K.bindFramebuffer(36160, o);\n            try {\n              const a = t.texture,\n                o = a.format,\n                l = a.type;\n              if (o !== E && vt.convert(o) !== xt.getParameter(35739))\n                return void console.error(\n                  \"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\"\n                );\n              const c =\n                l === w &&\n                (Z.has(\"EXT_color_buffer_half_float\") ||\n                  (Q.isWebGL2 && Z.has(\"EXT_color_buffer_float\")));\n              if (\n                !(\n                  l === x ||\n                  vt.convert(l) === xt.getParameter(35738) ||\n                  (l === b &&\n                    (Q.isWebGL2 ||\n                      Z.has(\"OES_texture_float\") ||\n                      Z.has(\"WEBGL_color_buffer_float\"))) ||\n                  c\n                )\n              )\n                return void console.error(\n                  \"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\"\n                );\n              36053 === xt.checkFramebufferStatus(36160)\n                ? e >= 0 &&\n                  e <= t.width - i &&\n                  n >= 0 &&\n                  n <= t.height - r &&\n                  xt.readPixels(e, n, i, r, vt.convert(o), vt.convert(l), s)\n                : console.error(\n                    \"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.\"\n                  );\n            } finally {\n              const t = null !== T ? tt.get(T).__webglFramebuffer : null;\n              K.bindFramebuffer(36160, t);\n            }\n          }\n        }),\n        (this.copyFramebufferToTexture = function (t, e, n = 0) {\n          const i = Math.pow(2, -n),\n            r = Math.floor(e.image.width * i),\n            s = Math.floor(e.image.height * i);\n          let a = vt.convert(e.format);\n          Q.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),\n            et.setTexture2D(e, 0),\n            xt.copyTexImage2D(3553, n, a, t.x, t.y, r, s, 0),\n            K.unbindTexture();\n        }),\n        (this.copyTextureToTexture = function (t, e, n, i = 0) {\n          const r = e.image.width,\n            s = e.image.height,\n            a = vt.convert(n.format),\n            o = vt.convert(n.type);\n          et.setTexture2D(n, 0),\n            xt.pixelStorei(37440, n.flipY),\n            xt.pixelStorei(37441, n.premultiplyAlpha),\n            xt.pixelStorei(3317, n.unpackAlignment),\n            e.isDataTexture\n              ? xt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data)\n              : e.isCompressedTexture\n              ? xt.compressedTexSubImage2D(\n                  3553,\n                  i,\n                  t.x,\n                  t.y,\n                  e.mipmaps[0].width,\n                  e.mipmaps[0].height,\n                  a,\n                  e.mipmaps[0].data\n                )\n              : xt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image),\n            0 === i && n.generateMipmaps && xt.generateMipmap(3553),\n            K.unbindTexture();\n        }),\n        (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {\n          if (v.isWebGL1Renderer)\n            return void console.warn(\n              \"THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.\"\n            );\n          const s = t.max.x - t.min.x + 1,\n            a = t.max.y - t.min.y + 1,\n            o = t.max.z - t.min.z + 1,\n            l = vt.convert(i.format),\n            c = vt.convert(i.type);\n          let h;\n          if (i.isDataTexture3D) et.setTexture3D(i, 0), (h = 32879);\n          else {\n            if (!i.isDataTexture2DArray)\n              return void console.warn(\n                \"THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.\"\n              );\n            et.setTexture2DArray(i, 0), (h = 35866);\n          }\n          xt.pixelStorei(37440, i.flipY),\n            xt.pixelStorei(37441, i.premultiplyAlpha),\n            xt.pixelStorei(3317, i.unpackAlignment);\n          const u = xt.getParameter(3314),\n            d = xt.getParameter(32878),\n            p = xt.getParameter(3316),\n            m = xt.getParameter(3315),\n            f = xt.getParameter(32877),\n            g = n.isCompressedTexture ? n.mipmaps[0] : n.image;\n          xt.pixelStorei(3314, g.width),\n            xt.pixelStorei(32878, g.height),\n            xt.pixelStorei(3316, t.min.x),\n            xt.pixelStorei(3315, t.min.y),\n            xt.pixelStorei(32877, t.min.z),\n            n.isDataTexture || n.isDataTexture3D\n              ? xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data)\n              : n.isCompressedTexture\n              ? (console.warn(\n                  \"THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.\"\n                ),\n                xt.compressedTexSubImage3D(\n                  h,\n                  r,\n                  e.x,\n                  e.y,\n                  e.z,\n                  s,\n                  a,\n                  o,\n                  l,\n                  g.data\n                ))\n              : xt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g),\n            xt.pixelStorei(3314, u),\n            xt.pixelStorei(32878, d),\n            xt.pixelStorei(3316, p),\n            xt.pixelStorei(3315, m),\n            xt.pixelStorei(32877, f),\n            0 === r && i.generateMipmaps && xt.generateMipmap(h),\n            K.unbindTexture();\n        }),\n        (this.initTexture = function (t) {\n          et.setTexture2D(t, 0), K.unbindTexture();\n        }),\n        (this.resetState = function () {\n          (M = 0), (S = 0), (T = null), K.reset(), yt.reset();\n        }),\n        \"undefined\" != typeof __THREE_DEVTOOLS__ &&\n          __THREE_DEVTOOLS__.dispatchEvent(\n            new CustomEvent(\"observe\", { detail: this })\n          );\n    }\n    Qs.prototype.isWebGLRenderer = !0;\n    class Ks extends Qs {}\n    Ks.prototype.isWebGL1Renderer = !0;\n    class $s {\n      constructor(t, e = 25e-5) {\n        (this.name = \"\"), (this.color = new rn(t)), (this.density = e);\n      }\n      clone() {\n        return new $s(this.color, this.density);\n      }\n      toJSON() {\n        return {\n          type: \"FogExp2\",\n          color: this.color.getHex(),\n          density: this.density,\n        };\n      }\n    }\n    $s.prototype.isFogExp2 = !0;\n    class ta {\n      constructor(t, e = 1, n = 1e3) {\n        (this.name = \"\"),\n          (this.color = new rn(t)),\n          (this.near = e),\n          (this.far = n);\n      }\n      clone() {\n        return new ta(this.color, this.near, this.far);\n      }\n      toJSON() {\n        return {\n          type: \"Fog\",\n          color: this.color.getHex(),\n          near: this.near,\n          far: this.far,\n        };\n      }\n    }\n    ta.prototype.isFog = !0;\n    class ea extends Fe {\n      constructor() {\n        super(),\n          (this.type = \"Scene\"),\n          (this.background = null),\n          (this.environment = null),\n          (this.fog = null),\n          (this.overrideMaterial = null),\n          (this.autoUpdate = !0),\n          \"undefined\" != typeof __THREE_DEVTOOLS__ &&\n            __THREE_DEVTOOLS__.dispatchEvent(\n              new CustomEvent(\"observe\", { detail: this })\n            );\n      }\n      copy(t, e) {\n        return (\n          super.copy(t, e),\n          null !== t.background && (this.background = t.background.clone()),\n          null !== t.environment && (this.environment = t.environment.clone()),\n          null !== t.fog && (this.fog = t.fog.clone()),\n          null !== t.overrideMaterial &&\n            (this.overrideMaterial = t.overrideMaterial.clone()),\n          (this.autoUpdate = t.autoUpdate),\n          (this.matrixAutoUpdate = t.matrixAutoUpdate),\n          this\n        );\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;\n      }\n    }\n    ea.prototype.isScene = !0;\n    class na {\n      constructor(t, e) {\n        (this.array = t),\n          (this.stride = e),\n          (this.count = void 0 !== t ? t.length / e : 0),\n          (this.usage = et),\n          (this.updateRange = { offset: 0, count: -1 }),\n          (this.version = 0),\n          (this.uuid = ht());\n      }\n      onUploadCallback() {}\n      set needsUpdate(t) {\n        !0 === t && this.version++;\n      }\n      setUsage(t) {\n        return (this.usage = t), this;\n      }\n      copy(t) {\n        return (\n          (this.array = new t.array.constructor(t.array)),\n          (this.count = t.count),\n          (this.stride = t.stride),\n          (this.usage = t.usage),\n          this\n        );\n      }\n      copyAt(t, e, n) {\n        (t *= this.stride), (n *= e.stride);\n        for (let i = 0, r = this.stride; i < r; i++)\n          this.array[t + i] = e.array[n + i];\n        return this;\n      }\n      set(t, e = 0) {\n        return this.array.set(t, e), this;\n      }\n      clone(t) {\n        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),\n          void 0 === this.array.buffer._uuid &&\n            (this.array.buffer._uuid = ht()),\n          void 0 === t.arrayBuffers[this.array.buffer._uuid] &&\n            (t.arrayBuffers[this.array.buffer._uuid] =\n              this.array.slice(0).buffer);\n        const e = new this.array.constructor(\n            t.arrayBuffers[this.array.buffer._uuid]\n          ),\n          n = new this.constructor(e, this.stride);\n        return n.setUsage(this.usage), n;\n      }\n      onUpload(t) {\n        return (this.onUploadCallback = t), this;\n      }\n      toJSON(t) {\n        return (\n          void 0 === t.arrayBuffers && (t.arrayBuffers = {}),\n          void 0 === this.array.buffer._uuid &&\n            (this.array.buffer._uuid = ht()),\n          void 0 === t.arrayBuffers[this.array.buffer._uuid] &&\n            (t.arrayBuffers[this.array.buffer._uuid] =\n              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),\n          {\n            uuid: this.uuid,\n            buffer: this.array.buffer._uuid,\n            type: this.array.constructor.name,\n            stride: this.stride,\n          }\n        );\n      }\n    }\n    na.prototype.isInterleavedBuffer = !0;\n    const ia = new zt();\n    class ra {\n      constructor(t, e, n, i = !1) {\n        (this.name = \"\"),\n          (this.data = t),\n          (this.itemSize = e),\n          (this.offset = n),\n          (this.normalized = !0 === i);\n      }\n      get count() {\n        return this.data.count;\n      }\n      get array() {\n        return this.data.array;\n      }\n      set needsUpdate(t) {\n        this.data.needsUpdate = t;\n      }\n      applyMatrix4(t) {\n        for (let e = 0, n = this.data.count; e < n; e++)\n          (ia.x = this.getX(e)),\n            (ia.y = this.getY(e)),\n            (ia.z = this.getZ(e)),\n            ia.applyMatrix4(t),\n            this.setXYZ(e, ia.x, ia.y, ia.z);\n        return this;\n      }\n      applyNormalMatrix(t) {\n        for (let e = 0, n = this.count; e < n; e++)\n          (ia.x = this.getX(e)),\n            (ia.y = this.getY(e)),\n            (ia.z = this.getZ(e)),\n            ia.applyNormalMatrix(t),\n            this.setXYZ(e, ia.x, ia.y, ia.z);\n        return this;\n      }\n      transformDirection(t) {\n        for (let e = 0, n = this.count; e < n; e++)\n          (ia.x = this.getX(e)),\n            (ia.y = this.getY(e)),\n            (ia.z = this.getZ(e)),\n            ia.transformDirection(t),\n            this.setXYZ(e, ia.x, ia.y, ia.z);\n        return this;\n      }\n      setX(t, e) {\n        return (this.data.array[t * this.data.stride + this.offset] = e), this;\n      }\n      setY(t, e) {\n        return (\n          (this.data.array[t * this.data.stride + this.offset + 1] = e), this\n        );\n      }\n      setZ(t, e) {\n        return (\n          (this.data.array[t * this.data.stride + this.offset + 2] = e), this\n        );\n      }\n      setW(t, e) {\n        return (\n          (this.data.array[t * this.data.stride + this.offset + 3] = e), this\n        );\n      }\n      getX(t) {\n        return this.data.array[t * this.data.stride + this.offset];\n      }\n      getY(t) {\n        return this.data.array[t * this.data.stride + this.offset + 1];\n      }\n      getZ(t) {\n        return this.data.array[t * this.data.stride + this.offset + 2];\n      }\n      getW(t) {\n        return this.data.array[t * this.data.stride + this.offset + 3];\n      }\n      setXY(t, e, n) {\n        return (\n          (t = t * this.data.stride + this.offset),\n          (this.data.array[t + 0] = e),\n          (this.data.array[t + 1] = n),\n          this\n        );\n      }\n      setXYZ(t, e, n, i) {\n        return (\n          (t = t * this.data.stride + this.offset),\n          (this.data.array[t + 0] = e),\n          (this.data.array[t + 1] = n),\n          (this.data.array[t + 2] = i),\n          this\n        );\n      }\n      setXYZW(t, e, n, i, r) {\n        return (\n          (t = t * this.data.stride + this.offset),\n          (this.data.array[t + 0] = e),\n          (this.data.array[t + 1] = n),\n          (this.data.array[t + 2] = i),\n          (this.data.array[t + 3] = r),\n          this\n        );\n      }\n      clone(t) {\n        if (void 0 === t) {\n          console.log(\n            \"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.\"\n          );\n          const t = [];\n          for (let e = 0; e < this.count; e++) {\n            const n = e * this.data.stride + this.offset;\n            for (let e = 0; e < this.itemSize; e++)\n              t.push(this.data.array[n + e]);\n          }\n          return new ln(\n            new this.array.constructor(t),\n            this.itemSize,\n            this.normalized\n          );\n        }\n        return (\n          void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),\n          void 0 === t.interleavedBuffers[this.data.uuid] &&\n            (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),\n          new ra(\n            t.interleavedBuffers[this.data.uuid],\n            this.itemSize,\n            this.offset,\n            this.normalized\n          )\n        );\n      }\n      toJSON(t) {\n        if (void 0 === t) {\n          console.log(\n            \"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.\"\n          );\n          const t = [];\n          for (let e = 0; e < this.count; e++) {\n            const n = e * this.data.stride + this.offset;\n            for (let e = 0; e < this.itemSize; e++)\n              t.push(this.data.array[n + e]);\n          }\n          return {\n            itemSize: this.itemSize,\n            type: this.array.constructor.name,\n            array: t,\n            normalized: this.normalized,\n          };\n        }\n        return (\n          void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),\n          void 0 === t.interleavedBuffers[this.data.uuid] &&\n            (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),\n          {\n            isInterleavedBufferAttribute: !0,\n            itemSize: this.itemSize,\n            data: this.data.uuid,\n            offset: this.offset,\n            normalized: this.normalized,\n          }\n        );\n      }\n    }\n    ra.prototype.isInterleavedBufferAttribute = !0;\n    class sa extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"SpriteMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.map = null),\n          (this.alphaMap = null),\n          (this.rotation = 0),\n          (this.sizeAttenuation = !0),\n          (this.transparent = !0),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.map = t.map),\n          (this.alphaMap = t.alphaMap),\n          (this.rotation = t.rotation),\n          (this.sizeAttenuation = t.sizeAttenuation),\n          this\n        );\n      }\n    }\n    let aa;\n    sa.prototype.isSpriteMaterial = !0;\n    const oa = new zt(),\n      la = new zt(),\n      ca = new zt(),\n      ha = new yt(),\n      ua = new yt(),\n      da = new de(),\n      pa = new zt(),\n      ma = new zt(),\n      fa = new zt(),\n      ga = new yt(),\n      va = new yt(),\n      ya = new yt();\n    class xa extends Fe {\n      constructor(t) {\n        if ((super(), (this.type = \"Sprite\"), void 0 === aa)) {\n          aa = new En();\n          const t = new Float32Array([\n              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,\n              0.5, 0, 0, 1,\n            ]),\n            e = new na(t, 5);\n          aa.setIndex([0, 1, 2, 0, 2, 3]),\n            aa.setAttribute(\"position\", new ra(e, 3, 0, !1)),\n            aa.setAttribute(\"uv\", new ra(e, 2, 3, !1));\n        }\n        (this.geometry = aa),\n          (this.material = void 0 !== t ? t : new sa()),\n          (this.center = new yt(0.5, 0.5));\n      }\n      raycast(t, e) {\n        null === t.camera &&\n          console.error(\n            'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.'\n          ),\n          la.setFromMatrixScale(this.matrixWorld),\n          da.copy(t.camera.matrixWorld),\n          this.modelViewMatrix.multiplyMatrices(\n            t.camera.matrixWorldInverse,\n            this.matrixWorld\n          ),\n          ca.setFromMatrixPosition(this.modelViewMatrix),\n          t.camera.isPerspectiveCamera &&\n            !1 === this.material.sizeAttenuation &&\n            la.multiplyScalar(-ca.z);\n        const n = this.material.rotation;\n        let i, r;\n        0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));\n        const s = this.center;\n        _a(pa.set(-0.5, -0.5, 0), ca, s, la, i, r),\n          _a(ma.set(0.5, -0.5, 0), ca, s, la, i, r),\n          _a(fa.set(0.5, 0.5, 0), ca, s, la, i, r),\n          ga.set(0, 0),\n          va.set(1, 0),\n          ya.set(1, 1);\n        let a = t.ray.intersectTriangle(pa, ma, fa, !1, oa);\n        if (\n          null === a &&\n          (_a(ma.set(-0.5, 0.5, 0), ca, s, la, i, r),\n          va.set(0, 1),\n          (a = t.ray.intersectTriangle(pa, fa, ma, !1, oa)),\n          null === a)\n        )\n          return;\n        const o = t.ray.origin.distanceTo(oa);\n        o < t.near ||\n          o > t.far ||\n          e.push({\n            distance: o,\n            point: oa.clone(),\n            uv: Ye.getUV(oa, pa, ma, fa, ga, va, ya, new yt()),\n            face: null,\n            object: this,\n          });\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          void 0 !== t.center && this.center.copy(t.center),\n          (this.material = t.material),\n          this\n        );\n      }\n    }\n    function _a(t, e, n, i, r, s) {\n      ha.subVectors(t, n).addScalar(0.5).multiply(i),\n        void 0 !== r\n          ? ((ua.x = s * ha.x - r * ha.y), (ua.y = r * ha.x + s * ha.y))\n          : ua.copy(ha),\n        t.copy(e),\n        (t.x += ua.x),\n        (t.y += ua.y),\n        t.applyMatrix4(da);\n    }\n    xa.prototype.isSprite = !0;\n    const Ma = new zt(),\n      ba = new zt();\n    class wa extends Fe {\n      constructor() {\n        super(),\n          (this._currentLevel = 0),\n          (this.type = \"LOD\"),\n          Object.defineProperties(this, {\n            levels: { enumerable: !0, value: [] },\n            isLOD: { value: !0 },\n          }),\n          (this.autoUpdate = !0);\n      }\n      copy(t) {\n        super.copy(t, !1);\n        const e = t.levels;\n        for (let t = 0, n = e.length; t < n; t++) {\n          const n = e[t];\n          this.addLevel(n.object.clone(), n.distance);\n        }\n        return (this.autoUpdate = t.autoUpdate), this;\n      }\n      addLevel(t, e = 0) {\n        e = Math.abs(e);\n        const n = this.levels;\n        let i;\n        for (i = 0; i < n.length && !(e < n[i].distance); i++);\n        return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;\n      }\n      getCurrentLevel() {\n        return this._currentLevel;\n      }\n      getObjectForDistance(t) {\n        const e = this.levels;\n        if (e.length > 0) {\n          let n, i;\n          for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);\n          return e[n - 1].object;\n        }\n        return null;\n      }\n      raycast(t, e) {\n        if (this.levels.length > 0) {\n          Ma.setFromMatrixPosition(this.matrixWorld);\n          const n = t.ray.origin.distanceTo(Ma);\n          this.getObjectForDistance(n).raycast(t, e);\n        }\n      }\n      update(t) {\n        const e = this.levels;\n        if (e.length > 1) {\n          Ma.setFromMatrixPosition(t.matrixWorld),\n            ba.setFromMatrixPosition(this.matrixWorld);\n          const n = Ma.distanceTo(ba) / t.zoom;\n          let i, r;\n          for (\n            e[0].object.visible = !0, i = 1, r = e.length;\n            i < r && n >= e[i].distance;\n            i++\n          )\n            (e[i - 1].object.visible = !1), (e[i].object.visible = !0);\n          for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;\n        }\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        !1 === this.autoUpdate && (e.object.autoUpdate = !1),\n          (e.object.levels = []);\n        const n = this.levels;\n        for (let t = 0, i = n.length; t < i; t++) {\n          const i = n[t];\n          e.object.levels.push({ object: i.object.uuid, distance: i.distance });\n        }\n        return e;\n      }\n    }\n    const Sa = new zt(),\n      Ta = new Ct(),\n      Ea = new Ct(),\n      Aa = new zt(),\n      La = new de();\n    class Ra extends Wn {\n      constructor(t, e) {\n        super(t, e),\n          (this.type = \"SkinnedMesh\"),\n          (this.bindMode = \"attached\"),\n          (this.bindMatrix = new de()),\n          (this.bindMatrixInverse = new de());\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.bindMode = t.bindMode),\n          this.bindMatrix.copy(t.bindMatrix),\n          this.bindMatrixInverse.copy(t.bindMatrixInverse),\n          (this.skeleton = t.skeleton),\n          this\n        );\n      }\n      bind(t, e) {\n        (this.skeleton = t),\n          void 0 === e &&\n            (this.updateMatrixWorld(!0),\n            this.skeleton.calculateInverses(),\n            (e = this.matrixWorld)),\n          this.bindMatrix.copy(e),\n          this.bindMatrixInverse.copy(e).invert();\n      }\n      pose() {\n        this.skeleton.pose();\n      }\n      normalizeSkinWeights() {\n        const t = new Ct(),\n          e = this.geometry.attributes.skinWeight;\n        for (let n = 0, i = e.count; n < i; n++) {\n          (t.x = e.getX(n)),\n            (t.y = e.getY(n)),\n            (t.z = e.getZ(n)),\n            (t.w = e.getW(n));\n          const i = 1 / t.manhattanLength();\n          i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),\n            e.setXYZW(n, t.x, t.y, t.z, t.w);\n        }\n      }\n      updateMatrixWorld(t) {\n        super.updateMatrixWorld(t),\n          \"attached\" === this.bindMode\n            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()\n            : \"detached\" === this.bindMode\n            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()\n            : console.warn(\n                \"THREE.SkinnedMesh: Unrecognized bindMode: \" + this.bindMode\n              );\n      }\n      boneTransform(t, e) {\n        const n = this.skeleton,\n          i = this.geometry;\n        Ta.fromBufferAttribute(i.attributes.skinIndex, t),\n          Ea.fromBufferAttribute(i.attributes.skinWeight, t),\n          Sa.copy(e).applyMatrix4(this.bindMatrix),\n          e.set(0, 0, 0);\n        for (let t = 0; t < 4; t++) {\n          const i = Ea.getComponent(t);\n          if (0 !== i) {\n            const r = Ta.getComponent(t);\n            La.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),\n              e.addScaledVector(Aa.copy(Sa).applyMatrix4(La), i);\n          }\n        }\n        return e.applyMatrix4(this.bindMatrixInverse);\n      }\n    }\n    Ra.prototype.isSkinnedMesh = !0;\n    class Ca extends Fe {\n      constructor() {\n        super(), (this.type = \"Bone\");\n      }\n    }\n    Ca.prototype.isBone = !0;\n    class Pa extends Lt {\n      constructor(\n        t = null,\n        e = 1,\n        n = 1,\n        i,\n        r,\n        s,\n        a,\n        o,\n        l = 1003,\n        c = 1003,\n        h,\n        u\n      ) {\n        super(null, s, a, o, l, c, i, r, h, u),\n          (this.image = { data: t, width: e, height: n }),\n          (this.magFilter = l),\n          (this.minFilter = c),\n          (this.generateMipmaps = !1),\n          (this.flipY = !1),\n          (this.unpackAlignment = 1),\n          (this.needsUpdate = !0);\n      }\n    }\n    Pa.prototype.isDataTexture = !0;\n    const Ia = new de(),\n      Da = new de();\n    class Na {\n      constructor(t = [], e = []) {\n        (this.uuid = ht()),\n          (this.bones = t.slice(0)),\n          (this.boneInverses = e),\n          (this.boneMatrices = null),\n          (this.boneTexture = null),\n          (this.boneTextureSize = 0),\n          (this.frame = -1),\n          this.init();\n      }\n      init() {\n        const t = this.bones,\n          e = this.boneInverses;\n        if (\n          ((this.boneMatrices = new Float32Array(16 * t.length)),\n          0 === e.length)\n        )\n          this.calculateInverses();\n        else if (t.length !== e.length) {\n          console.warn(\n            \"THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.\"\n          ),\n            (this.boneInverses = []);\n          for (let t = 0, e = this.bones.length; t < e; t++)\n            this.boneInverses.push(new de());\n        }\n      }\n      calculateInverses() {\n        this.boneInverses.length = 0;\n        for (let t = 0, e = this.bones.length; t < e; t++) {\n          const e = new de();\n          this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),\n            this.boneInverses.push(e);\n        }\n      }\n      pose() {\n        for (let t = 0, e = this.bones.length; t < e; t++) {\n          const e = this.bones[t];\n          e && e.matrixWorld.copy(this.boneInverses[t]).invert();\n        }\n        for (let t = 0, e = this.bones.length; t < e; t++) {\n          const e = this.bones[t];\n          e &&\n            (e.parent && e.parent.isBone\n              ? (e.matrix.copy(e.parent.matrixWorld).invert(),\n                e.matrix.multiply(e.matrixWorld))\n              : e.matrix.copy(e.matrixWorld),\n            e.matrix.decompose(e.position, e.quaternion, e.scale));\n        }\n      }\n      update() {\n        const t = this.bones,\n          e = this.boneInverses,\n          n = this.boneMatrices,\n          i = this.boneTexture;\n        for (let i = 0, r = t.length; i < r; i++) {\n          const r = t[i] ? t[i].matrixWorld : Da;\n          Ia.multiplyMatrices(r, e[i]), Ia.toArray(n, 16 * i);\n        }\n        null !== i && (i.needsUpdate = !0);\n      }\n      clone() {\n        return new Na(this.bones, this.boneInverses);\n      }\n      computeBoneTexture() {\n        let t = Math.sqrt(4 * this.bones.length);\n        (t = ft(t)), (t = Math.max(t, 4));\n        const e = new Float32Array(t * t * 4);\n        e.set(this.boneMatrices);\n        const n = new Pa(e, t, t, E, b);\n        return (\n          (this.boneMatrices = e),\n          (this.boneTexture = n),\n          (this.boneTextureSize = t),\n          this\n        );\n      }\n      getBoneByName(t) {\n        for (let e = 0, n = this.bones.length; e < n; e++) {\n          const n = this.bones[e];\n          if (n.name === t) return n;\n        }\n      }\n      dispose() {\n        null !== this.boneTexture &&\n          (this.boneTexture.dispose(), (this.boneTexture = null));\n      }\n      fromJSON(t, e) {\n        this.uuid = t.uuid;\n        for (let n = 0, i = t.bones.length; n < i; n++) {\n          const i = t.bones[n];\n          let r = e[i];\n          void 0 === r &&\n            (console.warn(\"THREE.Skeleton: No bone found with UUID:\", i),\n            (r = new Ca())),\n            this.bones.push(r),\n            this.boneInverses.push(new de().fromArray(t.boneInverses[n]));\n        }\n        return this.init(), this;\n      }\n      toJSON() {\n        const t = {\n          metadata: {\n            version: 4.5,\n            type: \"Skeleton\",\n            generator: \"Skeleton.toJSON\",\n          },\n          bones: [],\n          boneInverses: [],\n        };\n        t.uuid = this.uuid;\n        const e = this.bones,\n          n = this.boneInverses;\n        for (let i = 0, r = e.length; i < r; i++) {\n          const r = e[i];\n          t.bones.push(r.uuid);\n          const s = n[i];\n          t.boneInverses.push(s.toArray());\n        }\n        return t;\n      }\n    }\n    class za extends ln {\n      constructor(t, e, n, i = 1) {\n        \"number\" == typeof n &&\n          ((i = n),\n          (n = !1),\n          console.error(\n            \"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.\"\n          )),\n          super(t, e, n),\n          (this.meshPerAttribute = i);\n      }\n      copy(t) {\n        return (\n          super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.meshPerAttribute = this.meshPerAttribute),\n          (t.isInstancedBufferAttribute = !0),\n          t\n        );\n      }\n    }\n    za.prototype.isInstancedBufferAttribute = !0;\n    const Ba = new de(),\n      Fa = new de(),\n      Oa = [],\n      Ua = new Wn();\n    class Ha extends Wn {\n      constructor(t, e, n) {\n        super(t, e),\n          (this.instanceMatrix = new za(new Float32Array(16 * n), 16)),\n          (this.instanceColor = null),\n          (this.count = n),\n          (this.frustumCulled = !1);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.instanceMatrix.copy(t.instanceMatrix),\n          null !== t.instanceColor &&\n            (this.instanceColor = t.instanceColor.clone()),\n          (this.count = t.count),\n          this\n        );\n      }\n      getColorAt(t, e) {\n        e.fromArray(this.instanceColor.array, 3 * t);\n      }\n      getMatrixAt(t, e) {\n        e.fromArray(this.instanceMatrix.array, 16 * t);\n      }\n      raycast(t, e) {\n        const n = this.matrixWorld,\n          i = this.count;\n        if (\n          ((Ua.geometry = this.geometry),\n          (Ua.material = this.material),\n          void 0 !== Ua.material)\n        )\n          for (let r = 0; r < i; r++) {\n            this.getMatrixAt(r, Ba),\n              Fa.multiplyMatrices(n, Ba),\n              (Ua.matrixWorld = Fa),\n              Ua.raycast(t, Oa);\n            for (let t = 0, n = Oa.length; t < n; t++) {\n              const n = Oa[t];\n              (n.instanceId = r), (n.object = this), e.push(n);\n            }\n            Oa.length = 0;\n          }\n      }\n      setColorAt(t, e) {\n        null === this.instanceColor &&\n          (this.instanceColor = new za(\n            new Float32Array(3 * this.instanceMatrix.count),\n            3\n          )),\n          e.toArray(this.instanceColor.array, 3 * t);\n      }\n      setMatrixAt(t, e) {\n        e.toArray(this.instanceMatrix.array, 16 * t);\n      }\n      updateMorphTargets() {}\n      dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n      }\n    }\n    Ha.prototype.isInstancedMesh = !0;\n    class Ga extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"LineBasicMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.linewidth = 1),\n          (this.linecap = \"round\"),\n          (this.linejoin = \"round\"),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.linewidth = t.linewidth),\n          (this.linecap = t.linecap),\n          (this.linejoin = t.linejoin),\n          this\n        );\n      }\n    }\n    Ga.prototype.isLineBasicMaterial = !0;\n    const ka = new zt(),\n      Va = new zt(),\n      Wa = new de(),\n      ja = new ue(),\n      qa = new ie();\n    class Xa extends Fe {\n      constructor(t = new En(), e = new Ga()) {\n        super(),\n          (this.type = \"Line\"),\n          (this.geometry = t),\n          (this.material = e),\n          this.updateMorphTargets();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.material = t.material),\n          (this.geometry = t.geometry),\n          this\n        );\n      }\n      computeLineDistances() {\n        const t = this.geometry;\n        if (t.isBufferGeometry)\n          if (null === t.index) {\n            const e = t.attributes.position,\n              n = [0];\n            for (let t = 1, i = e.count; t < i; t++)\n              ka.fromBufferAttribute(e, t - 1),\n                Va.fromBufferAttribute(e, t),\n                (n[t] = n[t - 1]),\n                (n[t] += ka.distanceTo(Va));\n            t.setAttribute(\"lineDistance\", new vn(n, 1));\n          } else\n            console.warn(\n              \"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\"\n            );\n        else\n          t.isGeometry &&\n            console.error(\n              \"THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\"\n            );\n        return this;\n      }\n      raycast(t, e) {\n        const n = this.geometry,\n          i = this.matrixWorld,\n          r = t.params.Line.threshold,\n          s = n.drawRange;\n        if (\n          (null === n.boundingSphere && n.computeBoundingSphere(),\n          qa.copy(n.boundingSphere),\n          qa.applyMatrix4(i),\n          (qa.radius += r),\n          !1 === t.ray.intersectsSphere(qa))\n        )\n          return;\n        Wa.copy(i).invert(), ja.copy(t.ray).applyMatrix4(Wa);\n        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),\n          o = a * a,\n          l = new zt(),\n          c = new zt(),\n          h = new zt(),\n          u = new zt(),\n          d = this.isLineSegments ? 2 : 1;\n        if (n.isBufferGeometry) {\n          const i = n.index,\n            r = n.attributes.position;\n          if (null !== i) {\n            for (\n              let n = Math.max(0, s.start),\n                a = Math.min(i.count, s.start + s.count) - 1;\n              n < a;\n              n += d\n            ) {\n              const s = i.getX(n),\n                a = i.getX(n + 1);\n              l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);\n              if (ja.distanceSqToSegment(l, c, u, h) > o) continue;\n              u.applyMatrix4(this.matrixWorld);\n              const d = t.ray.origin.distanceTo(u);\n              d < t.near ||\n                d > t.far ||\n                e.push({\n                  distance: d,\n                  point: h.clone().applyMatrix4(this.matrixWorld),\n                  index: n,\n                  face: null,\n                  faceIndex: null,\n                  object: this,\n                });\n            }\n          } else {\n            for (\n              let n = Math.max(0, s.start),\n                i = Math.min(r.count, s.start + s.count) - 1;\n              n < i;\n              n += d\n            ) {\n              l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);\n              if (ja.distanceSqToSegment(l, c, u, h) > o) continue;\n              u.applyMatrix4(this.matrixWorld);\n              const i = t.ray.origin.distanceTo(u);\n              i < t.near ||\n                i > t.far ||\n                e.push({\n                  distance: i,\n                  point: h.clone().applyMatrix4(this.matrixWorld),\n                  index: n,\n                  face: null,\n                  faceIndex: null,\n                  object: this,\n                });\n            }\n          }\n        } else n.isGeometry && console.error(\"THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n      updateMorphTargets() {\n        const t = this.geometry;\n        if (t.isBufferGeometry) {\n          const e = t.morphAttributes,\n            n = Object.keys(e);\n          if (n.length > 0) {\n            const t = e[n[0]];\n            if (void 0 !== t) {\n              (this.morphTargetInfluences = []),\n                (this.morphTargetDictionary = {});\n              for (let e = 0, n = t.length; e < n; e++) {\n                const n = t[e].name || String(e);\n                this.morphTargetInfluences.push(0),\n                  (this.morphTargetDictionary[n] = e);\n              }\n            }\n          }\n        } else {\n          const e = t.morphTargets;\n          void 0 !== e &&\n            e.length > 0 &&\n            console.error(\n              \"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.\"\n            );\n        }\n      }\n    }\n    Xa.prototype.isLine = !0;\n    const Ya = new zt(),\n      Ja = new zt();\n    class Za extends Xa {\n      constructor(t, e) {\n        super(t, e), (this.type = \"LineSegments\");\n      }\n      computeLineDistances() {\n        const t = this.geometry;\n        if (t.isBufferGeometry)\n          if (null === t.index) {\n            const e = t.attributes.position,\n              n = [];\n            for (let t = 0, i = e.count; t < i; t += 2)\n              Ya.fromBufferAttribute(e, t),\n                Ja.fromBufferAttribute(e, t + 1),\n                (n[t] = 0 === t ? 0 : n[t - 1]),\n                (n[t + 1] = n[t] + Ya.distanceTo(Ja));\n            t.setAttribute(\"lineDistance\", new vn(n, 1));\n          } else\n            console.warn(\n              \"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\"\n            );\n        else\n          t.isGeometry &&\n            console.error(\n              \"THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\"\n            );\n        return this;\n      }\n    }\n    Za.prototype.isLineSegments = !0;\n    class Qa extends Xa {\n      constructor(t, e) {\n        super(t, e), (this.type = \"LineLoop\");\n      }\n    }\n    Qa.prototype.isLineLoop = !0;\n    class Ka extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"PointsMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.map = null),\n          (this.alphaMap = null),\n          (this.size = 1),\n          (this.sizeAttenuation = !0),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.map = t.map),\n          (this.alphaMap = t.alphaMap),\n          (this.size = t.size),\n          (this.sizeAttenuation = t.sizeAttenuation),\n          this\n        );\n      }\n    }\n    Ka.prototype.isPointsMaterial = !0;\n    const $a = new de(),\n      to = new ue(),\n      eo = new ie(),\n      no = new zt();\n    class io extends Fe {\n      constructor(t = new En(), e = new Ka()) {\n        super(),\n          (this.type = \"Points\"),\n          (this.geometry = t),\n          (this.material = e),\n          this.updateMorphTargets();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.material = t.material),\n          (this.geometry = t.geometry),\n          this\n        );\n      }\n      raycast(t, e) {\n        const n = this.geometry,\n          i = this.matrixWorld,\n          r = t.params.Points.threshold,\n          s = n.drawRange;\n        if (\n          (null === n.boundingSphere && n.computeBoundingSphere(),\n          eo.copy(n.boundingSphere),\n          eo.applyMatrix4(i),\n          (eo.radius += r),\n          !1 === t.ray.intersectsSphere(eo))\n        )\n          return;\n        $a.copy(i).invert(), to.copy(t.ray).applyMatrix4($a);\n        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),\n          o = a * a;\n        if (n.isBufferGeometry) {\n          const r = n.index,\n            a = n.attributes.position;\n          if (null !== r) {\n            for (\n              let n = Math.max(0, s.start),\n                l = Math.min(r.count, s.start + s.count);\n              n < l;\n              n++\n            ) {\n              const s = r.getX(n);\n              no.fromBufferAttribute(a, s), ro(no, s, o, i, t, e, this);\n            }\n          } else {\n            for (\n              let n = Math.max(0, s.start),\n                r = Math.min(a.count, s.start + s.count);\n              n < r;\n              n++\n            )\n              no.fromBufferAttribute(a, n), ro(no, n, o, i, t, e, this);\n          }\n        } else console.error(\"THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n      updateMorphTargets() {\n        const t = this.geometry;\n        if (t.isBufferGeometry) {\n          const e = t.morphAttributes,\n            n = Object.keys(e);\n          if (n.length > 0) {\n            const t = e[n[0]];\n            if (void 0 !== t) {\n              (this.morphTargetInfluences = []),\n                (this.morphTargetDictionary = {});\n              for (let e = 0, n = t.length; e < n; e++) {\n                const n = t[e].name || String(e);\n                this.morphTargetInfluences.push(0),\n                  (this.morphTargetDictionary[n] = e);\n              }\n            }\n          }\n        } else {\n          const e = t.morphTargets;\n          void 0 !== e &&\n            e.length > 0 &&\n            console.error(\n              \"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.\"\n            );\n        }\n      }\n    }\n    function ro(t, e, n, i, r, s, a) {\n      const o = to.distanceSqToPoint(t);\n      if (o < n) {\n        const n = new zt();\n        to.closestPointToPoint(t, n), n.applyMatrix4(i);\n        const l = r.ray.origin.distanceTo(n);\n        if (l < r.near || l > r.far) return;\n        s.push({\n          distance: l,\n          distanceToRay: Math.sqrt(o),\n          point: n,\n          index: e,\n          face: null,\n          object: a,\n        });\n      }\n    }\n    io.prototype.isPoints = !0;\n    class so extends Lt {\n      constructor(t, e, n, i, r, s, a, o, l) {\n        super(t, e, n, i, r, s, a, o, l),\n          (this.format = void 0 !== a ? a : T),\n          (this.minFilter = void 0 !== s ? s : g),\n          (this.magFilter = void 0 !== r ? r : g),\n          (this.generateMipmaps = !1);\n        const c = this;\n        \"requestVideoFrameCallback\" in t &&\n          t.requestVideoFrameCallback(function e() {\n            (c.needsUpdate = !0), t.requestVideoFrameCallback(e);\n          });\n      }\n      clone() {\n        return new this.constructor(this.image).copy(this);\n      }\n      update() {\n        const t = this.image;\n        !1 === \"requestVideoFrameCallback\" in t &&\n          t.readyState >= t.HAVE_CURRENT_DATA &&\n          (this.needsUpdate = !0);\n      }\n    }\n    so.prototype.isVideoTexture = !0;\n    class ao extends Lt {\n      constructor(t, e, n, i, r, s, a, o, l, c, h, u) {\n        super(null, s, a, o, l, c, i, r, h, u),\n          (this.image = { width: e, height: n }),\n          (this.mipmaps = t),\n          (this.flipY = !1),\n          (this.generateMipmaps = !1);\n      }\n    }\n    ao.prototype.isCompressedTexture = !0;\n    class oo extends Lt {\n      constructor(t, e, n, i, r, s, a, o, l) {\n        super(t, e, n, i, r, s, a, o, l), (this.needsUpdate = !0);\n      }\n    }\n    oo.prototype.isCanvasTexture = !0;\n    class lo extends Lt {\n      constructor(t, e, n, i, r, s, a, o, l, c) {\n        if ((c = void 0 !== c ? c : A) !== A && c !== L)\n          throw new Error(\n            \"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat\"\n          );\n        void 0 === n && c === A && (n = _),\n          void 0 === n && c === L && (n = S),\n          super(null, i, r, s, a, o, c, n, l),\n          (this.image = { width: t, height: e }),\n          (this.magFilter = void 0 !== a ? a : p),\n          (this.minFilter = void 0 !== o ? o : p),\n          (this.flipY = !1),\n          (this.generateMipmaps = !1);\n      }\n    }\n    lo.prototype.isDepthTexture = !0;\n    class co extends En {\n      constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {\n        super(),\n          (this.type = \"CircleGeometry\"),\n          (this.parameters = {\n            radius: t,\n            segments: e,\n            thetaStart: n,\n            thetaLength: i,\n          }),\n          (e = Math.max(3, e));\n        const r = [],\n          s = [],\n          a = [],\n          o = [],\n          l = new zt(),\n          c = new yt();\n        s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);\n        for (let r = 0, h = 3; r <= e; r++, h += 3) {\n          const u = n + (r / e) * i;\n          (l.x = t * Math.cos(u)),\n            (l.y = t * Math.sin(u)),\n            s.push(l.x, l.y, l.z),\n            a.push(0, 0, 1),\n            (c.x = (s[h] / t + 1) / 2),\n            (c.y = (s[h + 1] / t + 1) / 2),\n            o.push(c.x, c.y);\n        }\n        for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);\n        this.setIndex(r),\n          this.setAttribute(\"position\", new vn(s, 3)),\n          this.setAttribute(\"normal\", new vn(a, 3)),\n          this.setAttribute(\"uv\", new vn(o, 2));\n      }\n      static fromJSON(t) {\n        return new co(t.radius, t.segments, t.thetaStart, t.thetaLength);\n      }\n    }\n    class ho extends En {\n      constructor(\n        t = 1,\n        e = 1,\n        n = 1,\n        i = 8,\n        r = 1,\n        s = !1,\n        a = 0,\n        o = 2 * Math.PI\n      ) {\n        super(),\n          (this.type = \"CylinderGeometry\"),\n          (this.parameters = {\n            radiusTop: t,\n            radiusBottom: e,\n            height: n,\n            radialSegments: i,\n            heightSegments: r,\n            openEnded: s,\n            thetaStart: a,\n            thetaLength: o,\n          });\n        const l = this;\n        (i = Math.floor(i)), (r = Math.floor(r));\n        const c = [],\n          h = [],\n          u = [],\n          d = [];\n        let p = 0;\n        const m = [],\n          f = n / 2;\n        let g = 0;\n        function v(n) {\n          const r = p,\n            s = new yt(),\n            m = new zt();\n          let v = 0;\n          const y = !0 === n ? t : e,\n            x = !0 === n ? 1 : -1;\n          for (let t = 1; t <= i; t++)\n            h.push(0, f * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;\n          const _ = p;\n          for (let t = 0; t <= i; t++) {\n            const e = (t / i) * o + a,\n              n = Math.cos(e),\n              r = Math.sin(e);\n            (m.x = y * r),\n              (m.y = f * x),\n              (m.z = y * n),\n              h.push(m.x, m.y, m.z),\n              u.push(0, x, 0),\n              (s.x = 0.5 * n + 0.5),\n              (s.y = 0.5 * r * x + 0.5),\n              d.push(s.x, s.y),\n              p++;\n          }\n          for (let t = 0; t < i; t++) {\n            const e = r + t,\n              i = _ + t;\n            !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (v += 3);\n          }\n          l.addGroup(g, v, !0 === n ? 1 : 2), (g += v);\n        }\n        !(function () {\n          const s = new zt(),\n            v = new zt();\n          let y = 0;\n          const x = (e - t) / n;\n          for (let l = 0; l <= r; l++) {\n            const c = [],\n              g = l / r,\n              y = g * (e - t) + t;\n            for (let t = 0; t <= i; t++) {\n              const e = t / i,\n                r = e * o + a,\n                l = Math.sin(r),\n                m = Math.cos(r);\n              (v.x = y * l),\n                (v.y = -g * n + f),\n                (v.z = y * m),\n                h.push(v.x, v.y, v.z),\n                s.set(l, x, m).normalize(),\n                u.push(s.x, s.y, s.z),\n                d.push(e, 1 - g),\n                c.push(p++);\n            }\n            m.push(c);\n          }\n          for (let t = 0; t < i; t++)\n            for (let e = 0; e < r; e++) {\n              const n = m[e][t],\n                i = m[e + 1][t],\n                r = m[e + 1][t + 1],\n                s = m[e][t + 1];\n              c.push(n, i, s), c.push(i, r, s), (y += 6);\n            }\n          l.addGroup(g, y, 0), (g += y);\n        })(),\n          !1 === s && (t > 0 && v(!0), e > 0 && v(!1)),\n          this.setIndex(c),\n          this.setAttribute(\"position\", new vn(h, 3)),\n          this.setAttribute(\"normal\", new vn(u, 3)),\n          this.setAttribute(\"uv\", new vn(d, 2));\n      }\n      static fromJSON(t) {\n        return new ho(\n          t.radiusTop,\n          t.radiusBottom,\n          t.height,\n          t.radialSegments,\n          t.heightSegments,\n          t.openEnded,\n          t.thetaStart,\n          t.thetaLength\n        );\n      }\n    }\n    class uo extends ho {\n      constructor(t = 1, e = 1, n = 8, i = 1, r = !1, s = 0, a = 2 * Math.PI) {\n        super(0, t, e, n, i, r, s, a),\n          (this.type = \"ConeGeometry\"),\n          (this.parameters = {\n            radius: t,\n            height: e,\n            radialSegments: n,\n            heightSegments: i,\n            openEnded: r,\n            thetaStart: s,\n            thetaLength: a,\n          });\n      }\n      static fromJSON(t) {\n        return new uo(\n          t.radius,\n          t.height,\n          t.radialSegments,\n          t.heightSegments,\n          t.openEnded,\n          t.thetaStart,\n          t.thetaLength\n        );\n      }\n    }\n    class po extends En {\n      constructor(t = [], e = [], n = 1, i = 0) {\n        super(),\n          (this.type = \"PolyhedronGeometry\"),\n          (this.parameters = { vertices: t, indices: e, radius: n, detail: i });\n        const r = [],\n          s = [];\n        function a(t, e, n, i) {\n          const r = i + 1,\n            s = [];\n          for (let i = 0; i <= r; i++) {\n            s[i] = [];\n            const a = t.clone().lerp(n, i / r),\n              o = e.clone().lerp(n, i / r),\n              l = r - i;\n            for (let t = 0; t <= l; t++)\n              s[i][t] = 0 === t && i === r ? a : a.clone().lerp(o, t / l);\n          }\n          for (let t = 0; t < r; t++)\n            for (let e = 0; e < 2 * (r - t) - 1; e++) {\n              const n = Math.floor(e / 2);\n              e % 2 == 0\n                ? (o(s[t][n + 1]), o(s[t + 1][n]), o(s[t][n]))\n                : (o(s[t][n + 1]), o(s[t + 1][n + 1]), o(s[t + 1][n]));\n            }\n        }\n        function o(t) {\n          r.push(t.x, t.y, t.z);\n        }\n        function l(e, n) {\n          const i = 3 * e;\n          (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);\n        }\n        function c(t, e, n, i) {\n          i < 0 && 1 === t.x && (s[e] = t.x - 1),\n            0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + 0.5);\n        }\n        function h(t) {\n          return Math.atan2(t.z, -t.x);\n        }\n        !(function (t) {\n          const n = new zt(),\n            i = new zt(),\n            r = new zt();\n          for (let s = 0; s < e.length; s += 3)\n            l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t);\n        })(i),\n          (function (t) {\n            const e = new zt();\n            for (let n = 0; n < r.length; n += 3)\n              (e.x = r[n + 0]),\n                (e.y = r[n + 1]),\n                (e.z = r[n + 2]),\n                e.normalize().multiplyScalar(t),\n                (r[n + 0] = e.x),\n                (r[n + 1] = e.y),\n                (r[n + 2] = e.z);\n          })(n),\n          (function () {\n            const t = new zt();\n            for (let n = 0; n < r.length; n += 3) {\n              (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);\n              const i = h(t) / 2 / Math.PI + 0.5,\n                a =\n                  ((e = t),\n                  Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +\n                    0.5);\n              s.push(i, 1 - a);\n            }\n            var e;\n            (function () {\n              const t = new zt(),\n                e = new zt(),\n                n = new zt(),\n                i = new zt(),\n                a = new yt(),\n                o = new yt(),\n                l = new yt();\n              for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {\n                t.set(r[u + 0], r[u + 1], r[u + 2]),\n                  e.set(r[u + 3], r[u + 4], r[u + 5]),\n                  n.set(r[u + 6], r[u + 7], r[u + 8]),\n                  a.set(s[d + 0], s[d + 1]),\n                  o.set(s[d + 2], s[d + 3]),\n                  l.set(s[d + 4], s[d + 5]),\n                  i.copy(t).add(e).add(n).divideScalar(3);\n                const p = h(i);\n                c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p);\n              }\n            })(),\n              (function () {\n                for (let t = 0; t < s.length; t += 6) {\n                  const e = s[t + 0],\n                    n = s[t + 2],\n                    i = s[t + 4],\n                    r = Math.max(e, n, i),\n                    a = Math.min(e, n, i);\n                  r > 0.9 &&\n                    a < 0.1 &&\n                    (e < 0.2 && (s[t + 0] += 1),\n                    n < 0.2 && (s[t + 2] += 1),\n                    i < 0.2 && (s[t + 4] += 1));\n                }\n              })();\n          })(),\n          this.setAttribute(\"position\", new vn(r, 3)),\n          this.setAttribute(\"normal\", new vn(r.slice(), 3)),\n          this.setAttribute(\"uv\", new vn(s, 2)),\n          0 === i ? this.computeVertexNormals() : this.normalizeNormals();\n      }\n      static fromJSON(t) {\n        return new po(t.vertices, t.indices, t.radius, t.details);\n      }\n    }\n    class mo extends po {\n      constructor(t = 1, e = 0) {\n        const n = (1 + Math.sqrt(5)) / 2,\n          i = 1 / n;\n        super(\n          [\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            1,\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1,\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            1,\n            1,\n            1,\n            -1,\n            1,\n            1,\n            1,\n            0,\n            -i,\n            -n,\n            0,\n            -i,\n            n,\n            0,\n            i,\n            -n,\n            0,\n            i,\n            n,\n            -i,\n            -n,\n            0,\n            -i,\n            n,\n            0,\n            i,\n            -n,\n            0,\n            i,\n            n,\n            0,\n            -n,\n            0,\n            -i,\n            n,\n            0,\n            -i,\n            -n,\n            0,\n            i,\n            n,\n            0,\n            i,\n          ],\n          [\n            3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,\n            8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0,\n            1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18,\n            3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4,\n            0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4,\n            17, 1, 12, 14, 1, 14, 5, 1, 5, 9,\n          ],\n          t,\n          e\n        ),\n          (this.type = \"DodecahedronGeometry\"),\n          (this.parameters = { radius: t, detail: e });\n      }\n      static fromJSON(t) {\n        return new mo(t.radius, t.detail);\n      }\n    }\n    const fo = new zt(),\n      go = new zt(),\n      vo = new zt(),\n      yo = new Ye();\n    class xo extends En {\n      constructor(t = null, e = 1) {\n        if (\n          (super(),\n          (this.type = \"EdgesGeometry\"),\n          (this.parameters = { geometry: t, thresholdAngle: e }),\n          null !== t)\n        ) {\n          const n = 4,\n            i = Math.pow(10, n),\n            r = Math.cos(at * e),\n            s = t.getIndex(),\n            a = t.getAttribute(\"position\"),\n            o = s ? s.count : a.count,\n            l = [0, 0, 0],\n            c = [\"a\", \"b\", \"c\"],\n            h = new Array(3),\n            u = {},\n            d = [];\n          for (let t = 0; t < o; t += 3) {\n            s\n              ? ((l[0] = s.getX(t)),\n                (l[1] = s.getX(t + 1)),\n                (l[2] = s.getX(t + 2)))\n              : ((l[0] = t), (l[1] = t + 1), (l[2] = t + 2));\n            const { a: e, b: n, c: o } = yo;\n            if (\n              (e.fromBufferAttribute(a, l[0]),\n              n.fromBufferAttribute(a, l[1]),\n              o.fromBufferAttribute(a, l[2]),\n              yo.getNormal(vo),\n              (h[0] = `${Math.round(e.x * i)},${Math.round(\n                e.y * i\n              )},${Math.round(e.z * i)}`),\n              (h[1] = `${Math.round(n.x * i)},${Math.round(\n                n.y * i\n              )},${Math.round(n.z * i)}`),\n              (h[2] = `${Math.round(o.x * i)},${Math.round(\n                o.y * i\n              )},${Math.round(o.z * i)}`),\n              h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])\n            )\n              for (let t = 0; t < 3; t++) {\n                const e = (t + 1) % 3,\n                  n = h[t],\n                  i = h[e],\n                  s = yo[c[t]],\n                  a = yo[c[e]],\n                  o = `${n}_${i}`,\n                  p = `${i}_${n}`;\n                p in u && u[p]\n                  ? (vo.dot(u[p].normal) <= r &&\n                      (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)),\n                    (u[p] = null))\n                  : o in u ||\n                    (u[o] = { index0: l[t], index1: l[e], normal: vo.clone() });\n              }\n          }\n          for (const t in u)\n            if (u[t]) {\n              const { index0: e, index1: n } = u[t];\n              fo.fromBufferAttribute(a, e),\n                go.fromBufferAttribute(a, n),\n                d.push(fo.x, fo.y, fo.z),\n                d.push(go.x, go.y, go.z);\n            }\n          this.setAttribute(\"position\", new vn(d, 3));\n        }\n      }\n    }\n    class _o {\n      constructor() {\n        (this.type = \"Curve\"), (this.arcLengthDivisions = 200);\n      }\n      getPoint() {\n        return console.warn(\"THREE.Curve: .getPoint() not implemented.\"), null;\n      }\n      getPointAt(t, e) {\n        const n = this.getUtoTmapping(t);\n        return this.getPoint(n, e);\n      }\n      getPoints(t = 5) {\n        const e = [];\n        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));\n        return e;\n      }\n      getSpacedPoints(t = 5) {\n        const e = [];\n        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));\n        return e;\n      }\n      getLength() {\n        const t = this.getLengths();\n        return t[t.length - 1];\n      }\n      getLengths(t = this.arcLengthDivisions) {\n        if (\n          this.cacheArcLengths &&\n          this.cacheArcLengths.length === t + 1 &&\n          !this.needsUpdate\n        )\n          return this.cacheArcLengths;\n        this.needsUpdate = !1;\n        const e = [];\n        let n,\n          i = this.getPoint(0),\n          r = 0;\n        e.push(0);\n        for (let s = 1; s <= t; s++)\n          (n = this.getPoint(s / t)),\n            (r += n.distanceTo(i)),\n            e.push(r),\n            (i = n);\n        return (this.cacheArcLengths = e), e;\n      }\n      updateArcLengths() {\n        (this.needsUpdate = !0), this.getLengths();\n      }\n      getUtoTmapping(t, e) {\n        const n = this.getLengths();\n        let i = 0;\n        const r = n.length;\n        let s;\n        s = e || t * n[r - 1];\n        let a,\n          o = 0,\n          l = r - 1;\n        for (; o <= l; )\n          if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))\n            o = i + 1;\n          else {\n            if (!(a > 0)) {\n              l = i;\n              break;\n            }\n            l = i - 1;\n          }\n        if (((i = l), n[i] === s)) return i / (r - 1);\n        const c = n[i];\n        return (i + (s - c) / (n[i + 1] - c)) / (r - 1);\n      }\n      getTangent(t, e) {\n        const n = 1e-4;\n        let i = t - n,\n          r = t + n;\n        i < 0 && (i = 0), r > 1 && (r = 1);\n        const s = this.getPoint(i),\n          a = this.getPoint(r),\n          o = e || (s.isVector2 ? new yt() : new zt());\n        return o.copy(a).sub(s).normalize(), o;\n      }\n      getTangentAt(t, e) {\n        const n = this.getUtoTmapping(t);\n        return this.getTangent(n, e);\n      }\n      computeFrenetFrames(t, e) {\n        const n = new zt(),\n          i = [],\n          r = [],\n          s = [],\n          a = new zt(),\n          o = new de();\n        for (let e = 0; e <= t; e++) {\n          const n = e / t;\n          i[e] = this.getTangentAt(n, new zt());\n        }\n        (r[0] = new zt()), (s[0] = new zt());\n        let l = Number.MAX_VALUE;\n        const c = Math.abs(i[0].x),\n          h = Math.abs(i[0].y),\n          u = Math.abs(i[0].z);\n        c <= l && ((l = c), n.set(1, 0, 0)),\n          h <= l && ((l = h), n.set(0, 1, 0)),\n          u <= l && n.set(0, 0, 1),\n          a.crossVectors(i[0], n).normalize(),\n          r[0].crossVectors(i[0], a),\n          s[0].crossVectors(i[0], r[0]);\n        for (let e = 1; e <= t; e++) {\n          if (\n            ((r[e] = r[e - 1].clone()),\n            (s[e] = s[e - 1].clone()),\n            a.crossVectors(i[e - 1], i[e]),\n            a.length() > Number.EPSILON)\n          ) {\n            a.normalize();\n            const t = Math.acos(ut(i[e - 1].dot(i[e]), -1, 1));\n            r[e].applyMatrix4(o.makeRotationAxis(a, t));\n          }\n          s[e].crossVectors(i[e], r[e]);\n        }\n        if (!0 === e) {\n          let e = Math.acos(ut(r[0].dot(r[t]), -1, 1));\n          (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);\n          for (let n = 1; n <= t; n++)\n            r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)),\n              s[n].crossVectors(i[n], r[n]);\n        }\n        return { tangents: i, normals: r, binormals: s };\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return (this.arcLengthDivisions = t.arcLengthDivisions), this;\n      }\n      toJSON() {\n        const t = {\n          metadata: { version: 4.5, type: \"Curve\", generator: \"Curve.toJSON\" },\n        };\n        return (\n          (t.arcLengthDivisions = this.arcLengthDivisions),\n          (t.type = this.type),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (this.arcLengthDivisions = t.arcLengthDivisions), this;\n      }\n    }\n    class Mo extends _o {\n      constructor(\n        t = 0,\n        e = 0,\n        n = 1,\n        i = 1,\n        r = 0,\n        s = 2 * Math.PI,\n        a = !1,\n        o = 0\n      ) {\n        super(),\n          (this.type = \"EllipseCurve\"),\n          (this.aX = t),\n          (this.aY = e),\n          (this.xRadius = n),\n          (this.yRadius = i),\n          (this.aStartAngle = r),\n          (this.aEndAngle = s),\n          (this.aClockwise = a),\n          (this.aRotation = o);\n      }\n      getPoint(t, e) {\n        const n = e || new yt(),\n          i = 2 * Math.PI;\n        let r = this.aEndAngle - this.aStartAngle;\n        const s = Math.abs(r) < Number.EPSILON;\n        for (; r < 0; ) r += i;\n        for (; r > i; ) r -= i;\n        r < Number.EPSILON && (r = s ? 0 : i),\n          !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));\n        const a = this.aStartAngle + t * r;\n        let o = this.aX + this.xRadius * Math.cos(a),\n          l = this.aY + this.yRadius * Math.sin(a);\n        if (0 !== this.aRotation) {\n          const t = Math.cos(this.aRotation),\n            e = Math.sin(this.aRotation),\n            n = o - this.aX,\n            i = l - this.aY;\n          (o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);\n        }\n        return n.set(o, l);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.aX = t.aX),\n          (this.aY = t.aY),\n          (this.xRadius = t.xRadius),\n          (this.yRadius = t.yRadius),\n          (this.aStartAngle = t.aStartAngle),\n          (this.aEndAngle = t.aEndAngle),\n          (this.aClockwise = t.aClockwise),\n          (this.aRotation = t.aRotation),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.aX = this.aX),\n          (t.aY = this.aY),\n          (t.xRadius = this.xRadius),\n          (t.yRadius = this.yRadius),\n          (t.aStartAngle = this.aStartAngle),\n          (t.aEndAngle = this.aEndAngle),\n          (t.aClockwise = this.aClockwise),\n          (t.aRotation = this.aRotation),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          (this.aX = t.aX),\n          (this.aY = t.aY),\n          (this.xRadius = t.xRadius),\n          (this.yRadius = t.yRadius),\n          (this.aStartAngle = t.aStartAngle),\n          (this.aEndAngle = t.aEndAngle),\n          (this.aClockwise = t.aClockwise),\n          (this.aRotation = t.aRotation),\n          this\n        );\n      }\n    }\n    Mo.prototype.isEllipseCurve = !0;\n    class bo extends Mo {\n      constructor(t, e, n, i, r, s) {\n        super(t, e, n, n, i, r, s), (this.type = \"ArcCurve\");\n      }\n    }\n    function wo() {\n      let t = 0,\n        e = 0,\n        n = 0,\n        i = 0;\n      function r(r, s, a, o) {\n        (t = r),\n          (e = a),\n          (n = -3 * r + 3 * s - 2 * a - o),\n          (i = 2 * r - 2 * s + a + o);\n      }\n      return {\n        initCatmullRom: function (t, e, n, i, s) {\n          r(e, n, s * (n - t), s * (i - e));\n        },\n        initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {\n          let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,\n            c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;\n          (l *= a), (c *= a), r(e, n, l, c);\n        },\n        calc: function (r) {\n          const s = r * r;\n          return t + e * r + n * s + i * (s * r);\n        },\n      };\n    }\n    bo.prototype.isArcCurve = !0;\n    const So = new zt(),\n      To = new wo(),\n      Eo = new wo(),\n      Ao = new wo();\n    class Lo extends _o {\n      constructor(t = [], e = !1, n = \"centripetal\", i = 0.5) {\n        super(),\n          (this.type = \"CatmullRomCurve3\"),\n          (this.points = t),\n          (this.closed = e),\n          (this.curveType = n),\n          (this.tension = i);\n      }\n      getPoint(t, e = new zt()) {\n        const n = e,\n          i = this.points,\n          r = i.length,\n          s = (r - (this.closed ? 0 : 1)) * t;\n        let a,\n          o,\n          l = Math.floor(s),\n          c = s - l;\n        this.closed\n          ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)\n          : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),\n          this.closed || l > 0\n            ? (a = i[(l - 1) % r])\n            : (So.subVectors(i[0], i[1]).add(i[0]), (a = So));\n        const h = i[l % r],\n          u = i[(l + 1) % r];\n        if (\n          (this.closed || l + 2 < r\n            ? (o = i[(l + 2) % r])\n            : (So.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = So)),\n          \"centripetal\" === this.curveType || \"chordal\" === this.curveType)\n        ) {\n          const t = \"chordal\" === this.curveType ? 0.5 : 0.25;\n          let e = Math.pow(a.distanceToSquared(h), t),\n            n = Math.pow(h.distanceToSquared(u), t),\n            i = Math.pow(u.distanceToSquared(o), t);\n          n < 1e-4 && (n = 1),\n            e < 1e-4 && (e = n),\n            i < 1e-4 && (i = n),\n            To.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),\n            Eo.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),\n            Ao.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i);\n        } else \"catmullrom\" === this.curveType && (To.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Eo.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Ao.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));\n        return n.set(To.calc(c), Eo.calc(c), Ao.calc(c)), n;\n      }\n      copy(t) {\n        super.copy(t), (this.points = []);\n        for (let e = 0, n = t.points.length; e < n; e++) {\n          const n = t.points[e];\n          this.points.push(n.clone());\n        }\n        return (\n          (this.closed = t.closed),\n          (this.curveType = t.curveType),\n          (this.tension = t.tension),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        t.points = [];\n        for (let e = 0, n = this.points.length; e < n; e++) {\n          const n = this.points[e];\n          t.points.push(n.toArray());\n        }\n        return (\n          (t.closed = this.closed),\n          (t.curveType = this.curveType),\n          (t.tension = this.tension),\n          t\n        );\n      }\n      fromJSON(t) {\n        super.fromJSON(t), (this.points = []);\n        for (let e = 0, n = t.points.length; e < n; e++) {\n          const n = t.points[e];\n          this.points.push(new zt().fromArray(n));\n        }\n        return (\n          (this.closed = t.closed),\n          (this.curveType = t.curveType),\n          (this.tension = t.tension),\n          this\n        );\n      }\n    }\n    function Ro(t, e, n, i, r) {\n      const s = 0.5 * (i - e),\n        a = 0.5 * (r - n),\n        o = t * t;\n      return (\n        (2 * n - 2 * i + s + a) * (t * o) +\n        (-3 * n + 3 * i - 2 * s - a) * o +\n        s * t +\n        n\n      );\n    }\n    function Co(t, e, n, i) {\n      return (\n        (function (t, e) {\n          const n = 1 - t;\n          return n * n * e;\n        })(t, e) +\n        (function (t, e) {\n          return 2 * (1 - t) * t * e;\n        })(t, n) +\n        (function (t, e) {\n          return t * t * e;\n        })(t, i)\n      );\n    }\n    function Po(t, e, n, i, r) {\n      return (\n        (function (t, e) {\n          const n = 1 - t;\n          return n * n * n * e;\n        })(t, e) +\n        (function (t, e) {\n          const n = 1 - t;\n          return 3 * n * n * t * e;\n        })(t, n) +\n        (function (t, e) {\n          return 3 * (1 - t) * t * t * e;\n        })(t, i) +\n        (function (t, e) {\n          return t * t * t * e;\n        })(t, r)\n      );\n    }\n    Lo.prototype.isCatmullRomCurve3 = !0;\n    class Io extends _o {\n      constructor(t = new yt(), e = new yt(), n = new yt(), i = new yt()) {\n        super(),\n          (this.type = \"CubicBezierCurve\"),\n          (this.v0 = t),\n          (this.v1 = e),\n          (this.v2 = n),\n          (this.v3 = i);\n      }\n      getPoint(t, e = new yt()) {\n        const n = e,\n          i = this.v0,\n          r = this.v1,\n          s = this.v2,\n          a = this.v3;\n        return n.set(Po(t, i.x, r.x, s.x, a.x), Po(t, i.y, r.y, s.y, a.y)), n;\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.v0.copy(t.v0),\n          this.v1.copy(t.v1),\n          this.v2.copy(t.v2),\n          this.v3.copy(t.v3),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.v0 = this.v0.toArray()),\n          (t.v1 = this.v1.toArray()),\n          (t.v2 = this.v2.toArray()),\n          (t.v3 = this.v3.toArray()),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v0.fromArray(t.v0),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this.v3.fromArray(t.v3),\n          this\n        );\n      }\n    }\n    Io.prototype.isCubicBezierCurve = !0;\n    class Do extends _o {\n      constructor(t = new zt(), e = new zt(), n = new zt(), i = new zt()) {\n        super(),\n          (this.type = \"CubicBezierCurve3\"),\n          (this.v0 = t),\n          (this.v1 = e),\n          (this.v2 = n),\n          (this.v3 = i);\n      }\n      getPoint(t, e = new zt()) {\n        const n = e,\n          i = this.v0,\n          r = this.v1,\n          s = this.v2,\n          a = this.v3;\n        return (\n          n.set(\n            Po(t, i.x, r.x, s.x, a.x),\n            Po(t, i.y, r.y, s.y, a.y),\n            Po(t, i.z, r.z, s.z, a.z)\n          ),\n          n\n        );\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.v0.copy(t.v0),\n          this.v1.copy(t.v1),\n          this.v2.copy(t.v2),\n          this.v3.copy(t.v3),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.v0 = this.v0.toArray()),\n          (t.v1 = this.v1.toArray()),\n          (t.v2 = this.v2.toArray()),\n          (t.v3 = this.v3.toArray()),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v0.fromArray(t.v0),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this.v3.fromArray(t.v3),\n          this\n        );\n      }\n    }\n    Do.prototype.isCubicBezierCurve3 = !0;\n    class No extends _o {\n      constructor(t = new yt(), e = new yt()) {\n        super(), (this.type = \"LineCurve\"), (this.v1 = t), (this.v2 = e);\n      }\n      getPoint(t, e = new yt()) {\n        const n = e;\n        return (\n          1 === t\n            ? n.copy(this.v2)\n            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),\n          n\n        );\n      }\n      getPointAt(t, e) {\n        return this.getPoint(t, e);\n      }\n      getTangent(t, e) {\n        const n = e || new yt();\n        return n.copy(this.v2).sub(this.v1).normalize(), n;\n      }\n      copy(t) {\n        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this\n        );\n      }\n    }\n    No.prototype.isLineCurve = !0;\n    class zo extends _o {\n      constructor(t = new zt(), e = new zt()) {\n        super(),\n          (this.type = \"LineCurve3\"),\n          (this.isLineCurve3 = !0),\n          (this.v1 = t),\n          (this.v2 = e);\n      }\n      getPoint(t, e = new zt()) {\n        const n = e;\n        return (\n          1 === t\n            ? n.copy(this.v2)\n            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),\n          n\n        );\n      }\n      getPointAt(t, e) {\n        return this.getPoint(t, e);\n      }\n      copy(t) {\n        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this\n        );\n      }\n    }\n    class Bo extends _o {\n      constructor(t = new yt(), e = new yt(), n = new yt()) {\n        super(),\n          (this.type = \"QuadraticBezierCurve\"),\n          (this.v0 = t),\n          (this.v1 = e),\n          (this.v2 = n);\n      }\n      getPoint(t, e = new yt()) {\n        const n = e,\n          i = this.v0,\n          r = this.v1,\n          s = this.v2;\n        return n.set(Co(t, i.x, r.x, s.x), Co(t, i.y, r.y, s.y)), n;\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.v0.copy(t.v0),\n          this.v1.copy(t.v1),\n          this.v2.copy(t.v2),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.v0 = this.v0.toArray()),\n          (t.v1 = this.v1.toArray()),\n          (t.v2 = this.v2.toArray()),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v0.fromArray(t.v0),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this\n        );\n      }\n    }\n    Bo.prototype.isQuadraticBezierCurve = !0;\n    class Fo extends _o {\n      constructor(t = new zt(), e = new zt(), n = new zt()) {\n        super(),\n          (this.type = \"QuadraticBezierCurve3\"),\n          (this.v0 = t),\n          (this.v1 = e),\n          (this.v2 = n);\n      }\n      getPoint(t, e = new zt()) {\n        const n = e,\n          i = this.v0,\n          r = this.v1,\n          s = this.v2;\n        return (\n          n.set(\n            Co(t, i.x, r.x, s.x),\n            Co(t, i.y, r.y, s.y),\n            Co(t, i.z, r.z, s.z)\n          ),\n          n\n        );\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.v0.copy(t.v0),\n          this.v1.copy(t.v1),\n          this.v2.copy(t.v2),\n          this\n        );\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (\n          (t.v0 = this.v0.toArray()),\n          (t.v1 = this.v1.toArray()),\n          (t.v2 = this.v2.toArray()),\n          t\n        );\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t),\n          this.v0.fromArray(t.v0),\n          this.v1.fromArray(t.v1),\n          this.v2.fromArray(t.v2),\n          this\n        );\n      }\n    }\n    Fo.prototype.isQuadraticBezierCurve3 = !0;\n    class Oo extends _o {\n      constructor(t = []) {\n        super(), (this.type = \"SplineCurve\"), (this.points = t);\n      }\n      getPoint(t, e = new yt()) {\n        const n = e,\n          i = this.points,\n          r = (i.length - 1) * t,\n          s = Math.floor(r),\n          a = r - s,\n          o = i[0 === s ? s : s - 1],\n          l = i[s],\n          c = i[s > i.length - 2 ? i.length - 1 : s + 1],\n          h = i[s > i.length - 3 ? i.length - 1 : s + 2];\n        return n.set(Ro(a, o.x, l.x, c.x, h.x), Ro(a, o.y, l.y, c.y, h.y)), n;\n      }\n      copy(t) {\n        super.copy(t), (this.points = []);\n        for (let e = 0, n = t.points.length; e < n; e++) {\n          const n = t.points[e];\n          this.points.push(n.clone());\n        }\n        return this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        t.points = [];\n        for (let e = 0, n = this.points.length; e < n; e++) {\n          const n = this.points[e];\n          t.points.push(n.toArray());\n        }\n        return t;\n      }\n      fromJSON(t) {\n        super.fromJSON(t), (this.points = []);\n        for (let e = 0, n = t.points.length; e < n; e++) {\n          const n = t.points[e];\n          this.points.push(new yt().fromArray(n));\n        }\n        return this;\n      }\n    }\n    Oo.prototype.isSplineCurve = !0;\n    var Uo = Object.freeze({\n      __proto__: null,\n      ArcCurve: bo,\n      CatmullRomCurve3: Lo,\n      CubicBezierCurve: Io,\n      CubicBezierCurve3: Do,\n      EllipseCurve: Mo,\n      LineCurve: No,\n      LineCurve3: zo,\n      QuadraticBezierCurve: Bo,\n      QuadraticBezierCurve3: Fo,\n      SplineCurve: Oo,\n    });\n    class Ho extends _o {\n      constructor() {\n        super(),\n          (this.type = \"CurvePath\"),\n          (this.curves = []),\n          (this.autoClose = !1);\n      }\n      add(t) {\n        this.curves.push(t);\n      }\n      closePath() {\n        const t = this.curves[0].getPoint(0),\n          e = this.curves[this.curves.length - 1].getPoint(1);\n        t.equals(e) || this.curves.push(new No(e, t));\n      }\n      getPoint(t, e) {\n        const n = t * this.getLength(),\n          i = this.getCurveLengths();\n        let r = 0;\n        for (; r < i.length; ) {\n          if (i[r] >= n) {\n            const t = i[r] - n,\n              s = this.curves[r],\n              a = s.getLength(),\n              o = 0 === a ? 0 : 1 - t / a;\n            return s.getPointAt(o, e);\n          }\n          r++;\n        }\n        return null;\n      }\n      getLength() {\n        const t = this.getCurveLengths();\n        return t[t.length - 1];\n      }\n      updateArcLengths() {\n        (this.needsUpdate = !0),\n          (this.cacheLengths = null),\n          this.getCurveLengths();\n      }\n      getCurveLengths() {\n        if (\n          this.cacheLengths &&\n          this.cacheLengths.length === this.curves.length\n        )\n          return this.cacheLengths;\n        const t = [];\n        let e = 0;\n        for (let n = 0, i = this.curves.length; n < i; n++)\n          (e += this.curves[n].getLength()), t.push(e);\n        return (this.cacheLengths = t), t;\n      }\n      getSpacedPoints(t = 40) {\n        const e = [];\n        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));\n        return this.autoClose && e.push(e[0]), e;\n      }\n      getPoints(t = 12) {\n        const e = [];\n        let n;\n        for (let i = 0, r = this.curves; i < r.length; i++) {\n          const s = r[i],\n            a =\n              s && s.isEllipseCurve\n                ? 2 * t\n                : s && (s.isLineCurve || s.isLineCurve3)\n                ? 1\n                : s && s.isSplineCurve\n                ? t * s.points.length\n                : t,\n            o = s.getPoints(a);\n          for (let t = 0; t < o.length; t++) {\n            const i = o[t];\n            (n && n.equals(i)) || (e.push(i), (n = i));\n          }\n        }\n        return (\n          this.autoClose &&\n            e.length > 1 &&\n            !e[e.length - 1].equals(e[0]) &&\n            e.push(e[0]),\n          e\n        );\n      }\n      copy(t) {\n        super.copy(t), (this.curves = []);\n        for (let e = 0, n = t.curves.length; e < n; e++) {\n          const n = t.curves[e];\n          this.curves.push(n.clone());\n        }\n        return (this.autoClose = t.autoClose), this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        (t.autoClose = this.autoClose), (t.curves = []);\n        for (let e = 0, n = this.curves.length; e < n; e++) {\n          const n = this.curves[e];\n          t.curves.push(n.toJSON());\n        }\n        return t;\n      }\n      fromJSON(t) {\n        super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);\n        for (let e = 0, n = t.curves.length; e < n; e++) {\n          const n = t.curves[e];\n          this.curves.push(new Uo[n.type]().fromJSON(n));\n        }\n        return this;\n      }\n    }\n    class Go extends Ho {\n      constructor(t) {\n        super(),\n          (this.type = \"Path\"),\n          (this.currentPoint = new yt()),\n          t && this.setFromPoints(t);\n      }\n      setFromPoints(t) {\n        this.moveTo(t[0].x, t[0].y);\n        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);\n        return this;\n      }\n      moveTo(t, e) {\n        return this.currentPoint.set(t, e), this;\n      }\n      lineTo(t, e) {\n        const n = new No(this.currentPoint.clone(), new yt(t, e));\n        return this.curves.push(n), this.currentPoint.set(t, e), this;\n      }\n      quadraticCurveTo(t, e, n, i) {\n        const r = new Bo(this.currentPoint.clone(), new yt(t, e), new yt(n, i));\n        return this.curves.push(r), this.currentPoint.set(n, i), this;\n      }\n      bezierCurveTo(t, e, n, i, r, s) {\n        const a = new Io(\n          this.currentPoint.clone(),\n          new yt(t, e),\n          new yt(n, i),\n          new yt(r, s)\n        );\n        return this.curves.push(a), this.currentPoint.set(r, s), this;\n      }\n      splineThru(t) {\n        const e = [this.currentPoint.clone()].concat(t),\n          n = new Oo(e);\n        return (\n          this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this\n        );\n      }\n      arc(t, e, n, i, r, s) {\n        const a = this.currentPoint.x,\n          o = this.currentPoint.y;\n        return this.absarc(t + a, e + o, n, i, r, s), this;\n      }\n      absarc(t, e, n, i, r, s) {\n        return this.absellipse(t, e, n, n, i, r, s), this;\n      }\n      ellipse(t, e, n, i, r, s, a, o) {\n        const l = this.currentPoint.x,\n          c = this.currentPoint.y;\n        return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;\n      }\n      absellipse(t, e, n, i, r, s, a, o) {\n        const l = new Mo(t, e, n, i, r, s, a, o);\n        if (this.curves.length > 0) {\n          const t = l.getPoint(0);\n          t.equals(this.currentPoint) || this.lineTo(t.x, t.y);\n        }\n        this.curves.push(l);\n        const c = l.getPoint(1);\n        return this.currentPoint.copy(c), this;\n      }\n      copy(t) {\n        return super.copy(t), this.currentPoint.copy(t.currentPoint), this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (t.currentPoint = this.currentPoint.toArray()), t;\n      }\n      fromJSON(t) {\n        return (\n          super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this\n        );\n      }\n    }\n    class ko extends Go {\n      constructor(t) {\n        super(t), (this.uuid = ht()), (this.type = \"Shape\"), (this.holes = []);\n      }\n      getPointsHoles(t) {\n        const e = [];\n        for (let n = 0, i = this.holes.length; n < i; n++)\n          e[n] = this.holes[n].getPoints(t);\n        return e;\n      }\n      extractPoints(t) {\n        return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };\n      }\n      copy(t) {\n        super.copy(t), (this.holes = []);\n        for (let e = 0, n = t.holes.length; e < n; e++) {\n          const n = t.holes[e];\n          this.holes.push(n.clone());\n        }\n        return this;\n      }\n      toJSON() {\n        const t = super.toJSON();\n        (t.uuid = this.uuid), (t.holes = []);\n        for (let e = 0, n = this.holes.length; e < n; e++) {\n          const n = this.holes[e];\n          t.holes.push(n.toJSON());\n        }\n        return t;\n      }\n      fromJSON(t) {\n        super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);\n        for (let e = 0, n = t.holes.length; e < n; e++) {\n          const n = t.holes[e];\n          this.holes.push(new Go().fromJSON(n));\n        }\n        return this;\n      }\n    }\n    const Vo = function (t, e, n = 2) {\n      const i = e && e.length,\n        r = i ? e[0] * n : t.length;\n      let s = Wo(t, 0, r, n, !0);\n      const a = [];\n      if (!s || s.next === s.prev) return a;\n      let o, l, c, h, u, d, p;\n      if (\n        (i &&\n          (s = (function (t, e, n, i) {\n            const r = [];\n            let s, a, o, l, c;\n            for (s = 0, a = e.length; s < a; s++)\n              (o = e[s] * i),\n                (l = s < a - 1 ? e[s + 1] * i : t.length),\n                (c = Wo(t, o, l, i, !1)),\n                c === c.next && (c.steiner = !0),\n                r.push(el(c));\n            for (r.sort(Qo), s = 0; s < r.length; s++)\n              Ko(r[s], n), (n = jo(n, n.next));\n            return n;\n          })(t, e, s, n)),\n        t.length > 80 * n)\n      ) {\n        (o = c = t[0]), (l = h = t[1]);\n        for (let e = n; e < r; e += n)\n          (u = t[e]),\n            (d = t[e + 1]),\n            u < o && (o = u),\n            d < l && (l = d),\n            u > c && (c = u),\n            d > h && (h = d);\n        (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);\n      }\n      return qo(s, a, n, o, l, p), a;\n    };\n    function Wo(t, e, n, i, r) {\n      let s, a;\n      if (\n        r ===\n        (function (t, e, n, i) {\n          let r = 0;\n          for (let s = e, a = n - i; s < n; s += i)\n            (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);\n          return r;\n        })(t, e, n, i) >\n          0\n      )\n        for (s = e; s < n; s += i) a = ul(s, t[s], t[s + 1], a);\n      else for (s = n - i; s >= e; s -= i) a = ul(s, t[s], t[s + 1], a);\n      return a && sl(a, a.next) && (dl(a), (a = a.next)), a;\n    }\n    function jo(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      let n,\n        i = t;\n      do {\n        if (\n          ((n = !1),\n          i.steiner || (!sl(i, i.next) && 0 !== rl(i.prev, i, i.next)))\n        )\n          i = i.next;\n        else {\n          if ((dl(i), (i = e = i.prev), i === i.next)) break;\n          n = !0;\n        }\n      } while (n || i !== e);\n      return e;\n    }\n    function qo(t, e, n, i, r, s, a) {\n      if (!t) return;\n      !a &&\n        s &&\n        (function (t, e, n, i) {\n          let r = t;\n          do {\n            null === r.z && (r.z = tl(r.x, r.y, e, n, i)),\n              (r.prevZ = r.prev),\n              (r.nextZ = r.next),\n              (r = r.next);\n          } while (r !== t);\n          (r.prevZ.nextZ = null),\n            (r.prevZ = null),\n            (function (t) {\n              let e,\n                n,\n                i,\n                r,\n                s,\n                a,\n                o,\n                l,\n                c = 1;\n              do {\n                for (n = t, t = null, s = null, a = 0; n; ) {\n                  for (\n                    a++, i = n, o = 0, e = 0;\n                    e < c && (o++, (i = i.nextZ), i);\n                    e++\n                  );\n                  for (l = c; o > 0 || (l > 0 && i); )\n                    0 !== o && (0 === l || !i || n.z <= i.z)\n                      ? ((r = n), (n = n.nextZ), o--)\n                      : ((r = i), (i = i.nextZ), l--),\n                      s ? (s.nextZ = r) : (t = r),\n                      (r.prevZ = s),\n                      (s = r);\n                  n = i;\n                }\n                (s.nextZ = null), (c *= 2);\n              } while (a > 1);\n            })(r);\n        })(t, i, r, s);\n      let o,\n        l,\n        c = t;\n      for (; t.prev !== t.next; )\n        if (((o = t.prev), (l = t.next), s ? Yo(t, i, r, s) : Xo(t)))\n          e.push(o.i / n),\n            e.push(t.i / n),\n            e.push(l.i / n),\n            dl(t),\n            (t = l.next),\n            (c = l.next);\n        else if ((t = l) === c) {\n          a\n            ? 1 === a\n              ? qo((t = Jo(jo(t), e, n)), e, n, i, r, s, 2)\n              : 2 === a && Zo(t, e, n, i, r, s)\n            : qo(jo(t), e, n, i, r, s, 1);\n          break;\n        }\n    }\n    function Xo(t) {\n      const e = t.prev,\n        n = t,\n        i = t.next;\n      if (rl(e, n, i) >= 0) return !1;\n      let r = t.next.next;\n      for (; r !== t.prev; ) {\n        if (\n          nl(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&\n          rl(r.prev, r, r.next) >= 0\n        )\n          return !1;\n        r = r.next;\n      }\n      return !0;\n    }\n    function Yo(t, e, n, i) {\n      const r = t.prev,\n        s = t,\n        a = t.next;\n      if (rl(r, s, a) >= 0) return !1;\n      const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,\n        l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,\n        c = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,\n        h = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,\n        u = tl(o, l, e, n, i),\n        d = tl(c, h, e, n, i);\n      let p = t.prevZ,\n        m = t.nextZ;\n      for (; p && p.z >= u && m && m.z <= d; ) {\n        if (\n          p !== t.prev &&\n          p !== t.next &&\n          nl(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&\n          rl(p.prev, p, p.next) >= 0\n        )\n          return !1;\n        if (\n          ((p = p.prevZ),\n          m !== t.prev &&\n            m !== t.next &&\n            nl(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&\n            rl(m.prev, m, m.next) >= 0)\n        )\n          return !1;\n        m = m.nextZ;\n      }\n      for (; p && p.z >= u; ) {\n        if (\n          p !== t.prev &&\n          p !== t.next &&\n          nl(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&\n          rl(p.prev, p, p.next) >= 0\n        )\n          return !1;\n        p = p.prevZ;\n      }\n      for (; m && m.z <= d; ) {\n        if (\n          m !== t.prev &&\n          m !== t.next &&\n          nl(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&\n          rl(m.prev, m, m.next) >= 0\n        )\n          return !1;\n        m = m.nextZ;\n      }\n      return !0;\n    }\n    function Jo(t, e, n) {\n      let i = t;\n      do {\n        const r = i.prev,\n          s = i.next.next;\n        !sl(r, s) &&\n          al(r, i, i.next, s) &&\n          cl(r, s) &&\n          cl(s, r) &&\n          (e.push(r.i / n),\n          e.push(i.i / n),\n          e.push(s.i / n),\n          dl(i),\n          dl(i.next),\n          (i = t = s)),\n          (i = i.next);\n      } while (i !== t);\n      return jo(i);\n    }\n    function Zo(t, e, n, i, r, s) {\n      let a = t;\n      do {\n        let t = a.next.next;\n        for (; t !== a.prev; ) {\n          if (a.i !== t.i && il(a, t)) {\n            let o = hl(a, t);\n            return (\n              (a = jo(a, a.next)),\n              (o = jo(o, o.next)),\n              qo(a, e, n, i, r, s),\n              void qo(o, e, n, i, r, s)\n            );\n          }\n          t = t.next;\n        }\n        a = a.next;\n      } while (a !== t);\n    }\n    function Qo(t, e) {\n      return t.x - e.x;\n    }\n    function Ko(t, e) {\n      if (\n        ((e = (function (t, e) {\n          let n = e;\n          const i = t.x,\n            r = t.y;\n          let s,\n            a = -1 / 0;\n          do {\n            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {\n              const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);\n              if (t <= i && t > a) {\n                if (((a = t), t === i)) {\n                  if (r === n.y) return n;\n                  if (r === n.next.y) return n.next;\n                }\n                s = n.x < n.next.x ? n : n.next;\n              }\n            }\n            n = n.next;\n          } while (n !== e);\n          if (!s) return null;\n          if (i === a) return s;\n          const o = s,\n            l = s.x,\n            c = s.y;\n          let h,\n            u = 1 / 0;\n          n = s;\n          do {\n            i >= n.x &&\n              n.x >= l &&\n              i !== n.x &&\n              nl(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) &&\n              ((h = Math.abs(r - n.y) / (i - n.x)),\n              cl(n, t) &&\n                (h < u ||\n                  (h === u && (n.x > s.x || (n.x === s.x && $o(s, n))))) &&\n                ((s = n), (u = h))),\n              (n = n.next);\n          } while (n !== o);\n          return s;\n        })(t, e)),\n        e)\n      ) {\n        const n = hl(e, t);\n        jo(e, e.next), jo(n, n.next);\n      }\n    }\n    function $o(t, e) {\n      return rl(t.prev, t, e.prev) < 0 && rl(e.next, t, t.next) < 0;\n    }\n    function tl(t, e, n, i, r) {\n      return (\n        (t =\n          1431655765 &\n          ((t =\n            858993459 &\n            ((t =\n              252645135 &\n              ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |\n                (t << 4))) |\n              (t << 2))) |\n            (t << 1))) |\n        ((e =\n          1431655765 &\n          ((e =\n            858993459 &\n            ((e =\n              252645135 &\n              ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |\n                (e << 4))) |\n              (e << 2))) |\n            (e << 1))) <<\n          1)\n      );\n    }\n    function el(t) {\n      let e = t,\n        n = t;\n      do {\n        (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);\n      } while (e !== t);\n      return n;\n    }\n    function nl(t, e, n, i, r, s, a, o) {\n      return (\n        (r - a) * (e - o) - (t - a) * (s - o) >= 0 &&\n        (t - a) * (i - o) - (n - a) * (e - o) >= 0 &&\n        (n - a) * (s - o) - (r - a) * (i - o) >= 0\n      );\n    }\n    function il(t, e) {\n      return (\n        t.next.i !== e.i &&\n        t.prev.i !== e.i &&\n        !(function (t, e) {\n          let n = t;\n          do {\n            if (\n              n.i !== t.i &&\n              n.next.i !== t.i &&\n              n.i !== e.i &&\n              n.next.i !== e.i &&\n              al(n, n.next, t, e)\n            )\n              return !0;\n            n = n.next;\n          } while (n !== t);\n          return !1;\n        })(t, e) &&\n        ((cl(t, e) &&\n          cl(e, t) &&\n          (function (t, e) {\n            let n = t,\n              i = !1;\n            const r = (t.x + e.x) / 2,\n              s = (t.y + e.y) / 2;\n            do {\n              n.y > s != n.next.y > s &&\n                n.next.y !== n.y &&\n                r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&\n                (i = !i),\n                (n = n.next);\n            } while (n !== t);\n            return i;\n          })(t, e) &&\n          (rl(t.prev, t, e.prev) || rl(t, e.prev, e))) ||\n          (sl(t, e) && rl(t.prev, t, t.next) > 0 && rl(e.prev, e, e.next) > 0))\n      );\n    }\n    function rl(t, e, n) {\n      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);\n    }\n    function sl(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function al(t, e, n, i) {\n      const r = ll(rl(t, e, n)),\n        s = ll(rl(t, e, i)),\n        a = ll(rl(n, i, t)),\n        o = ll(rl(n, i, e));\n      return (\n        (r !== s && a !== o) ||\n        !(0 !== r || !ol(t, n, e)) ||\n        !(0 !== s || !ol(t, i, e)) ||\n        !(0 !== a || !ol(n, t, i)) ||\n        !(0 !== o || !ol(n, e, i))\n      );\n    }\n    function ol(t, e, n) {\n      return (\n        e.x <= Math.max(t.x, n.x) &&\n        e.x >= Math.min(t.x, n.x) &&\n        e.y <= Math.max(t.y, n.y) &&\n        e.y >= Math.min(t.y, n.y)\n      );\n    }\n    function ll(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function cl(t, e) {\n      return rl(t.prev, t, t.next) < 0\n        ? rl(t, e, t.next) >= 0 && rl(t, t.prev, e) >= 0\n        : rl(t, e, t.prev) < 0 || rl(t, t.next, e) < 0;\n    }\n    function hl(t, e) {\n      const n = new pl(t.i, t.x, t.y),\n        i = new pl(e.i, e.x, e.y),\n        r = t.next,\n        s = e.prev;\n      return (\n        (t.next = e),\n        (e.prev = t),\n        (n.next = r),\n        (r.prev = n),\n        (i.next = n),\n        (n.prev = i),\n        (s.next = i),\n        (i.prev = s),\n        i\n      );\n    }\n    function ul(t, e, n, i) {\n      const r = new pl(t, e, n);\n      return (\n        i\n          ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))\n          : ((r.prev = r), (r.next = r)),\n        r\n      );\n    }\n    function dl(t) {\n      (t.next.prev = t.prev),\n        (t.prev.next = t.next),\n        t.prevZ && (t.prevZ.nextZ = t.nextZ),\n        t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function pl(t, e, n) {\n      (this.i = t),\n        (this.x = e),\n        (this.y = n),\n        (this.prev = null),\n        (this.next = null),\n        (this.z = null),\n        (this.prevZ = null),\n        (this.nextZ = null),\n        (this.steiner = !1);\n    }\n    class ml {\n      static area(t) {\n        const e = t.length;\n        let n = 0;\n        for (let i = e - 1, r = 0; r < e; i = r++)\n          n += t[i].x * t[r].y - t[r].x * t[i].y;\n        return 0.5 * n;\n      }\n      static isClockWise(t) {\n        return ml.area(t) < 0;\n      }\n      static triangulateShape(t, e) {\n        const n = [],\n          i = [],\n          r = [];\n        fl(t), gl(n, t);\n        let s = t.length;\n        e.forEach(fl);\n        for (let t = 0; t < e.length; t++)\n          i.push(s), (s += e[t].length), gl(n, e[t]);\n        const a = Vo(n, i);\n        for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));\n        return r;\n      }\n    }\n    function fl(t) {\n      const e = t.length;\n      e > 2 && t[e - 1].equals(t[0]) && t.pop();\n    }\n    function gl(t, e) {\n      for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);\n    }\n    class vl extends En {\n      constructor(\n        t = new ko([\n          new yt(0.5, 0.5),\n          new yt(-0.5, 0.5),\n          new yt(-0.5, -0.5),\n          new yt(0.5, -0.5),\n        ]),\n        e = {}\n      ) {\n        super(),\n          (this.type = \"ExtrudeGeometry\"),\n          (this.parameters = { shapes: t, options: e }),\n          (t = Array.isArray(t) ? t : [t]);\n        const n = this,\n          i = [],\n          r = [];\n        for (let e = 0, n = t.length; e < n; e++) {\n          s(t[e]);\n        }\n        function s(t) {\n          const s = [],\n            a = void 0 !== e.curveSegments ? e.curveSegments : 12,\n            o = void 0 !== e.steps ? e.steps : 1;\n          let l = void 0 !== e.depth ? e.depth : 1,\n            c = void 0 === e.bevelEnabled || e.bevelEnabled,\n            h = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,\n            u = void 0 !== e.bevelSize ? e.bevelSize : h - 0.1,\n            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,\n            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;\n          const m = e.extrudePath,\n            f = void 0 !== e.UVGenerator ? e.UVGenerator : yl;\n          void 0 !== e.amount &&\n            (console.warn(\n              \"THREE.ExtrudeBufferGeometry: amount has been renamed to depth.\"\n            ),\n            (l = e.amount));\n          let g,\n            v,\n            y,\n            x,\n            _,\n            M = !1;\n          m &&\n            ((g = m.getSpacedPoints(o)),\n            (M = !0),\n            (c = !1),\n            (v = m.computeFrenetFrames(o, !1)),\n            (y = new zt()),\n            (x = new zt()),\n            (_ = new zt())),\n            c || ((p = 0), (h = 0), (u = 0), (d = 0));\n          const b = t.extractPoints(a);\n          let w = b.shape;\n          const S = b.holes;\n          if (!ml.isClockWise(w)) {\n            w = w.reverse();\n            for (let t = 0, e = S.length; t < e; t++) {\n              const e = S[t];\n              ml.isClockWise(e) && (S[t] = e.reverse());\n            }\n          }\n          const T = ml.triangulateShape(w, S),\n            E = w;\n          for (let t = 0, e = S.length; t < e; t++) {\n            const e = S[t];\n            w = w.concat(e);\n          }\n          function A(t, e, n) {\n            return (\n              e || console.error(\"THREE.ExtrudeGeometry: vec does not exist\"),\n              e.clone().multiplyScalar(n).add(t)\n            );\n          }\n          const L = w.length,\n            R = T.length;\n          function C(t, e, n) {\n            let i, r, s;\n            const a = t.x - e.x,\n              o = t.y - e.y,\n              l = n.x - t.x,\n              c = n.y - t.y,\n              h = a * a + o * o,\n              u = a * c - o * l;\n            if (Math.abs(u) > Number.EPSILON) {\n              const u = Math.sqrt(h),\n                d = Math.sqrt(l * l + c * c),\n                p = e.x - o / u,\n                m = e.y + a / u,\n                f =\n                  ((n.x - c / d - p) * c - (n.y + l / d - m) * l) /\n                  (a * c - o * l);\n              (i = p + a * f - t.x), (r = m + o * f - t.y);\n              const g = i * i + r * r;\n              if (g <= 2) return new yt(i, r);\n              s = Math.sqrt(g / 2);\n            } else {\n              let t = !1;\n              a > Number.EPSILON\n                ? l > Number.EPSILON && (t = !0)\n                : a < -Number.EPSILON\n                ? l < -Number.EPSILON && (t = !0)\n                : Math.sign(o) === Math.sign(c) && (t = !0),\n                t\n                  ? ((i = -o), (r = a), (s = Math.sqrt(h)))\n                  : ((i = a), (r = o), (s = Math.sqrt(h / 2)));\n            }\n            return new yt(i / s, r / s);\n          }\n          const P = [];\n          for (\n            let t = 0, e = E.length, n = e - 1, i = t + 1;\n            t < e;\n            t++, n++, i++\n          )\n            n === e && (n = 0),\n              i === e && (i = 0),\n              (P[t] = C(E[t], E[n], E[i]));\n          const I = [];\n          let D,\n            N = P.concat();\n          for (let t = 0, e = S.length; t < e; t++) {\n            const e = S[t];\n            D = [];\n            for (\n              let t = 0, n = e.length, i = n - 1, r = t + 1;\n              t < n;\n              t++, i++, r++\n            )\n              i === n && (i = 0),\n                r === n && (r = 0),\n                (D[t] = C(e[t], e[i], e[r]));\n            I.push(D), (N = N.concat(D));\n          }\n          for (let t = 0; t < p; t++) {\n            const e = t / p,\n              n = h * Math.cos((e * Math.PI) / 2),\n              i = u * Math.sin((e * Math.PI) / 2) + d;\n            for (let t = 0, e = E.length; t < e; t++) {\n              const e = A(E[t], P[t], i);\n              F(e.x, e.y, -n);\n            }\n            for (let t = 0, e = S.length; t < e; t++) {\n              const e = S[t];\n              D = I[t];\n              for (let t = 0, r = e.length; t < r; t++) {\n                const r = A(e[t], D[t], i);\n                F(r.x, r.y, -n);\n              }\n            }\n          }\n          const z = u + d;\n          for (let t = 0; t < L; t++) {\n            const e = c ? A(w[t], N[t], z) : w[t];\n            M\n              ? (x.copy(v.normals[0]).multiplyScalar(e.x),\n                y.copy(v.binormals[0]).multiplyScalar(e.y),\n                _.copy(g[0]).add(x).add(y),\n                F(_.x, _.y, _.z))\n              : F(e.x, e.y, 0);\n          }\n          for (let t = 1; t <= o; t++)\n            for (let e = 0; e < L; e++) {\n              const n = c ? A(w[e], N[e], z) : w[e];\n              M\n                ? (x.copy(v.normals[t]).multiplyScalar(n.x),\n                  y.copy(v.binormals[t]).multiplyScalar(n.y),\n                  _.copy(g[t]).add(x).add(y),\n                  F(_.x, _.y, _.z))\n                : F(n.x, n.y, (l / o) * t);\n            }\n          for (let t = p - 1; t >= 0; t--) {\n            const e = t / p,\n              n = h * Math.cos((e * Math.PI) / 2),\n              i = u * Math.sin((e * Math.PI) / 2) + d;\n            for (let t = 0, e = E.length; t < e; t++) {\n              const e = A(E[t], P[t], i);\n              F(e.x, e.y, l + n);\n            }\n            for (let t = 0, e = S.length; t < e; t++) {\n              const e = S[t];\n              D = I[t];\n              for (let t = 0, r = e.length; t < r; t++) {\n                const r = A(e[t], D[t], i);\n                M\n                  ? F(r.x, r.y + g[o - 1].y, g[o - 1].x + n)\n                  : F(r.x, r.y, l + n);\n              }\n            }\n          }\n          function B(t, e) {\n            let n = t.length;\n            for (; --n >= 0; ) {\n              const i = n;\n              let r = n - 1;\n              r < 0 && (r = t.length - 1);\n              for (let t = 0, n = o + 2 * p; t < n; t++) {\n                const n = L * t,\n                  s = L * (t + 1);\n                U(e + i + n, e + r + n, e + r + s, e + i + s);\n              }\n            }\n          }\n          function F(t, e, n) {\n            s.push(t), s.push(e), s.push(n);\n          }\n          function O(t, e, r) {\n            H(t), H(e), H(r);\n            const s = i.length / 3,\n              a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);\n            G(a[0]), G(a[1]), G(a[2]);\n          }\n          function U(t, e, r, s) {\n            H(t), H(e), H(s), H(e), H(r), H(s);\n            const a = i.length / 3,\n              o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);\n            G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3]);\n          }\n          function H(t) {\n            i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2]);\n          }\n          function G(t) {\n            r.push(t.x), r.push(t.y);\n          }\n          !(function () {\n            const t = i.length / 3;\n            if (c) {\n              let t = 0,\n                e = L * t;\n              for (let t = 0; t < R; t++) {\n                const n = T[t];\n                O(n[2] + e, n[1] + e, n[0] + e);\n              }\n              (t = o + 2 * p), (e = L * t);\n              for (let t = 0; t < R; t++) {\n                const n = T[t];\n                O(n[0] + e, n[1] + e, n[2] + e);\n              }\n            } else {\n              for (let t = 0; t < R; t++) {\n                const e = T[t];\n                O(e[2], e[1], e[0]);\n              }\n              for (let t = 0; t < R; t++) {\n                const e = T[t];\n                O(e[0] + L * o, e[1] + L * o, e[2] + L * o);\n              }\n            }\n            n.addGroup(t, i.length / 3 - t, 0);\n          })(),\n            (function () {\n              const t = i.length / 3;\n              let e = 0;\n              B(E, e), (e += E.length);\n              for (let t = 0, n = S.length; t < n; t++) {\n                const n = S[t];\n                B(n, e), (e += n.length);\n              }\n              n.addGroup(t, i.length / 3 - t, 1);\n            })();\n        }\n        this.setAttribute(\"position\", new vn(i, 3)),\n          this.setAttribute(\"uv\", new vn(r, 2)),\n          this.computeVertexNormals();\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (function (t, e, n) {\n          if (((n.shapes = []), Array.isArray(t)))\n            for (let e = 0, i = t.length; e < i; e++) {\n              const i = t[e];\n              n.shapes.push(i.uuid);\n            }\n          else n.shapes.push(t.uuid);\n          void 0 !== e.extrudePath &&\n            (n.options.extrudePath = e.extrudePath.toJSON());\n          return n;\n        })(this.parameters.shapes, this.parameters.options, t);\n      }\n      static fromJSON(t, e) {\n        const n = [];\n        for (let i = 0, r = t.shapes.length; i < r; i++) {\n          const r = e[t.shapes[i]];\n          n.push(r);\n        }\n        const i = t.options.extrudePath;\n        return (\n          void 0 !== i &&\n            (t.options.extrudePath = new Uo[i.type]().fromJSON(i)),\n          new vl(n, t.options)\n        );\n      }\n    }\n    const yl = {\n      generateTopUV: function (t, e, n, i, r) {\n        const s = e[3 * n],\n          a = e[3 * n + 1],\n          o = e[3 * i],\n          l = e[3 * i + 1],\n          c = e[3 * r],\n          h = e[3 * r + 1];\n        return [new yt(s, a), new yt(o, l), new yt(c, h)];\n      },\n      generateSideWallUV: function (t, e, n, i, r, s) {\n        const a = e[3 * n],\n          o = e[3 * n + 1],\n          l = e[3 * n + 2],\n          c = e[3 * i],\n          h = e[3 * i + 1],\n          u = e[3 * i + 2],\n          d = e[3 * r],\n          p = e[3 * r + 1],\n          m = e[3 * r + 2],\n          f = e[3 * s],\n          g = e[3 * s + 1],\n          v = e[3 * s + 2];\n        return Math.abs(o - h) < Math.abs(a - c)\n          ? [\n              new yt(a, 1 - l),\n              new yt(c, 1 - u),\n              new yt(d, 1 - m),\n              new yt(f, 1 - v),\n            ]\n          : [\n              new yt(o, 1 - l),\n              new yt(h, 1 - u),\n              new yt(p, 1 - m),\n              new yt(g, 1 - v),\n            ];\n      },\n    };\n    class xl extends po {\n      constructor(t = 1, e = 0) {\n        const n = (1 + Math.sqrt(5)) / 2;\n        super(\n          [\n            -1,\n            n,\n            0,\n            1,\n            n,\n            0,\n            -1,\n            -n,\n            0,\n            1,\n            -n,\n            0,\n            0,\n            -1,\n            n,\n            0,\n            1,\n            n,\n            0,\n            -1,\n            -n,\n            0,\n            1,\n            -n,\n            n,\n            0,\n            -1,\n            n,\n            0,\n            1,\n            -n,\n            0,\n            -1,\n            -n,\n            0,\n            1,\n          ],\n          [\n            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,\n            11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,\n            8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,\n          ],\n          t,\n          e\n        ),\n          (this.type = \"IcosahedronGeometry\"),\n          (this.parameters = { radius: t, detail: e });\n      }\n      static fromJSON(t) {\n        return new xl(t.radius, t.detail);\n      }\n    }\n    class _l extends En {\n      constructor(\n        t = [new yt(0, 0.5), new yt(0.5, 0), new yt(0, -0.5)],\n        e = 12,\n        n = 0,\n        i = 2 * Math.PI\n      ) {\n        super(),\n          (this.type = \"LatheGeometry\"),\n          (this.parameters = {\n            points: t,\n            segments: e,\n            phiStart: n,\n            phiLength: i,\n          }),\n          (e = Math.floor(e)),\n          (i = ut(i, 0, 2 * Math.PI));\n        const r = [],\n          s = [],\n          a = [],\n          o = 1 / e,\n          l = new zt(),\n          c = new yt();\n        for (let r = 0; r <= e; r++) {\n          const h = n + r * o * i,\n            u = Math.sin(h),\n            d = Math.cos(h);\n          for (let n = 0; n <= t.length - 1; n++)\n            (l.x = t[n].x * u),\n              (l.y = t[n].y),\n              (l.z = t[n].x * d),\n              s.push(l.x, l.y, l.z),\n              (c.x = r / e),\n              (c.y = n / (t.length - 1)),\n              a.push(c.x, c.y);\n        }\n        for (let n = 0; n < e; n++)\n          for (let e = 0; e < t.length - 1; e++) {\n            const i = e + n * t.length,\n              s = i,\n              a = i + t.length,\n              o = i + t.length + 1,\n              l = i + 1;\n            r.push(s, a, l), r.push(a, o, l);\n          }\n        if (\n          (this.setIndex(r),\n          this.setAttribute(\"position\", new vn(s, 3)),\n          this.setAttribute(\"uv\", new vn(a, 2)),\n          this.computeVertexNormals(),\n          i === 2 * Math.PI)\n        ) {\n          const n = this.attributes.normal.array,\n            i = new zt(),\n            r = new zt(),\n            s = new zt(),\n            a = e * t.length * 3;\n          for (let e = 0, o = 0; e < t.length; e++, o += 3)\n            (i.x = n[o + 0]),\n              (i.y = n[o + 1]),\n              (i.z = n[o + 2]),\n              (r.x = n[a + o + 0]),\n              (r.y = n[a + o + 1]),\n              (r.z = n[a + o + 2]),\n              s.addVectors(i, r).normalize(),\n              (n[o + 0] = n[a + o + 0] = s.x),\n              (n[o + 1] = n[a + o + 1] = s.y),\n              (n[o + 2] = n[a + o + 2] = s.z);\n        }\n      }\n      static fromJSON(t) {\n        return new _l(t.points, t.segments, t.phiStart, t.phiLength);\n      }\n    }\n    class Ml extends po {\n      constructor(t = 1, e = 0) {\n        super(\n          [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],\n          [\n            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,\n            2,\n          ],\n          t,\n          e\n        ),\n          (this.type = \"OctahedronGeometry\"),\n          (this.parameters = { radius: t, detail: e });\n      }\n      static fromJSON(t) {\n        return new Ml(t.radius, t.detail);\n      }\n    }\n    class bl extends En {\n      constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {\n        super(),\n          (this.type = \"RingGeometry\"),\n          (this.parameters = {\n            innerRadius: t,\n            outerRadius: e,\n            thetaSegments: n,\n            phiSegments: i,\n            thetaStart: r,\n            thetaLength: s,\n          }),\n          (n = Math.max(3, n));\n        const a = [],\n          o = [],\n          l = [],\n          c = [];\n        let h = t;\n        const u = (e - t) / (i = Math.max(1, i)),\n          d = new zt(),\n          p = new yt();\n        for (let t = 0; t <= i; t++) {\n          for (let t = 0; t <= n; t++) {\n            const i = r + (t / n) * s;\n            (d.x = h * Math.cos(i)),\n              (d.y = h * Math.sin(i)),\n              o.push(d.x, d.y, d.z),\n              l.push(0, 0, 1),\n              (p.x = (d.x / e + 1) / 2),\n              (p.y = (d.y / e + 1) / 2),\n              c.push(p.x, p.y);\n          }\n          h += u;\n        }\n        for (let t = 0; t < i; t++) {\n          const e = t * (n + 1);\n          for (let t = 0; t < n; t++) {\n            const i = t + e,\n              r = i,\n              s = i + n + 1,\n              o = i + n + 2,\n              l = i + 1;\n            a.push(r, s, l), a.push(s, o, l);\n          }\n        }\n        this.setIndex(a),\n          this.setAttribute(\"position\", new vn(o, 3)),\n          this.setAttribute(\"normal\", new vn(l, 3)),\n          this.setAttribute(\"uv\", new vn(c, 2));\n      }\n      static fromJSON(t) {\n        return new bl(\n          t.innerRadius,\n          t.outerRadius,\n          t.thetaSegments,\n          t.phiSegments,\n          t.thetaStart,\n          t.thetaLength\n        );\n      }\n    }\n    class wl extends En {\n      constructor(\n        t = new ko([new yt(0, 0.5), new yt(-0.5, -0.5), new yt(0.5, -0.5)]),\n        e = 12\n      ) {\n        super(),\n          (this.type = \"ShapeGeometry\"),\n          (this.parameters = { shapes: t, curveSegments: e });\n        const n = [],\n          i = [],\n          r = [],\n          s = [];\n        let a = 0,\n          o = 0;\n        if (!1 === Array.isArray(t)) l(t);\n        else\n          for (let e = 0; e < t.length; e++)\n            l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);\n        function l(t) {\n          const a = i.length / 3,\n            l = t.extractPoints(e);\n          let c = l.shape;\n          const h = l.holes;\n          !1 === ml.isClockWise(c) && (c = c.reverse());\n          for (let t = 0, e = h.length; t < e; t++) {\n            const e = h[t];\n            !0 === ml.isClockWise(e) && (h[t] = e.reverse());\n          }\n          const u = ml.triangulateShape(c, h);\n          for (let t = 0, e = h.length; t < e; t++) {\n            const e = h[t];\n            c = c.concat(e);\n          }\n          for (let t = 0, e = c.length; t < e; t++) {\n            const e = c[t];\n            i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);\n          }\n          for (let t = 0, e = u.length; t < e; t++) {\n            const e = u[t],\n              i = e[0] + a,\n              r = e[1] + a,\n              s = e[2] + a;\n            n.push(i, r, s), (o += 3);\n          }\n        }\n        this.setIndex(n),\n          this.setAttribute(\"position\", new vn(i, 3)),\n          this.setAttribute(\"normal\", new vn(r, 3)),\n          this.setAttribute(\"uv\", new vn(s, 2));\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (function (t, e) {\n          if (((e.shapes = []), Array.isArray(t)))\n            for (let n = 0, i = t.length; n < i; n++) {\n              const i = t[n];\n              e.shapes.push(i.uuid);\n            }\n          else e.shapes.push(t.uuid);\n          return e;\n        })(this.parameters.shapes, t);\n      }\n      static fromJSON(t, e) {\n        const n = [];\n        for (let i = 0, r = t.shapes.length; i < r; i++) {\n          const r = e[t.shapes[i]];\n          n.push(r);\n        }\n        return new wl(n, t.curveSegments);\n      }\n    }\n    class Sl extends En {\n      constructor(\n        t = 1,\n        e = 32,\n        n = 16,\n        i = 0,\n        r = 2 * Math.PI,\n        s = 0,\n        a = Math.PI\n      ) {\n        super(),\n          (this.type = \"SphereGeometry\"),\n          (this.parameters = {\n            radius: t,\n            widthSegments: e,\n            heightSegments: n,\n            phiStart: i,\n            phiLength: r,\n            thetaStart: s,\n            thetaLength: a,\n          }),\n          (e = Math.max(3, Math.floor(e))),\n          (n = Math.max(2, Math.floor(n)));\n        const o = Math.min(s + a, Math.PI);\n        let l = 0;\n        const c = [],\n          h = new zt(),\n          u = new zt(),\n          d = [],\n          p = [],\n          m = [],\n          f = [];\n        for (let d = 0; d <= n; d++) {\n          const g = [],\n            v = d / n;\n          let y = 0;\n          0 == d && 0 == s\n            ? (y = 0.5 / e)\n            : d == n && o == Math.PI && (y = -0.5 / e);\n          for (let n = 0; n <= e; n++) {\n            const o = n / e;\n            (h.x = -t * Math.cos(i + o * r) * Math.sin(s + v * a)),\n              (h.y = t * Math.cos(s + v * a)),\n              (h.z = t * Math.sin(i + o * r) * Math.sin(s + v * a)),\n              p.push(h.x, h.y, h.z),\n              u.copy(h).normalize(),\n              m.push(u.x, u.y, u.z),\n              f.push(o + y, 1 - v),\n              g.push(l++);\n          }\n          c.push(g);\n        }\n        for (let t = 0; t < n; t++)\n          for (let i = 0; i < e; i++) {\n            const e = c[t][i + 1],\n              r = c[t][i],\n              a = c[t + 1][i],\n              l = c[t + 1][i + 1];\n            (0 !== t || s > 0) && d.push(e, r, l),\n              (t !== n - 1 || o < Math.PI) && d.push(r, a, l);\n          }\n        this.setIndex(d),\n          this.setAttribute(\"position\", new vn(p, 3)),\n          this.setAttribute(\"normal\", new vn(m, 3)),\n          this.setAttribute(\"uv\", new vn(f, 2));\n      }\n      static fromJSON(t) {\n        return new Sl(\n          t.radius,\n          t.widthSegments,\n          t.heightSegments,\n          t.phiStart,\n          t.phiLength,\n          t.thetaStart,\n          t.thetaLength\n        );\n      }\n    }\n    class Tl extends po {\n      constructor(t = 1, e = 0) {\n        super(\n          [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],\n          [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],\n          t,\n          e\n        ),\n          (this.type = \"TetrahedronGeometry\"),\n          (this.parameters = { radius: t, detail: e });\n      }\n      static fromJSON(t) {\n        return new Tl(t.radius, t.detail);\n      }\n    }\n    class El extends En {\n      constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {\n        super(),\n          (this.type = \"TorusGeometry\"),\n          (this.parameters = {\n            radius: t,\n            tube: e,\n            radialSegments: n,\n            tubularSegments: i,\n            arc: r,\n          }),\n          (n = Math.floor(n)),\n          (i = Math.floor(i));\n        const s = [],\n          a = [],\n          o = [],\n          l = [],\n          c = new zt(),\n          h = new zt(),\n          u = new zt();\n        for (let s = 0; s <= n; s++)\n          for (let d = 0; d <= i; d++) {\n            const p = (d / i) * r,\n              m = (s / n) * Math.PI * 2;\n            (h.x = (t + e * Math.cos(m)) * Math.cos(p)),\n              (h.y = (t + e * Math.cos(m)) * Math.sin(p)),\n              (h.z = e * Math.sin(m)),\n              a.push(h.x, h.y, h.z),\n              (c.x = t * Math.cos(p)),\n              (c.y = t * Math.sin(p)),\n              u.subVectors(h, c).normalize(),\n              o.push(u.x, u.y, u.z),\n              l.push(d / i),\n              l.push(s / n);\n          }\n        for (let t = 1; t <= n; t++)\n          for (let e = 1; e <= i; e++) {\n            const n = (i + 1) * t + e - 1,\n              r = (i + 1) * (t - 1) + e - 1,\n              a = (i + 1) * (t - 1) + e,\n              o = (i + 1) * t + e;\n            s.push(n, r, o), s.push(r, a, o);\n          }\n        this.setIndex(s),\n          this.setAttribute(\"position\", new vn(a, 3)),\n          this.setAttribute(\"normal\", new vn(o, 3)),\n          this.setAttribute(\"uv\", new vn(l, 2));\n      }\n      static fromJSON(t) {\n        return new El(\n          t.radius,\n          t.tube,\n          t.radialSegments,\n          t.tubularSegments,\n          t.arc\n        );\n      }\n    }\n    class Al extends En {\n      constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, s = 3) {\n        super(),\n          (this.type = \"TorusKnotGeometry\"),\n          (this.parameters = {\n            radius: t,\n            tube: e,\n            tubularSegments: n,\n            radialSegments: i,\n            p: r,\n            q: s,\n          }),\n          (n = Math.floor(n)),\n          (i = Math.floor(i));\n        const a = [],\n          o = [],\n          l = [],\n          c = [],\n          h = new zt(),\n          u = new zt(),\n          d = new zt(),\n          p = new zt(),\n          m = new zt(),\n          f = new zt(),\n          g = new zt();\n        for (let a = 0; a <= n; ++a) {\n          const y = (a / n) * r * Math.PI * 2;\n          v(y, r, s, t, d),\n            v(y + 0.01, r, s, t, p),\n            f.subVectors(p, d),\n            g.addVectors(p, d),\n            m.crossVectors(f, g),\n            g.crossVectors(m, f),\n            m.normalize(),\n            g.normalize();\n          for (let t = 0; t <= i; ++t) {\n            const r = (t / i) * Math.PI * 2,\n              s = -e * Math.cos(r),\n              p = e * Math.sin(r);\n            (h.x = d.x + (s * g.x + p * m.x)),\n              (h.y = d.y + (s * g.y + p * m.y)),\n              (h.z = d.z + (s * g.z + p * m.z)),\n              o.push(h.x, h.y, h.z),\n              u.subVectors(h, d).normalize(),\n              l.push(u.x, u.y, u.z),\n              c.push(a / n),\n              c.push(t / i);\n          }\n        }\n        for (let t = 1; t <= n; t++)\n          for (let e = 1; e <= i; e++) {\n            const n = (i + 1) * (t - 1) + (e - 1),\n              r = (i + 1) * t + (e - 1),\n              s = (i + 1) * t + e,\n              o = (i + 1) * (t - 1) + e;\n            a.push(n, r, o), a.push(r, s, o);\n          }\n        function v(t, e, n, i, r) {\n          const s = Math.cos(t),\n            a = Math.sin(t),\n            o = (n / e) * t,\n            l = Math.cos(o);\n          (r.x = i * (2 + l) * 0.5 * s),\n            (r.y = i * (2 + l) * a * 0.5),\n            (r.z = i * Math.sin(o) * 0.5);\n        }\n        this.setIndex(a),\n          this.setAttribute(\"position\", new vn(o, 3)),\n          this.setAttribute(\"normal\", new vn(l, 3)),\n          this.setAttribute(\"uv\", new vn(c, 2));\n      }\n      static fromJSON(t) {\n        return new Al(\n          t.radius,\n          t.tube,\n          t.tubularSegments,\n          t.radialSegments,\n          t.p,\n          t.q\n        );\n      }\n    }\n    class Ll extends En {\n      constructor(\n        t = new Fo(new zt(-1, -1, 0), new zt(-1, 1, 0), new zt(1, 1, 0)),\n        e = 64,\n        n = 1,\n        i = 8,\n        r = !1\n      ) {\n        super(),\n          (this.type = \"TubeGeometry\"),\n          (this.parameters = {\n            path: t,\n            tubularSegments: e,\n            radius: n,\n            radialSegments: i,\n            closed: r,\n          });\n        const s = t.computeFrenetFrames(e, r);\n        (this.tangents = s.tangents),\n          (this.normals = s.normals),\n          (this.binormals = s.binormals);\n        const a = new zt(),\n          o = new zt(),\n          l = new yt();\n        let c = new zt();\n        const h = [],\n          u = [],\n          d = [],\n          p = [];\n        function m(r) {\n          c = t.getPointAt(r / e, c);\n          const l = s.normals[r],\n            d = s.binormals[r];\n          for (let t = 0; t <= i; t++) {\n            const e = (t / i) * Math.PI * 2,\n              r = Math.sin(e),\n              s = -Math.cos(e);\n            (o.x = s * l.x + r * d.x),\n              (o.y = s * l.y + r * d.y),\n              (o.z = s * l.z + r * d.z),\n              o.normalize(),\n              u.push(o.x, o.y, o.z),\n              (a.x = c.x + n * o.x),\n              (a.y = c.y + n * o.y),\n              (a.z = c.z + n * o.z),\n              h.push(a.x, a.y, a.z);\n          }\n        }\n        !(function () {\n          for (let t = 0; t < e; t++) m(t);\n          m(!1 === r ? e : 0),\n            (function () {\n              for (let t = 0; t <= e; t++)\n                for (let n = 0; n <= i; n++)\n                  (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);\n            })(),\n            (function () {\n              for (let t = 1; t <= e; t++)\n                for (let e = 1; e <= i; e++) {\n                  const n = (i + 1) * (t - 1) + (e - 1),\n                    r = (i + 1) * t + (e - 1),\n                    s = (i + 1) * t + e,\n                    a = (i + 1) * (t - 1) + e;\n                  p.push(n, r, a), p.push(r, s, a);\n                }\n            })();\n        })(),\n          this.setIndex(p),\n          this.setAttribute(\"position\", new vn(h, 3)),\n          this.setAttribute(\"normal\", new vn(u, 3)),\n          this.setAttribute(\"uv\", new vn(d, 2));\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return (t.path = this.parameters.path.toJSON()), t;\n      }\n      static fromJSON(t) {\n        return new Ll(\n          new Uo[t.path.type]().fromJSON(t.path),\n          t.tubularSegments,\n          t.radius,\n          t.radialSegments,\n          t.closed\n        );\n      }\n    }\n    class Rl extends En {\n      constructor(t = null) {\n        if (\n          (super(),\n          (this.type = \"WireframeGeometry\"),\n          (this.parameters = { geometry: t }),\n          null !== t)\n        ) {\n          const e = [],\n            n = new Set(),\n            i = new zt(),\n            r = new zt();\n          if (null !== t.index) {\n            const s = t.attributes.position,\n              a = t.index;\n            let o = t.groups;\n            0 === o.length &&\n              (o = [{ start: 0, count: a.count, materialIndex: 0 }]);\n            for (let t = 0, l = o.length; t < l; ++t) {\n              const l = o[t],\n                c = l.start;\n              for (let t = c, o = c + l.count; t < o; t += 3)\n                for (let o = 0; o < 3; o++) {\n                  const l = a.getX(t + o),\n                    c = a.getX(t + ((o + 1) % 3));\n                  i.fromBufferAttribute(s, l),\n                    r.fromBufferAttribute(s, c),\n                    !0 === Cl(i, r, n) &&\n                      (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));\n                }\n            }\n          } else {\n            const s = t.attributes.position;\n            for (let t = 0, a = s.count / 3; t < a; t++)\n              for (let a = 0; a < 3; a++) {\n                const o = 3 * t + a,\n                  l = 3 * t + ((a + 1) % 3);\n                i.fromBufferAttribute(s, o),\n                  r.fromBufferAttribute(s, l),\n                  !0 === Cl(i, r, n) &&\n                    (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z));\n              }\n          }\n          this.setAttribute(\"position\", new vn(e, 3));\n        }\n      }\n    }\n    function Cl(t, e, n) {\n      const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,\n        r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;\n      return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), !0);\n    }\n    var Pl = Object.freeze({\n      __proto__: null,\n      BoxGeometry: qn,\n      BoxBufferGeometry: qn,\n      CircleGeometry: co,\n      CircleBufferGeometry: co,\n      ConeGeometry: uo,\n      ConeBufferGeometry: uo,\n      CylinderGeometry: ho,\n      CylinderBufferGeometry: ho,\n      DodecahedronGeometry: mo,\n      DodecahedronBufferGeometry: mo,\n      EdgesGeometry: xo,\n      ExtrudeGeometry: vl,\n      ExtrudeBufferGeometry: vl,\n      IcosahedronGeometry: xl,\n      IcosahedronBufferGeometry: xl,\n      LatheGeometry: _l,\n      LatheBufferGeometry: _l,\n      OctahedronGeometry: Ml,\n      OctahedronBufferGeometry: Ml,\n      PlaneGeometry: di,\n      PlaneBufferGeometry: di,\n      PolyhedronGeometry: po,\n      PolyhedronBufferGeometry: po,\n      RingGeometry: bl,\n      RingBufferGeometry: bl,\n      ShapeGeometry: wl,\n      ShapeBufferGeometry: wl,\n      SphereGeometry: Sl,\n      SphereBufferGeometry: Sl,\n      TetrahedronGeometry: Tl,\n      TetrahedronBufferGeometry: Tl,\n      TorusGeometry: El,\n      TorusBufferGeometry: El,\n      TorusKnotGeometry: Al,\n      TorusKnotBufferGeometry: Al,\n      TubeGeometry: Ll,\n      TubeBufferGeometry: Ll,\n      WireframeGeometry: Rl,\n    });\n    class Il extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"ShadowMaterial\"),\n          (this.color = new rn(0)),\n          (this.transparent = !0),\n          this.setValues(t);\n      }\n      copy(t) {\n        return super.copy(t), this.color.copy(t.color), this;\n      }\n    }\n    Il.prototype.isShadowMaterial = !0;\n    class Dl extends Ze {\n      constructor(t) {\n        super(),\n          (this.defines = { STANDARD: \"\" }),\n          (this.type = \"MeshStandardMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.roughness = 1),\n          (this.metalness = 0),\n          (this.map = null),\n          (this.lightMap = null),\n          (this.lightMapIntensity = 1),\n          (this.aoMap = null),\n          (this.aoMapIntensity = 1),\n          (this.emissive = new rn(0)),\n          (this.emissiveIntensity = 1),\n          (this.emissiveMap = null),\n          (this.bumpMap = null),\n          (this.bumpScale = 1),\n          (this.normalMap = null),\n          (this.normalMapType = 0),\n          (this.normalScale = new yt(1, 1)),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.roughnessMap = null),\n          (this.metalnessMap = null),\n          (this.alphaMap = null),\n          (this.envMap = null),\n          (this.envMapIntensity = 1),\n          (this.refractionRatio = 0.98),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.wireframeLinecap = \"round\"),\n          (this.wireframeLinejoin = \"round\"),\n          (this.flatShading = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.defines = { STANDARD: \"\" }),\n          this.color.copy(t.color),\n          (this.roughness = t.roughness),\n          (this.metalness = t.metalness),\n          (this.map = t.map),\n          (this.lightMap = t.lightMap),\n          (this.lightMapIntensity = t.lightMapIntensity),\n          (this.aoMap = t.aoMap),\n          (this.aoMapIntensity = t.aoMapIntensity),\n          this.emissive.copy(t.emissive),\n          (this.emissiveMap = t.emissiveMap),\n          (this.emissiveIntensity = t.emissiveIntensity),\n          (this.bumpMap = t.bumpMap),\n          (this.bumpScale = t.bumpScale),\n          (this.normalMap = t.normalMap),\n          (this.normalMapType = t.normalMapType),\n          this.normalScale.copy(t.normalScale),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.roughnessMap = t.roughnessMap),\n          (this.metalnessMap = t.metalnessMap),\n          (this.alphaMap = t.alphaMap),\n          (this.envMap = t.envMap),\n          (this.envMapIntensity = t.envMapIntensity),\n          (this.refractionRatio = t.refractionRatio),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.wireframeLinecap = t.wireframeLinecap),\n          (this.wireframeLinejoin = t.wireframeLinejoin),\n          (this.flatShading = t.flatShading),\n          this\n        );\n      }\n    }\n    Dl.prototype.isMeshStandardMaterial = !0;\n    class Nl extends Dl {\n      constructor(t) {\n        super(),\n          (this.defines = { STANDARD: \"\", PHYSICAL: \"\" }),\n          (this.type = \"MeshPhysicalMaterial\"),\n          (this.clearcoatMap = null),\n          (this.clearcoatRoughness = 0),\n          (this.clearcoatRoughnessMap = null),\n          (this.clearcoatNormalScale = new yt(1, 1)),\n          (this.clearcoatNormalMap = null),\n          (this.ior = 1.5),\n          Object.defineProperty(this, \"reflectivity\", {\n            get: function () {\n              return ut((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);\n            },\n            set: function (t) {\n              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);\n            },\n          }),\n          (this.sheenColor = new rn(0)),\n          (this.sheenColorMap = null),\n          (this.sheenRoughness = 1),\n          (this.sheenRoughnessMap = null),\n          (this.transmissionMap = null),\n          (this.thickness = 0.01),\n          (this.thicknessMap = null),\n          (this.attenuationDistance = 0),\n          (this.attenuationColor = new rn(1, 1, 1)),\n          (this.specularIntensity = 1),\n          (this.specularIntensityMap = null),\n          (this.specularColor = new rn(1, 1, 1)),\n          (this.specularColorMap = null),\n          (this._sheen = 0),\n          (this._clearcoat = 0),\n          (this._transmission = 0),\n          this.setValues(t);\n      }\n      get sheen() {\n        return this._sheen;\n      }\n      set sheen(t) {\n        this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);\n      }\n      get clearcoat() {\n        return this._clearcoat;\n      }\n      set clearcoat(t) {\n        this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);\n      }\n      get transmission() {\n        return this._transmission;\n      }\n      set transmission(t) {\n        this._transmission > 0 != t > 0 && this.version++,\n          (this._transmission = t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.defines = { STANDARD: \"\", PHYSICAL: \"\" }),\n          (this.clearcoat = t.clearcoat),\n          (this.clearcoatMap = t.clearcoatMap),\n          (this.clearcoatRoughness = t.clearcoatRoughness),\n          (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),\n          (this.clearcoatNormalMap = t.clearcoatNormalMap),\n          this.clearcoatNormalScale.copy(t.clearcoatNormalScale),\n          (this.ior = t.ior),\n          (this.sheen = t.sheen),\n          this.sheenColor.copy(t.sheenColor),\n          (this.sheenColorMap = t.sheenColorMap),\n          (this.sheenRoughness = t.sheenRoughness),\n          (this.sheenRoughnessMap = t.sheenRoughnessMap),\n          (this.transmission = t.transmission),\n          (this.transmissionMap = t.transmissionMap),\n          (this.thickness = t.thickness),\n          (this.thicknessMap = t.thicknessMap),\n          (this.attenuationDistance = t.attenuationDistance),\n          this.attenuationColor.copy(t.attenuationColor),\n          (this.specularIntensity = t.specularIntensity),\n          (this.specularIntensityMap = t.specularIntensityMap),\n          this.specularColor.copy(t.specularColor),\n          (this.specularColorMap = t.specularColorMap),\n          this\n        );\n      }\n    }\n    Nl.prototype.isMeshPhysicalMaterial = !0;\n    class zl extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshPhongMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.specular = new rn(1118481)),\n          (this.shininess = 30),\n          (this.map = null),\n          (this.lightMap = null),\n          (this.lightMapIntensity = 1),\n          (this.aoMap = null),\n          (this.aoMapIntensity = 1),\n          (this.emissive = new rn(0)),\n          (this.emissiveIntensity = 1),\n          (this.emissiveMap = null),\n          (this.bumpMap = null),\n          (this.bumpScale = 1),\n          (this.normalMap = null),\n          (this.normalMapType = 0),\n          (this.normalScale = new yt(1, 1)),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.specularMap = null),\n          (this.alphaMap = null),\n          (this.envMap = null),\n          (this.combine = 0),\n          (this.reflectivity = 1),\n          (this.refractionRatio = 0.98),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.wireframeLinecap = \"round\"),\n          (this.wireframeLinejoin = \"round\"),\n          (this.flatShading = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          this.specular.copy(t.specular),\n          (this.shininess = t.shininess),\n          (this.map = t.map),\n          (this.lightMap = t.lightMap),\n          (this.lightMapIntensity = t.lightMapIntensity),\n          (this.aoMap = t.aoMap),\n          (this.aoMapIntensity = t.aoMapIntensity),\n          this.emissive.copy(t.emissive),\n          (this.emissiveMap = t.emissiveMap),\n          (this.emissiveIntensity = t.emissiveIntensity),\n          (this.bumpMap = t.bumpMap),\n          (this.bumpScale = t.bumpScale),\n          (this.normalMap = t.normalMap),\n          (this.normalMapType = t.normalMapType),\n          this.normalScale.copy(t.normalScale),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.specularMap = t.specularMap),\n          (this.alphaMap = t.alphaMap),\n          (this.envMap = t.envMap),\n          (this.combine = t.combine),\n          (this.reflectivity = t.reflectivity),\n          (this.refractionRatio = t.refractionRatio),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.wireframeLinecap = t.wireframeLinecap),\n          (this.wireframeLinejoin = t.wireframeLinejoin),\n          (this.flatShading = t.flatShading),\n          this\n        );\n      }\n    }\n    zl.prototype.isMeshPhongMaterial = !0;\n    class Bl extends Ze {\n      constructor(t) {\n        super(),\n          (this.defines = { TOON: \"\" }),\n          (this.type = \"MeshToonMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.map = null),\n          (this.gradientMap = null),\n          (this.lightMap = null),\n          (this.lightMapIntensity = 1),\n          (this.aoMap = null),\n          (this.aoMapIntensity = 1),\n          (this.emissive = new rn(0)),\n          (this.emissiveIntensity = 1),\n          (this.emissiveMap = null),\n          (this.bumpMap = null),\n          (this.bumpScale = 1),\n          (this.normalMap = null),\n          (this.normalMapType = 0),\n          (this.normalScale = new yt(1, 1)),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.alphaMap = null),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.wireframeLinecap = \"round\"),\n          (this.wireframeLinejoin = \"round\"),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.map = t.map),\n          (this.gradientMap = t.gradientMap),\n          (this.lightMap = t.lightMap),\n          (this.lightMapIntensity = t.lightMapIntensity),\n          (this.aoMap = t.aoMap),\n          (this.aoMapIntensity = t.aoMapIntensity),\n          this.emissive.copy(t.emissive),\n          (this.emissiveMap = t.emissiveMap),\n          (this.emissiveIntensity = t.emissiveIntensity),\n          (this.bumpMap = t.bumpMap),\n          (this.bumpScale = t.bumpScale),\n          (this.normalMap = t.normalMap),\n          (this.normalMapType = t.normalMapType),\n          this.normalScale.copy(t.normalScale),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.alphaMap = t.alphaMap),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.wireframeLinecap = t.wireframeLinecap),\n          (this.wireframeLinejoin = t.wireframeLinejoin),\n          this\n        );\n      }\n    }\n    Bl.prototype.isMeshToonMaterial = !0;\n    class Fl extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshNormalMaterial\"),\n          (this.bumpMap = null),\n          (this.bumpScale = 1),\n          (this.normalMap = null),\n          (this.normalMapType = 0),\n          (this.normalScale = new yt(1, 1)),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.fog = !1),\n          (this.flatShading = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.bumpMap = t.bumpMap),\n          (this.bumpScale = t.bumpScale),\n          (this.normalMap = t.normalMap),\n          (this.normalMapType = t.normalMapType),\n          this.normalScale.copy(t.normalScale),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.flatShading = t.flatShading),\n          this\n        );\n      }\n    }\n    Fl.prototype.isMeshNormalMaterial = !0;\n    class Ol extends Ze {\n      constructor(t) {\n        super(),\n          (this.type = \"MeshLambertMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.map = null),\n          (this.lightMap = null),\n          (this.lightMapIntensity = 1),\n          (this.aoMap = null),\n          (this.aoMapIntensity = 1),\n          (this.emissive = new rn(0)),\n          (this.emissiveIntensity = 1),\n          (this.emissiveMap = null),\n          (this.specularMap = null),\n          (this.alphaMap = null),\n          (this.envMap = null),\n          (this.combine = 0),\n          (this.reflectivity = 1),\n          (this.refractionRatio = 0.98),\n          (this.wireframe = !1),\n          (this.wireframeLinewidth = 1),\n          (this.wireframeLinecap = \"round\"),\n          (this.wireframeLinejoin = \"round\"),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.map = t.map),\n          (this.lightMap = t.lightMap),\n          (this.lightMapIntensity = t.lightMapIntensity),\n          (this.aoMap = t.aoMap),\n          (this.aoMapIntensity = t.aoMapIntensity),\n          this.emissive.copy(t.emissive),\n          (this.emissiveMap = t.emissiveMap),\n          (this.emissiveIntensity = t.emissiveIntensity),\n          (this.specularMap = t.specularMap),\n          (this.alphaMap = t.alphaMap),\n          (this.envMap = t.envMap),\n          (this.combine = t.combine),\n          (this.reflectivity = t.reflectivity),\n          (this.refractionRatio = t.refractionRatio),\n          (this.wireframe = t.wireframe),\n          (this.wireframeLinewidth = t.wireframeLinewidth),\n          (this.wireframeLinecap = t.wireframeLinecap),\n          (this.wireframeLinejoin = t.wireframeLinejoin),\n          this\n        );\n      }\n    }\n    Ol.prototype.isMeshLambertMaterial = !0;\n    class Ul extends Ze {\n      constructor(t) {\n        super(),\n          (this.defines = { MATCAP: \"\" }),\n          (this.type = \"MeshMatcapMaterial\"),\n          (this.color = new rn(16777215)),\n          (this.matcap = null),\n          (this.map = null),\n          (this.bumpMap = null),\n          (this.bumpScale = 1),\n          (this.normalMap = null),\n          (this.normalMapType = 0),\n          (this.normalScale = new yt(1, 1)),\n          (this.displacementMap = null),\n          (this.displacementScale = 1),\n          (this.displacementBias = 0),\n          (this.alphaMap = null),\n          (this.flatShading = !1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.defines = { MATCAP: \"\" }),\n          this.color.copy(t.color),\n          (this.matcap = t.matcap),\n          (this.map = t.map),\n          (this.bumpMap = t.bumpMap),\n          (this.bumpScale = t.bumpScale),\n          (this.normalMap = t.normalMap),\n          (this.normalMapType = t.normalMapType),\n          this.normalScale.copy(t.normalScale),\n          (this.displacementMap = t.displacementMap),\n          (this.displacementScale = t.displacementScale),\n          (this.displacementBias = t.displacementBias),\n          (this.alphaMap = t.alphaMap),\n          (this.flatShading = t.flatShading),\n          this\n        );\n      }\n    }\n    Ul.prototype.isMeshMatcapMaterial = !0;\n    class Hl extends Ga {\n      constructor(t) {\n        super(),\n          (this.type = \"LineDashedMaterial\"),\n          (this.scale = 1),\n          (this.dashSize = 3),\n          (this.gapSize = 1),\n          this.setValues(t);\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.scale = t.scale),\n          (this.dashSize = t.dashSize),\n          (this.gapSize = t.gapSize),\n          this\n        );\n      }\n    }\n    Hl.prototype.isLineDashedMaterial = !0;\n    var Gl = Object.freeze({\n      __proto__: null,\n      ShadowMaterial: Il,\n      SpriteMaterial: sa,\n      RawShaderMaterial: wi,\n      ShaderMaterial: Zn,\n      PointsMaterial: Ka,\n      MeshPhysicalMaterial: Nl,\n      MeshStandardMaterial: Dl,\n      MeshPhongMaterial: zl,\n      MeshToonMaterial: Bl,\n      MeshNormalMaterial: Fl,\n      MeshLambertMaterial: Ol,\n      MeshDepthMaterial: Us,\n      MeshDistanceMaterial: Hs,\n      MeshBasicMaterial: sn,\n      MeshMatcapMaterial: Ul,\n      LineDashedMaterial: Hl,\n      LineBasicMaterial: Ga,\n      Material: Ze,\n    });\n    const kl = {\n      arraySlice: function (t, e, n) {\n        return kl.isTypedArray(t)\n          ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))\n          : t.slice(e, n);\n      },\n      convertArray: function (t, e, n) {\n        return !t || (!n && t.constructor === e)\n          ? t\n          : \"number\" == typeof e.BYTES_PER_ELEMENT\n          ? new e(t)\n          : Array.prototype.slice.call(t);\n      },\n      isTypedArray: function (t) {\n        return ArrayBuffer.isView(t) && !(t instanceof DataView);\n      },\n      getKeyframeOrder: function (t) {\n        const e = t.length,\n          n = new Array(e);\n        for (let t = 0; t !== e; ++t) n[t] = t;\n        return (\n          n.sort(function (e, n) {\n            return t[e] - t[n];\n          }),\n          n\n        );\n      },\n      sortedArray: function (t, e, n) {\n        const i = t.length,\n          r = new t.constructor(i);\n        for (let s = 0, a = 0; a !== i; ++s) {\n          const i = n[s] * e;\n          for (let n = 0; n !== e; ++n) r[a++] = t[i + n];\n        }\n        return r;\n      },\n      flattenJSON: function (t, e, n, i) {\n        let r = 1,\n          s = t[0];\n        for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];\n        if (void 0 === s) return;\n        let a = s[i];\n        if (void 0 !== a)\n          if (Array.isArray(a))\n            do {\n              (a = s[i]),\n                void 0 !== a && (e.push(s.time), n.push.apply(n, a)),\n                (s = t[r++]);\n            } while (void 0 !== s);\n          else if (void 0 !== a.toArray)\n            do {\n              (a = s[i]),\n                void 0 !== a && (e.push(s.time), a.toArray(n, n.length)),\n                (s = t[r++]);\n            } while (void 0 !== s);\n          else\n            do {\n              (a = s[i]),\n                void 0 !== a && (e.push(s.time), n.push(a)),\n                (s = t[r++]);\n            } while (void 0 !== s);\n      },\n      subclip: function (t, e, n, i, r = 30) {\n        const s = t.clone();\n        s.name = e;\n        const a = [];\n        for (let t = 0; t < s.tracks.length; ++t) {\n          const e = s.tracks[t],\n            o = e.getValueSize(),\n            l = [],\n            c = [];\n          for (let t = 0; t < e.times.length; ++t) {\n            const s = e.times[t] * r;\n            if (!(s < n || s >= i)) {\n              l.push(e.times[t]);\n              for (let n = 0; n < o; ++n) c.push(e.values[t * o + n]);\n            }\n          }\n          0 !== l.length &&\n            ((e.times = kl.convertArray(l, e.times.constructor)),\n            (e.values = kl.convertArray(c, e.values.constructor)),\n            a.push(e));\n        }\n        s.tracks = a;\n        let o = 1 / 0;\n        for (let t = 0; t < s.tracks.length; ++t)\n          o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);\n        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);\n        return s.resetDuration(), s;\n      },\n      makeClipAdditive: function (t, e = 0, n = t, i = 30) {\n        i <= 0 && (i = 30);\n        const r = n.tracks.length,\n          s = e / i;\n        for (let e = 0; e < r; ++e) {\n          const i = n.tracks[e],\n            r = i.ValueTypeName;\n          if (\"bool\" === r || \"string\" === r) continue;\n          const a = t.tracks.find(function (t) {\n            return t.name === i.name && t.ValueTypeName === r;\n          });\n          if (void 0 === a) continue;\n          let o = 0;\n          const l = i.getValueSize();\n          i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&\n            (o = l / 3);\n          let c = 0;\n          const h = a.getValueSize();\n          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&\n            (c = h / 3);\n          const u = i.times.length - 1;\n          let d;\n          if (s <= i.times[0]) {\n            const t = o,\n              e = l - o;\n            d = kl.arraySlice(i.values, t, e);\n          } else if (s >= i.times[u]) {\n            const t = u * l + o,\n              e = t + l - o;\n            d = kl.arraySlice(i.values, t, e);\n          } else {\n            const t = i.createInterpolant(),\n              e = o,\n              n = l - o;\n            t.evaluate(s), (d = kl.arraySlice(t.resultBuffer, e, n));\n          }\n          if (\"quaternion\" === r) {\n            new Nt().fromArray(d).normalize().conjugate().toArray(d);\n          }\n          const p = a.times.length;\n          for (let t = 0; t < p; ++t) {\n            const e = t * h + c;\n            if (\"quaternion\" === r)\n              Nt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);\n            else {\n              const t = h - 2 * c;\n              for (let n = 0; n < t; ++n) a.values[e + n] -= d[n];\n            }\n          }\n        }\n        return (t.blendMode = q), t;\n      },\n    };\n    class Vl {\n      constructor(t, e, n, i) {\n        (this.parameterPositions = t),\n          (this._cachedIndex = 0),\n          (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),\n          (this.sampleValues = e),\n          (this.valueSize = n),\n          (this.settings = null),\n          (this.DefaultSettings_ = {});\n      }\n      evaluate(t) {\n        const e = this.parameterPositions;\n        let n = this._cachedIndex,\n          i = e[n],\n          r = e[n - 1];\n        t: {\n          e: {\n            let s;\n            n: {\n              i: if (!(t < i)) {\n                for (let s = n + 2; ; ) {\n                  if (void 0 === i) {\n                    if (t < r) break i;\n                    return (\n                      (n = e.length),\n                      (this._cachedIndex = n),\n                      this.afterEnd_(n - 1, t, r)\n                    );\n                  }\n                  if (n === s) break;\n                  if (((r = i), (i = e[++n]), t < i)) break e;\n                }\n                s = e.length;\n                break n;\n              }\n              if (t >= r) break t;\n              {\n                const a = e[1];\n                t < a && ((n = 2), (r = a));\n                for (let s = n - 2; ; ) {\n                  if (void 0 === r)\n                    return (this._cachedIndex = 0), this.beforeStart_(0, t, i);\n                  if (n === s) break;\n                  if (((i = r), (r = e[--n - 1]), t >= r)) break e;\n                }\n                (s = n), (n = 0);\n              }\n            }\n            for (; n < s; ) {\n              const i = (n + s) >>> 1;\n              t < e[i] ? (s = i) : (n = i + 1);\n            }\n            if (((i = e[n]), (r = e[n - 1]), void 0 === r))\n              return (this._cachedIndex = 0), this.beforeStart_(0, t, i);\n            if (void 0 === i)\n              return (\n                (n = e.length),\n                (this._cachedIndex = n),\n                this.afterEnd_(n - 1, r, t)\n              );\n          }\n          (this._cachedIndex = n), this.intervalChanged_(n, r, i);\n        }\n        return this.interpolate_(n, r, t, i);\n      }\n      getSettings_() {\n        return this.settings || this.DefaultSettings_;\n      }\n      copySampleValue_(t) {\n        const e = this.resultBuffer,\n          n = this.sampleValues,\n          i = this.valueSize,\n          r = t * i;\n        for (let t = 0; t !== i; ++t) e[t] = n[r + t];\n        return e;\n      }\n      interpolate_() {\n        throw new Error(\"call to abstract method\");\n      }\n      intervalChanged_() {}\n    }\n    (Vl.prototype.beforeStart_ = Vl.prototype.copySampleValue_),\n      (Vl.prototype.afterEnd_ = Vl.prototype.copySampleValue_);\n    class Wl extends Vl {\n      constructor(t, e, n, i) {\n        super(t, e, n, i),\n          (this._weightPrev = -0),\n          (this._offsetPrev = -0),\n          (this._weightNext = -0),\n          (this._offsetNext = -0),\n          (this.DefaultSettings_ = { endingStart: k, endingEnd: k });\n      }\n      intervalChanged_(t, e, n) {\n        const i = this.parameterPositions;\n        let r = t - 2,\n          s = t + 1,\n          a = i[r],\n          o = i[s];\n        if (void 0 === a)\n          switch (this.getSettings_().endingStart) {\n            case V:\n              (r = t), (a = 2 * e - n);\n              break;\n            case W:\n              (r = i.length - 2), (a = e + i[r] - i[r + 1]);\n              break;\n            default:\n              (r = t), (a = n);\n          }\n        if (void 0 === o)\n          switch (this.getSettings_().endingEnd) {\n            case V:\n              (s = t), (o = 2 * n - e);\n              break;\n            case W:\n              (s = 1), (o = n + i[1] - i[0]);\n              break;\n            default:\n              (s = t - 1), (o = e);\n          }\n        const l = 0.5 * (n - e),\n          c = this.valueSize;\n        (this._weightPrev = l / (e - a)),\n          (this._weightNext = l / (o - n)),\n          (this._offsetPrev = r * c),\n          (this._offsetNext = s * c);\n      }\n      interpolate_(t, e, n, i) {\n        const r = this.resultBuffer,\n          s = this.sampleValues,\n          a = this.valueSize,\n          o = t * a,\n          l = o - a,\n          c = this._offsetPrev,\n          h = this._offsetNext,\n          u = this._weightPrev,\n          d = this._weightNext,\n          p = (n - e) / (i - e),\n          m = p * p,\n          f = m * p,\n          g = -u * f + 2 * u * m - u * p,\n          v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,\n          y = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,\n          x = d * f - d * m;\n        for (let t = 0; t !== a; ++t)\n          r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + x * s[h + t];\n        return r;\n      }\n    }\n    class jl extends Vl {\n      constructor(t, e, n, i) {\n        super(t, e, n, i);\n      }\n      interpolate_(t, e, n, i) {\n        const r = this.resultBuffer,\n          s = this.sampleValues,\n          a = this.valueSize,\n          o = t * a,\n          l = o - a,\n          c = (n - e) / (i - e),\n          h = 1 - c;\n        for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;\n        return r;\n      }\n    }\n    class ql extends Vl {\n      constructor(t, e, n, i) {\n        super(t, e, n, i);\n      }\n      interpolate_(t) {\n        return this.copySampleValue_(t - 1);\n      }\n    }\n    class Xl {\n      constructor(t, e, n, i) {\n        if (void 0 === t)\n          throw new Error(\"THREE.KeyframeTrack: track name is undefined\");\n        if (void 0 === e || 0 === e.length)\n          throw new Error(\n            \"THREE.KeyframeTrack: no keyframes in track named \" + t\n          );\n        (this.name = t),\n          (this.times = kl.convertArray(e, this.TimeBufferType)),\n          (this.values = kl.convertArray(n, this.ValueBufferType)),\n          this.setInterpolation(i || this.DefaultInterpolation);\n      }\n      static toJSON(t) {\n        const e = t.constructor;\n        let n;\n        if (e.toJSON !== this.toJSON) n = e.toJSON(t);\n        else {\n          n = {\n            name: t.name,\n            times: kl.convertArray(t.times, Array),\n            values: kl.convertArray(t.values, Array),\n          };\n          const e = t.getInterpolation();\n          e !== t.DefaultInterpolation && (n.interpolation = e);\n        }\n        return (n.type = t.ValueTypeName), n;\n      }\n      InterpolantFactoryMethodDiscrete(t) {\n        return new ql(this.times, this.values, this.getValueSize(), t);\n      }\n      InterpolantFactoryMethodLinear(t) {\n        return new jl(this.times, this.values, this.getValueSize(), t);\n      }\n      InterpolantFactoryMethodSmooth(t) {\n        return new Wl(this.times, this.values, this.getValueSize(), t);\n      }\n      setInterpolation(t) {\n        let e;\n        switch (t) {\n          case U:\n            e = this.InterpolantFactoryMethodDiscrete;\n            break;\n          case H:\n            e = this.InterpolantFactoryMethodLinear;\n            break;\n          case G:\n            e = this.InterpolantFactoryMethodSmooth;\n        }\n        if (void 0 === e) {\n          const e =\n            \"unsupported interpolation for \" +\n            this.ValueTypeName +\n            \" keyframe track named \" +\n            this.name;\n          if (void 0 === this.createInterpolant) {\n            if (t === this.DefaultInterpolation) throw new Error(e);\n            this.setInterpolation(this.DefaultInterpolation);\n          }\n          return console.warn(\"THREE.KeyframeTrack:\", e), this;\n        }\n        return (this.createInterpolant = e), this;\n      }\n      getInterpolation() {\n        switch (this.createInterpolant) {\n          case this.InterpolantFactoryMethodDiscrete:\n            return U;\n          case this.InterpolantFactoryMethodLinear:\n            return H;\n          case this.InterpolantFactoryMethodSmooth:\n            return G;\n        }\n      }\n      getValueSize() {\n        return this.values.length / this.times.length;\n      }\n      shift(t) {\n        if (0 !== t) {\n          const e = this.times;\n          for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;\n        }\n        return this;\n      }\n      scale(t) {\n        if (1 !== t) {\n          const e = this.times;\n          for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;\n        }\n        return this;\n      }\n      trim(t, e) {\n        const n = this.times,\n          i = n.length;\n        let r = 0,\n          s = i - 1;\n        for (; r !== i && n[r] < t; ) ++r;\n        for (; -1 !== s && n[s] > e; ) --s;\n        if ((++s, 0 !== r || s !== i)) {\n          r >= s && ((s = Math.max(s, 1)), (r = s - 1));\n          const t = this.getValueSize();\n          (this.times = kl.arraySlice(n, r, s)),\n            (this.values = kl.arraySlice(this.values, r * t, s * t));\n        }\n        return this;\n      }\n      validate() {\n        let t = !0;\n        const e = this.getValueSize();\n        e - Math.floor(e) != 0 &&\n          (console.error(\n            \"THREE.KeyframeTrack: Invalid value size in track.\",\n            this\n          ),\n          (t = !1));\n        const n = this.times,\n          i = this.values,\n          r = n.length;\n        0 === r &&\n          (console.error(\"THREE.KeyframeTrack: Track is empty.\", this),\n          (t = !1));\n        let s = null;\n        for (let e = 0; e !== r; e++) {\n          const i = n[e];\n          if (\"number\" == typeof i && isNaN(i)) {\n            console.error(\n              \"THREE.KeyframeTrack: Time is not a valid number.\",\n              this,\n              e,\n              i\n            ),\n              (t = !1);\n            break;\n          }\n          if (null !== s && s > i) {\n            console.error(\n              \"THREE.KeyframeTrack: Out of order keys.\",\n              this,\n              e,\n              i,\n              s\n            ),\n              (t = !1);\n            break;\n          }\n          s = i;\n        }\n        if (void 0 !== i && kl.isTypedArray(i))\n          for (let e = 0, n = i.length; e !== n; ++e) {\n            const n = i[e];\n            if (isNaN(n)) {\n              console.error(\n                \"THREE.KeyframeTrack: Value is not a valid number.\",\n                this,\n                e,\n                n\n              ),\n                (t = !1);\n              break;\n            }\n          }\n        return t;\n      }\n      optimize() {\n        const t = kl.arraySlice(this.times),\n          e = kl.arraySlice(this.values),\n          n = this.getValueSize(),\n          i = this.getInterpolation() === G,\n          r = t.length - 1;\n        let s = 1;\n        for (let a = 1; a < r; ++a) {\n          let r = !1;\n          const o = t[a];\n          if (o !== t[a + 1] && (1 !== a || o !== t[0]))\n            if (i) r = !0;\n            else {\n              const t = a * n,\n                i = t - n,\n                s = t + n;\n              for (let a = 0; a !== n; ++a) {\n                const n = e[t + a];\n                if (n !== e[i + a] || n !== e[s + a]) {\n                  r = !0;\n                  break;\n                }\n              }\n            }\n          if (r) {\n            if (a !== s) {\n              t[s] = t[a];\n              const i = a * n,\n                r = s * n;\n              for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];\n            }\n            ++s;\n          }\n        }\n        if (r > 0) {\n          t[s] = t[r];\n          for (let t = r * n, i = s * n, a = 0; a !== n; ++a)\n            e[i + a] = e[t + a];\n          ++s;\n        }\n        return (\n          s !== t.length\n            ? ((this.times = kl.arraySlice(t, 0, s)),\n              (this.values = kl.arraySlice(e, 0, s * n)))\n            : ((this.times = t), (this.values = e)),\n          this\n        );\n      }\n      clone() {\n        const t = kl.arraySlice(this.times, 0),\n          e = kl.arraySlice(this.values, 0),\n          n = new (0, this.constructor)(this.name, t, e);\n        return (n.createInterpolant = this.createInterpolant), n;\n      }\n    }\n    (Xl.prototype.TimeBufferType = Float32Array),\n      (Xl.prototype.ValueBufferType = Float32Array),\n      (Xl.prototype.DefaultInterpolation = H);\n    class Yl extends Xl {}\n    (Yl.prototype.ValueTypeName = \"bool\"),\n      (Yl.prototype.ValueBufferType = Array),\n      (Yl.prototype.DefaultInterpolation = U),\n      (Yl.prototype.InterpolantFactoryMethodLinear = void 0),\n      (Yl.prototype.InterpolantFactoryMethodSmooth = void 0);\n    class Jl extends Xl {}\n    Jl.prototype.ValueTypeName = \"color\";\n    class Zl extends Xl {}\n    Zl.prototype.ValueTypeName = \"number\";\n    class Ql extends Vl {\n      constructor(t, e, n, i) {\n        super(t, e, n, i);\n      }\n      interpolate_(t, e, n, i) {\n        const r = this.resultBuffer,\n          s = this.sampleValues,\n          a = this.valueSize,\n          o = (n - e) / (i - e);\n        let l = t * a;\n        for (let t = l + a; l !== t; l += 4)\n          Nt.slerpFlat(r, 0, s, l - a, s, l, o);\n        return r;\n      }\n    }\n    class Kl extends Xl {\n      InterpolantFactoryMethodLinear(t) {\n        return new Ql(this.times, this.values, this.getValueSize(), t);\n      }\n    }\n    (Kl.prototype.ValueTypeName = \"quaternion\"),\n      (Kl.prototype.DefaultInterpolation = H),\n      (Kl.prototype.InterpolantFactoryMethodSmooth = void 0);\n    class $l extends Xl {}\n    ($l.prototype.ValueTypeName = \"string\"),\n      ($l.prototype.ValueBufferType = Array),\n      ($l.prototype.DefaultInterpolation = U),\n      ($l.prototype.InterpolantFactoryMethodLinear = void 0),\n      ($l.prototype.InterpolantFactoryMethodSmooth = void 0);\n    class tc extends Xl {}\n    tc.prototype.ValueTypeName = \"vector\";\n    class ec {\n      constructor(t, e = -1, n, i = 2500) {\n        (this.name = t),\n          (this.tracks = n),\n          (this.duration = e),\n          (this.blendMode = i),\n          (this.uuid = ht()),\n          this.duration < 0 && this.resetDuration();\n      }\n      static parse(t) {\n        const e = [],\n          n = t.tracks,\n          i = 1 / (t.fps || 1);\n        for (let t = 0, r = n.length; t !== r; ++t) e.push(nc(n[t]).scale(i));\n        const r = new this(t.name, t.duration, e, t.blendMode);\n        return (r.uuid = t.uuid), r;\n      }\n      static toJSON(t) {\n        const e = [],\n          n = t.tracks,\n          i = {\n            name: t.name,\n            duration: t.duration,\n            tracks: e,\n            uuid: t.uuid,\n            blendMode: t.blendMode,\n          };\n        for (let t = 0, i = n.length; t !== i; ++t) e.push(Xl.toJSON(n[t]));\n        return i;\n      }\n      static CreateFromMorphTargetSequence(t, e, n, i) {\n        const r = e.length,\n          s = [];\n        for (let t = 0; t < r; t++) {\n          let a = [],\n            o = [];\n          a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);\n          const l = kl.getKeyframeOrder(a);\n          (a = kl.sortedArray(a, 1, l)),\n            (o = kl.sortedArray(o, 1, l)),\n            i || 0 !== a[0] || (a.push(r), o.push(o[0])),\n            s.push(\n              new Zl(\".morphTargetInfluences[\" + e[t].name + \"]\", a, o).scale(\n                1 / n\n              )\n            );\n        }\n        return new this(t, -1, s);\n      }\n      static findByName(t, e) {\n        let n = t;\n        if (!Array.isArray(t)) {\n          const e = t;\n          n = (e.geometry && e.geometry.animations) || e.animations;\n        }\n        for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];\n        return null;\n      }\n      static CreateClipsFromMorphTargetSequences(t, e, n) {\n        const i = {},\n          r = /^([\\w-]*?)([\\d]+)$/;\n        for (let e = 0, n = t.length; e < n; e++) {\n          const n = t[e],\n            s = n.name.match(r);\n          if (s && s.length > 1) {\n            const t = s[1];\n            let e = i[t];\n            e || (i[t] = e = []), e.push(n);\n          }\n        }\n        const s = [];\n        for (const t in i)\n          s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));\n        return s;\n      }\n      static parseAnimation(t, e) {\n        if (!t)\n          return (\n            console.error(\n              \"THREE.AnimationClip: No animation in JSONLoader data.\"\n            ),\n            null\n          );\n        const n = function (t, e, n, i, r) {\n            if (0 !== n.length) {\n              const s = [],\n                a = [];\n              kl.flattenJSON(n, s, a, i),\n                0 !== s.length && r.push(new t(e, s, a));\n            }\n          },\n          i = [],\n          r = t.name || \"default\",\n          s = t.fps || 30,\n          a = t.blendMode;\n        let o = t.length || -1;\n        const l = t.hierarchy || [];\n        for (let t = 0; t < l.length; t++) {\n          const r = l[t].keys;\n          if (r && 0 !== r.length)\n            if (r[0].morphTargets) {\n              const t = {};\n              let e;\n              for (e = 0; e < r.length; e++)\n                if (r[e].morphTargets)\n                  for (let n = 0; n < r[e].morphTargets.length; n++)\n                    t[r[e].morphTargets[n]] = -1;\n              for (const n in t) {\n                const t = [],\n                  s = [];\n                for (let i = 0; i !== r[e].morphTargets.length; ++i) {\n                  const i = r[e];\n                  t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);\n                }\n                i.push(new Zl(\".morphTargetInfluence[\" + n + \"]\", t, s));\n              }\n              o = t.length * (s || 1);\n            } else {\n              const s = \".bones[\" + e[t].name + \"]\";\n              n(tc, s + \".position\", r, \"pos\", i),\n                n(Kl, s + \".quaternion\", r, \"rot\", i),\n                n(tc, s + \".scale\", r, \"scl\", i);\n            }\n        }\n        if (0 === i.length) return null;\n        return new this(r, o, i, a);\n      }\n      resetDuration() {\n        let t = 0;\n        for (let e = 0, n = this.tracks.length; e !== n; ++e) {\n          const n = this.tracks[e];\n          t = Math.max(t, n.times[n.times.length - 1]);\n        }\n        return (this.duration = t), this;\n      }\n      trim() {\n        for (let t = 0; t < this.tracks.length; t++)\n          this.tracks[t].trim(0, this.duration);\n        return this;\n      }\n      validate() {\n        let t = !0;\n        for (let e = 0; e < this.tracks.length; e++)\n          t = t && this.tracks[e].validate();\n        return t;\n      }\n      optimize() {\n        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();\n        return this;\n      }\n      clone() {\n        const t = [];\n        for (let e = 0; e < this.tracks.length; e++)\n          t.push(this.tracks[e].clone());\n        return new this.constructor(\n          this.name,\n          this.duration,\n          t,\n          this.blendMode\n        );\n      }\n      toJSON() {\n        return this.constructor.toJSON(this);\n      }\n    }\n    function nc(t) {\n      if (void 0 === t.type)\n        throw new Error(\n          \"THREE.KeyframeTrack: track type undefined, can not parse\"\n        );\n      const e = (function (t) {\n        switch (t.toLowerCase()) {\n          case \"scalar\":\n          case \"double\":\n          case \"float\":\n          case \"number\":\n          case \"integer\":\n            return Zl;\n          case \"vector\":\n          case \"vector2\":\n          case \"vector3\":\n          case \"vector4\":\n            return tc;\n          case \"color\":\n            return Jl;\n          case \"quaternion\":\n            return Kl;\n          case \"bool\":\n          case \"boolean\":\n            return Yl;\n          case \"string\":\n            return $l;\n        }\n        throw new Error(\"THREE.KeyframeTrack: Unsupported typeName: \" + t);\n      })(t.type);\n      if (void 0 === t.times) {\n        const e = [],\n          n = [];\n        kl.flattenJSON(t.keys, e, n, \"value\"), (t.times = e), (t.values = n);\n      }\n      return void 0 !== e.parse\n        ? e.parse(t)\n        : new e(t.name, t.times, t.values, t.interpolation);\n    }\n    const ic = {\n      enabled: !1,\n      files: {},\n      add: function (t, e) {\n        !1 !== this.enabled && (this.files[t] = e);\n      },\n      get: function (t) {\n        if (!1 !== this.enabled) return this.files[t];\n      },\n      remove: function (t) {\n        delete this.files[t];\n      },\n      clear: function () {\n        this.files = {};\n      },\n    };\n    class rc {\n      constructor(t, e, n) {\n        const i = this;\n        let r,\n          s = !1,\n          a = 0,\n          o = 0;\n        const l = [];\n        (this.onStart = void 0),\n          (this.onLoad = t),\n          (this.onProgress = e),\n          (this.onError = n),\n          (this.itemStart = function (t) {\n            o++,\n              !1 === s && void 0 !== i.onStart && i.onStart(t, a, o),\n              (s = !0);\n          }),\n          (this.itemEnd = function (t) {\n            a++,\n              void 0 !== i.onProgress && i.onProgress(t, a, o),\n              a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());\n          }),\n          (this.itemError = function (t) {\n            void 0 !== i.onError && i.onError(t);\n          }),\n          (this.resolveURL = function (t) {\n            return r ? r(t) : t;\n          }),\n          (this.setURLModifier = function (t) {\n            return (r = t), this;\n          }),\n          (this.addHandler = function (t, e) {\n            return l.push(t, e), this;\n          }),\n          (this.removeHandler = function (t) {\n            const e = l.indexOf(t);\n            return -1 !== e && l.splice(e, 2), this;\n          }),\n          (this.getHandler = function (t) {\n            for (let e = 0, n = l.length; e < n; e += 2) {\n              const n = l[e],\n                i = l[e + 1];\n              if ((n.global && (n.lastIndex = 0), n.test(t))) return i;\n            }\n            return null;\n          });\n      }\n    }\n    const sc = new rc();\n    class ac {\n      constructor(t) {\n        (this.manager = void 0 !== t ? t : sc),\n          (this.crossOrigin = \"anonymous\"),\n          (this.withCredentials = !1),\n          (this.path = \"\"),\n          (this.resourcePath = \"\"),\n          (this.requestHeader = {});\n      }\n      load() {}\n      loadAsync(t, e) {\n        const n = this;\n        return new Promise(function (i, r) {\n          n.load(t, i, e, r);\n        });\n      }\n      parse() {}\n      setCrossOrigin(t) {\n        return (this.crossOrigin = t), this;\n      }\n      setWithCredentials(t) {\n        return (this.withCredentials = t), this;\n      }\n      setPath(t) {\n        return (this.path = t), this;\n      }\n      setResourcePath(t) {\n        return (this.resourcePath = t), this;\n      }\n      setRequestHeader(t) {\n        return (this.requestHeader = t), this;\n      }\n    }\n    const oc = {};\n    class lc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        void 0 === t && (t = \"\"),\n          void 0 !== this.path && (t = this.path + t),\n          (t = this.manager.resolveURL(t));\n        const r = ic.get(t);\n        if (void 0 !== r)\n          return (\n            this.manager.itemStart(t),\n            setTimeout(() => {\n              e && e(r), this.manager.itemEnd(t);\n            }, 0),\n            r\n          );\n        if (void 0 !== oc[t])\n          return void oc[t].push({ onLoad: e, onProgress: n, onError: i });\n        (oc[t] = []), oc[t].push({ onLoad: e, onProgress: n, onError: i });\n        const s = new Request(t, {\n          headers: new Headers(this.requestHeader),\n          credentials: this.withCredentials ? \"include\" : \"same-origin\",\n        });\n        fetch(s)\n          .then((e) => {\n            if (200 === e.status || 0 === e.status) {\n              0 === e.status &&\n                console.warn(\"THREE.FileLoader: HTTP Status 0 received.\");\n              const n = oc[t],\n                i = e.body.getReader(),\n                r = e.headers.get(\"Content-Length\"),\n                s = r ? parseInt(r) : 0,\n                a = 0 !== s;\n              let o = 0;\n              return new ReadableStream({\n                start(t) {\n                  !(function e() {\n                    i.read().then(({ done: i, value: r }) => {\n                      if (i) t.close();\n                      else {\n                        o += r.byteLength;\n                        const i = new ProgressEvent(\"progress\", {\n                          lengthComputable: a,\n                          loaded: o,\n                          total: s,\n                        });\n                        for (let t = 0, e = n.length; t < e; t++) {\n                          const e = n[t];\n                          e.onProgress && e.onProgress(i);\n                        }\n                        t.enqueue(r), e();\n                      }\n                    });\n                  })();\n                },\n              });\n            }\n            throw Error(\n              `fetch for \"${e.url}\" responded with ${e.status}: ${e.statusText}`\n            );\n          })\n          .then((t) => {\n            const e = new Response(t);\n            switch (this.responseType) {\n              case \"arraybuffer\":\n                return e.arrayBuffer();\n              case \"blob\":\n                return e.blob();\n              case \"document\":\n                return e\n                  .text()\n                  .then((t) =>\n                    new DOMParser().parseFromString(t, this.mimeType)\n                  );\n              case \"json\":\n                return e.json();\n              default:\n                return e.text();\n            }\n          })\n          .then((e) => {\n            ic.add(t, e);\n            const n = oc[t];\n            delete oc[t];\n            for (let t = 0, i = n.length; t < i; t++) {\n              const i = n[t];\n              i.onLoad && i.onLoad(e);\n            }\n            this.manager.itemEnd(t);\n          })\n          .catch((e) => {\n            const n = oc[t];\n            delete oc[t];\n            for (let t = 0, i = n.length; t < i; t++) {\n              const i = n[t];\n              i.onError && i.onError(e);\n            }\n            this.manager.itemError(t), this.manager.itemEnd(t);\n          }),\n          this.manager.itemStart(t);\n      }\n      setResponseType(t) {\n        return (this.responseType = t), this;\n      }\n      setMimeType(t) {\n        return (this.mimeType = t), this;\n      }\n    }\n    class cc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        void 0 !== this.path && (t = this.path + t),\n          (t = this.manager.resolveURL(t));\n        const r = this,\n          s = ic.get(t);\n        if (void 0 !== s)\n          return (\n            r.manager.itemStart(t),\n            setTimeout(function () {\n              e && e(s), r.manager.itemEnd(t);\n            }, 0),\n            s\n          );\n        const a = wt(\"img\");\n        function o() {\n          c(), ic.add(t, this), e && e(this), r.manager.itemEnd(t);\n        }\n        function l(e) {\n          c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);\n        }\n        function c() {\n          a.removeEventListener(\"load\", o, !1),\n            a.removeEventListener(\"error\", l, !1);\n        }\n        return (\n          a.addEventListener(\"load\", o, !1),\n          a.addEventListener(\"error\", l, !1),\n          \"data:\" !== t.substr(0, 5) &&\n            void 0 !== this.crossOrigin &&\n            (a.crossOrigin = this.crossOrigin),\n          r.manager.itemStart(t),\n          (a.src = t),\n          a\n        );\n      }\n    }\n    class hc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        const r = new ei(),\n          s = new cc(this.manager);\n        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);\n        let a = 0;\n        function o(n) {\n          s.load(\n            t[n],\n            function (t) {\n              (r.images[n] = t),\n                a++,\n                6 === a && ((r.needsUpdate = !0), e && e(r));\n            },\n            void 0,\n            i\n          );\n        }\n        for (let e = 0; e < t.length; ++e) o(e);\n        return r;\n      }\n    }\n    class uc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        const r = this,\n          s = new Pa(),\n          a = new lc(this.manager);\n        return (\n          a.setResponseType(\"arraybuffer\"),\n          a.setRequestHeader(this.requestHeader),\n          a.setPath(this.path),\n          a.setWithCredentials(r.withCredentials),\n          a.load(\n            t,\n            function (t) {\n              const n = r.parse(t);\n              n &&\n                (void 0 !== n.image\n                  ? (s.image = n.image)\n                  : void 0 !== n.data &&\n                    ((s.image.width = n.width),\n                    (s.image.height = n.height),\n                    (s.image.data = n.data)),\n                (s.wrapS = void 0 !== n.wrapS ? n.wrapS : u),\n                (s.wrapT = void 0 !== n.wrapT ? n.wrapT : u),\n                (s.magFilter = void 0 !== n.magFilter ? n.magFilter : g),\n                (s.minFilter = void 0 !== n.minFilter ? n.minFilter : g),\n                (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),\n                void 0 !== n.encoding && (s.encoding = n.encoding),\n                void 0 !== n.flipY && (s.flipY = n.flipY),\n                void 0 !== n.format && (s.format = n.format),\n                void 0 !== n.type && (s.type = n.type),\n                void 0 !== n.mipmaps &&\n                  ((s.mipmaps = n.mipmaps), (s.minFilter = y)),\n                1 === n.mipmapCount && (s.minFilter = g),\n                void 0 !== n.generateMipmaps &&\n                  (s.generateMipmaps = n.generateMipmaps),\n                (s.needsUpdate = !0),\n                e && e(s, n));\n            },\n            n,\n            i\n          ),\n          s\n        );\n      }\n    }\n    class dc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        const r = new Lt(),\n          s = new cc(this.manager);\n        return (\n          s.setCrossOrigin(this.crossOrigin),\n          s.setPath(this.path),\n          s.load(\n            t,\n            function (t) {\n              (r.image = t), (r.needsUpdate = !0), void 0 !== e && e(r);\n            },\n            n,\n            i\n          ),\n          r\n        );\n      }\n    }\n    class pc extends Fe {\n      constructor(t, e = 1) {\n        super(),\n          (this.type = \"Light\"),\n          (this.color = new rn(t)),\n          (this.intensity = e);\n      }\n      dispose() {}\n      copy(t) {\n        return (\n          super.copy(t),\n          this.color.copy(t.color),\n          (this.intensity = t.intensity),\n          this\n        );\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (\n          (e.object.color = this.color.getHex()),\n          (e.object.intensity = this.intensity),\n          void 0 !== this.groundColor &&\n            (e.object.groundColor = this.groundColor.getHex()),\n          void 0 !== this.distance && (e.object.distance = this.distance),\n          void 0 !== this.angle && (e.object.angle = this.angle),\n          void 0 !== this.decay && (e.object.decay = this.decay),\n          void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),\n          void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),\n          e\n        );\n      }\n    }\n    pc.prototype.isLight = !0;\n    class mc extends pc {\n      constructor(t, e, n) {\n        super(t, n),\n          (this.type = \"HemisphereLight\"),\n          this.position.copy(Fe.DefaultUp),\n          this.updateMatrix(),\n          (this.groundColor = new rn(e));\n      }\n      copy(t) {\n        return (\n          pc.prototype.copy.call(this, t),\n          this.groundColor.copy(t.groundColor),\n          this\n        );\n      }\n    }\n    mc.prototype.isHemisphereLight = !0;\n    const fc = new de(),\n      gc = new zt(),\n      vc = new zt();\n    class yc {\n      constructor(t) {\n        (this.camera = t),\n          (this.bias = 0),\n          (this.normalBias = 0),\n          (this.radius = 1),\n          (this.blurSamples = 8),\n          (this.mapSize = new yt(512, 512)),\n          (this.map = null),\n          (this.mapPass = null),\n          (this.matrix = new de()),\n          (this.autoUpdate = !0),\n          (this.needsUpdate = !1),\n          (this._frustum = new ci()),\n          (this._frameExtents = new yt(1, 1)),\n          (this._viewportCount = 1),\n          (this._viewports = [new Ct(0, 0, 1, 1)]);\n      }\n      getViewportCount() {\n        return this._viewportCount;\n      }\n      getFrustum() {\n        return this._frustum;\n      }\n      updateMatrices(t) {\n        const e = this.camera,\n          n = this.matrix;\n        gc.setFromMatrixPosition(t.matrixWorld),\n          e.position.copy(gc),\n          vc.setFromMatrixPosition(t.target.matrixWorld),\n          e.lookAt(vc),\n          e.updateMatrixWorld(),\n          fc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),\n          this._frustum.setFromProjectionMatrix(fc),\n          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),\n          n.multiply(e.projectionMatrix),\n          n.multiply(e.matrixWorldInverse);\n      }\n      getViewport(t) {\n        return this._viewports[t];\n      }\n      getFrameExtents() {\n        return this._frameExtents;\n      }\n      dispose() {\n        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();\n      }\n      copy(t) {\n        return (\n          (this.camera = t.camera.clone()),\n          (this.bias = t.bias),\n          (this.radius = t.radius),\n          this.mapSize.copy(t.mapSize),\n          this\n        );\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      toJSON() {\n        const t = {};\n        return (\n          0 !== this.bias && (t.bias = this.bias),\n          0 !== this.normalBias && (t.normalBias = this.normalBias),\n          1 !== this.radius && (t.radius = this.radius),\n          (512 === this.mapSize.x && 512 === this.mapSize.y) ||\n            (t.mapSize = this.mapSize.toArray()),\n          (t.camera = this.camera.toJSON(!1).object),\n          delete t.camera.matrix,\n          t\n        );\n      }\n    }\n    class xc extends yc {\n      constructor() {\n        super(new Kn(50, 1, 0.5, 500)), (this.focus = 1);\n      }\n      updateMatrices(t) {\n        const e = this.camera,\n          n = 2 * ot * t.angle * this.focus,\n          i = this.mapSize.width / this.mapSize.height,\n          r = t.distance || e.far;\n        (n === e.fov && i === e.aspect && r === e.far) ||\n          ((e.fov = n),\n          (e.aspect = i),\n          (e.far = r),\n          e.updateProjectionMatrix()),\n          super.updateMatrices(t);\n      }\n      copy(t) {\n        return super.copy(t), (this.focus = t.focus), this;\n      }\n    }\n    xc.prototype.isSpotLightShadow = !0;\n    class _c extends pc {\n      constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {\n        super(t, e),\n          (this.type = \"SpotLight\"),\n          this.position.copy(Fe.DefaultUp),\n          this.updateMatrix(),\n          (this.target = new Fe()),\n          (this.distance = n),\n          (this.angle = i),\n          (this.penumbra = r),\n          (this.decay = s),\n          (this.shadow = new xc());\n      }\n      get power() {\n        return this.intensity * Math.PI;\n      }\n      set power(t) {\n        this.intensity = t / Math.PI;\n      }\n      dispose() {\n        this.shadow.dispose();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.distance = t.distance),\n          (this.angle = t.angle),\n          (this.penumbra = t.penumbra),\n          (this.decay = t.decay),\n          (this.target = t.target.clone()),\n          (this.shadow = t.shadow.clone()),\n          this\n        );\n      }\n    }\n    _c.prototype.isSpotLight = !0;\n    const Mc = new de(),\n      bc = new zt(),\n      wc = new zt();\n    class Sc extends yc {\n      constructor() {\n        super(new Kn(90, 1, 0.5, 500)),\n          (this._frameExtents = new yt(4, 2)),\n          (this._viewportCount = 6),\n          (this._viewports = [\n            new Ct(2, 1, 1, 1),\n            new Ct(0, 1, 1, 1),\n            new Ct(3, 1, 1, 1),\n            new Ct(1, 1, 1, 1),\n            new Ct(3, 0, 1, 1),\n            new Ct(1, 0, 1, 1),\n          ]),\n          (this._cubeDirections = [\n            new zt(1, 0, 0),\n            new zt(-1, 0, 0),\n            new zt(0, 0, 1),\n            new zt(0, 0, -1),\n            new zt(0, 1, 0),\n            new zt(0, -1, 0),\n          ]),\n          (this._cubeUps = [\n            new zt(0, 1, 0),\n            new zt(0, 1, 0),\n            new zt(0, 1, 0),\n            new zt(0, 1, 0),\n            new zt(0, 0, 1),\n            new zt(0, 0, -1),\n          ]);\n      }\n      updateMatrices(t, e = 0) {\n        const n = this.camera,\n          i = this.matrix,\n          r = t.distance || n.far;\n        r !== n.far && ((n.far = r), n.updateProjectionMatrix()),\n          bc.setFromMatrixPosition(t.matrixWorld),\n          n.position.copy(bc),\n          wc.copy(n.position),\n          wc.add(this._cubeDirections[e]),\n          n.up.copy(this._cubeUps[e]),\n          n.lookAt(wc),\n          n.updateMatrixWorld(),\n          i.makeTranslation(-bc.x, -bc.y, -bc.z),\n          Mc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),\n          this._frustum.setFromProjectionMatrix(Mc);\n      }\n    }\n    Sc.prototype.isPointLightShadow = !0;\n    class Tc extends pc {\n      constructor(t, e, n = 0, i = 1) {\n        super(t, e),\n          (this.type = \"PointLight\"),\n          (this.distance = n),\n          (this.decay = i),\n          (this.shadow = new Sc());\n      }\n      get power() {\n        return 4 * this.intensity * Math.PI;\n      }\n      set power(t) {\n        this.intensity = t / (4 * Math.PI);\n      }\n      dispose() {\n        this.shadow.dispose();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.distance = t.distance),\n          (this.decay = t.decay),\n          (this.shadow = t.shadow.clone()),\n          this\n        );\n      }\n    }\n    Tc.prototype.isPointLight = !0;\n    class Ec extends yc {\n      constructor() {\n        super(new bi(-5, 5, 5, -5, 0.5, 500));\n      }\n    }\n    Ec.prototype.isDirectionalLightShadow = !0;\n    class Ac extends pc {\n      constructor(t, e) {\n        super(t, e),\n          (this.type = \"DirectionalLight\"),\n          this.position.copy(Fe.DefaultUp),\n          this.updateMatrix(),\n          (this.target = new Fe()),\n          (this.shadow = new Ec());\n      }\n      dispose() {\n        this.shadow.dispose();\n      }\n      copy(t) {\n        return (\n          super.copy(t),\n          (this.target = t.target.clone()),\n          (this.shadow = t.shadow.clone()),\n          this\n        );\n      }\n    }\n    Ac.prototype.isDirectionalLight = !0;\n    class Lc extends pc {\n      constructor(t, e) {\n        super(t, e), (this.type = \"AmbientLight\");\n      }\n    }\n    Lc.prototype.isAmbientLight = !0;\n    class Rc extends pc {\n      constructor(t, e, n = 10, i = 10) {\n        super(t, e),\n          (this.type = \"RectAreaLight\"),\n          (this.width = n),\n          (this.height = i);\n      }\n      get power() {\n        return this.intensity * this.width * this.height * Math.PI;\n      }\n      set power(t) {\n        this.intensity = t / (this.width * this.height * Math.PI);\n      }\n      copy(t) {\n        return (\n          super.copy(t), (this.width = t.width), (this.height = t.height), this\n        );\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (\n          (e.object.width = this.width), (e.object.height = this.height), e\n        );\n      }\n    }\n    Rc.prototype.isRectAreaLight = !0;\n    class Cc {\n      constructor() {\n        this.coefficients = [];\n        for (let t = 0; t < 9; t++) this.coefficients.push(new zt());\n      }\n      set(t) {\n        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);\n        return this;\n      }\n      zero() {\n        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);\n        return this;\n      }\n      getAt(t, e) {\n        const n = t.x,\n          i = t.y,\n          r = t.z,\n          s = this.coefficients;\n        return (\n          e.copy(s[0]).multiplyScalar(0.282095),\n          e.addScaledVector(s[1], 0.488603 * i),\n          e.addScaledVector(s[2], 0.488603 * r),\n          e.addScaledVector(s[3], 0.488603 * n),\n          e.addScaledVector(s[4], n * i * 1.092548),\n          e.addScaledVector(s[5], i * r * 1.092548),\n          e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),\n          e.addScaledVector(s[7], n * r * 1.092548),\n          e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),\n          e\n        );\n      }\n      getIrradianceAt(t, e) {\n        const n = t.x,\n          i = t.y,\n          r = t.z,\n          s = this.coefficients;\n        return (\n          e.copy(s[0]).multiplyScalar(0.886227),\n          e.addScaledVector(s[1], 1.023328 * i),\n          e.addScaledVector(s[2], 1.023328 * r),\n          e.addScaledVector(s[3], 1.023328 * n),\n          e.addScaledVector(s[4], 0.858086 * n * i),\n          e.addScaledVector(s[5], 0.858086 * i * r),\n          e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),\n          e.addScaledVector(s[7], 0.858086 * n * r),\n          e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),\n          e\n        );\n      }\n      add(t) {\n        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);\n        return this;\n      }\n      addScaledSH(t, e) {\n        for (let n = 0; n < 9; n++)\n          this.coefficients[n].addScaledVector(t.coefficients[n], e);\n        return this;\n      }\n      scale(t) {\n        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);\n        return this;\n      }\n      lerp(t, e) {\n        for (let n = 0; n < 9; n++)\n          this.coefficients[n].lerp(t.coefficients[n], e);\n        return this;\n      }\n      equals(t) {\n        for (let e = 0; e < 9; e++)\n          if (!this.coefficients[e].equals(t.coefficients[e])) return !1;\n        return !0;\n      }\n      copy(t) {\n        return this.set(t.coefficients);\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      fromArray(t, e = 0) {\n        const n = this.coefficients;\n        for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);\n        return this;\n      }\n      toArray(t = [], e = 0) {\n        const n = this.coefficients;\n        for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);\n        return t;\n      }\n      static getBasisAt(t, e) {\n        const n = t.x,\n          i = t.y,\n          r = t.z;\n        (e[0] = 0.282095),\n          (e[1] = 0.488603 * i),\n          (e[2] = 0.488603 * r),\n          (e[3] = 0.488603 * n),\n          (e[4] = 1.092548 * n * i),\n          (e[5] = 1.092548 * i * r),\n          (e[6] = 0.315392 * (3 * r * r - 1)),\n          (e[7] = 1.092548 * n * r),\n          (e[8] = 0.546274 * (n * n - i * i));\n      }\n    }\n    Cc.prototype.isSphericalHarmonics3 = !0;\n    class Pc extends pc {\n      constructor(t = new Cc(), e = 1) {\n        super(void 0, e), (this.sh = t);\n      }\n      copy(t) {\n        return super.copy(t), this.sh.copy(t.sh), this;\n      }\n      fromJSON(t) {\n        return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (e.object.sh = this.sh.toArray()), e;\n      }\n    }\n    Pc.prototype.isLightProbe = !0;\n    class Ic extends ac {\n      constructor(t) {\n        super(t), (this.textures = {});\n      }\n      load(t, e, n, i) {\n        const r = this,\n          s = new lc(r.manager);\n        s.setPath(r.path),\n          s.setRequestHeader(r.requestHeader),\n          s.setWithCredentials(r.withCredentials),\n          s.load(\n            t,\n            function (n) {\n              try {\n                e(r.parse(JSON.parse(n)));\n              } catch (e) {\n                i ? i(e) : console.error(e), r.manager.itemError(t);\n              }\n            },\n            n,\n            i\n          );\n      }\n      parse(t) {\n        const e = this.textures;\n        function n(t) {\n          return (\n            void 0 === e[t] &&\n              console.warn(\"THREE.MaterialLoader: Undefined texture\", t),\n            e[t]\n          );\n        }\n        const i = new Gl[t.type]();\n        if (\n          (void 0 !== t.uuid && (i.uuid = t.uuid),\n          void 0 !== t.name && (i.name = t.name),\n          void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),\n          void 0 !== t.roughness && (i.roughness = t.roughness),\n          void 0 !== t.metalness && (i.metalness = t.metalness),\n          void 0 !== t.sheen && (i.sheen = t.sheen),\n          void 0 !== t.sheenColor &&\n            (i.sheenColor = new rn().setHex(t.sheenColor)),\n          void 0 !== t.sheenRoughness && (i.sheenRoughness = t.sheenRoughness),\n          void 0 !== t.emissive &&\n            void 0 !== i.emissive &&\n            i.emissive.setHex(t.emissive),\n          void 0 !== t.specular &&\n            void 0 !== i.specular &&\n            i.specular.setHex(t.specular),\n          void 0 !== t.specularIntensity &&\n            (i.specularIntensity = t.specularIntensity),\n          void 0 !== t.specularColor &&\n            void 0 !== i.specularColor &&\n            i.specularColor.setHex(t.specularColor),\n          void 0 !== t.shininess && (i.shininess = t.shininess),\n          void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),\n          void 0 !== t.clearcoatRoughness &&\n            (i.clearcoatRoughness = t.clearcoatRoughness),\n          void 0 !== t.transmission && (i.transmission = t.transmission),\n          void 0 !== t.thickness && (i.thickness = t.thickness),\n          void 0 !== t.attenuationDistance &&\n            (i.attenuationDistance = t.attenuationDistance),\n          void 0 !== t.attenuationColor &&\n            void 0 !== i.attenuationColor &&\n            i.attenuationColor.setHex(t.attenuationColor),\n          void 0 !== t.fog && (i.fog = t.fog),\n          void 0 !== t.flatShading && (i.flatShading = t.flatShading),\n          void 0 !== t.blending && (i.blending = t.blending),\n          void 0 !== t.combine && (i.combine = t.combine),\n          void 0 !== t.side && (i.side = t.side),\n          void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),\n          void 0 !== t.opacity && (i.opacity = t.opacity),\n          void 0 !== t.format && (i.format = t.format),\n          void 0 !== t.transparent && (i.transparent = t.transparent),\n          void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),\n          void 0 !== t.depthTest && (i.depthTest = t.depthTest),\n          void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),\n          void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),\n          void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),\n          void 0 !== t.stencilWriteMask &&\n            (i.stencilWriteMask = t.stencilWriteMask),\n          void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),\n          void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),\n          void 0 !== t.stencilFuncMask &&\n            (i.stencilFuncMask = t.stencilFuncMask),\n          void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),\n          void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),\n          void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),\n          void 0 !== t.wireframe && (i.wireframe = t.wireframe),\n          void 0 !== t.wireframeLinewidth &&\n            (i.wireframeLinewidth = t.wireframeLinewidth),\n          void 0 !== t.wireframeLinecap &&\n            (i.wireframeLinecap = t.wireframeLinecap),\n          void 0 !== t.wireframeLinejoin &&\n            (i.wireframeLinejoin = t.wireframeLinejoin),\n          void 0 !== t.rotation && (i.rotation = t.rotation),\n          1 !== t.linewidth && (i.linewidth = t.linewidth),\n          void 0 !== t.dashSize && (i.dashSize = t.dashSize),\n          void 0 !== t.gapSize && (i.gapSize = t.gapSize),\n          void 0 !== t.scale && (i.scale = t.scale),\n          void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),\n          void 0 !== t.polygonOffsetFactor &&\n            (i.polygonOffsetFactor = t.polygonOffsetFactor),\n          void 0 !== t.polygonOffsetUnits &&\n            (i.polygonOffsetUnits = t.polygonOffsetUnits),\n          void 0 !== t.dithering && (i.dithering = t.dithering),\n          void 0 !== t.alphaToCoverage &&\n            (i.alphaToCoverage = t.alphaToCoverage),\n          void 0 !== t.premultipliedAlpha &&\n            (i.premultipliedAlpha = t.premultipliedAlpha),\n          void 0 !== t.visible && (i.visible = t.visible),\n          void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),\n          void 0 !== t.userData && (i.userData = t.userData),\n          void 0 !== t.vertexColors &&\n            (\"number\" == typeof t.vertexColors\n              ? (i.vertexColors = t.vertexColors > 0)\n              : (i.vertexColors = t.vertexColors)),\n          void 0 !== t.uniforms)\n        )\n          for (const e in t.uniforms) {\n            const r = t.uniforms[e];\n            switch (((i.uniforms[e] = {}), r.type)) {\n              case \"t\":\n                i.uniforms[e].value = n(r.value);\n                break;\n              case \"c\":\n                i.uniforms[e].value = new rn().setHex(r.value);\n                break;\n              case \"v2\":\n                i.uniforms[e].value = new yt().fromArray(r.value);\n                break;\n              case \"v3\":\n                i.uniforms[e].value = new zt().fromArray(r.value);\n                break;\n              case \"v4\":\n                i.uniforms[e].value = new Ct().fromArray(r.value);\n                break;\n              case \"m3\":\n                i.uniforms[e].value = new xt().fromArray(r.value);\n                break;\n              case \"m4\":\n                i.uniforms[e].value = new de().fromArray(r.value);\n                break;\n              default:\n                i.uniforms[e].value = r.value;\n            }\n          }\n        if (\n          (void 0 !== t.defines && (i.defines = t.defines),\n          void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),\n          void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),\n          void 0 !== t.extensions)\n        )\n          for (const e in t.extensions) i.extensions[e] = t.extensions[e];\n        if (\n          (void 0 !== t.shading && (i.flatShading = 1 === t.shading),\n          void 0 !== t.size && (i.size = t.size),\n          void 0 !== t.sizeAttenuation &&\n            (i.sizeAttenuation = t.sizeAttenuation),\n          void 0 !== t.map && (i.map = n(t.map)),\n          void 0 !== t.matcap && (i.matcap = n(t.matcap)),\n          void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),\n          void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),\n          void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),\n          void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),\n          void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),\n          void 0 !== t.normalScale)\n        ) {\n          let e = t.normalScale;\n          !1 === Array.isArray(e) && (e = [e, e]),\n            (i.normalScale = new yt().fromArray(e));\n        }\n        return (\n          void 0 !== t.displacementMap &&\n            (i.displacementMap = n(t.displacementMap)),\n          void 0 !== t.displacementScale &&\n            (i.displacementScale = t.displacementScale),\n          void 0 !== t.displacementBias &&\n            (i.displacementBias = t.displacementBias),\n          void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),\n          void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),\n          void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),\n          void 0 !== t.emissiveIntensity &&\n            (i.emissiveIntensity = t.emissiveIntensity),\n          void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),\n          void 0 !== t.specularIntensityMap &&\n            (i.specularIntensityMap = n(t.specularIntensityMap)),\n          void 0 !== t.specularColorMap &&\n            (i.specularColorMap = n(t.specularColorMap)),\n          void 0 !== t.envMap && (i.envMap = n(t.envMap)),\n          void 0 !== t.envMapIntensity &&\n            (i.envMapIntensity = t.envMapIntensity),\n          void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),\n          void 0 !== t.refractionRatio &&\n            (i.refractionRatio = t.refractionRatio),\n          void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),\n          void 0 !== t.lightMapIntensity &&\n            (i.lightMapIntensity = t.lightMapIntensity),\n          void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),\n          void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),\n          void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),\n          void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),\n          void 0 !== t.clearcoatRoughnessMap &&\n            (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),\n          void 0 !== t.clearcoatNormalMap &&\n            (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),\n          void 0 !== t.clearcoatNormalScale &&\n            (i.clearcoatNormalScale = new yt().fromArray(\n              t.clearcoatNormalScale\n            )),\n          void 0 !== t.transmissionMap &&\n            (i.transmissionMap = n(t.transmissionMap)),\n          void 0 !== t.thicknessMap && (i.thicknessMap = n(t.thicknessMap)),\n          void 0 !== t.sheenColorMap && (i.sheenColorMap = n(t.sheenColorMap)),\n          void 0 !== t.sheenRoughnessMap &&\n            (i.sheenRoughnessMap = n(t.sheenRoughnessMap)),\n          i\n        );\n      }\n      setTextures(t) {\n        return (this.textures = t), this;\n      }\n    }\n    class Dc {\n      static decodeText(t) {\n        if (\"undefined\" != typeof TextDecoder)\n          return new TextDecoder().decode(t);\n        let e = \"\";\n        for (let n = 0, i = t.length; n < i; n++)\n          e += String.fromCharCode(t[n]);\n        try {\n          return decodeURIComponent(escape(e));\n        } catch (t) {\n          return e;\n        }\n      }\n      static extractUrlBase(t) {\n        const e = t.lastIndexOf(\"/\");\n        return -1 === e ? \"./\" : t.substr(0, e + 1);\n      }\n      static resolveURL(t, e) {\n        return \"string\" != typeof t || \"\" === t\n          ? \"\"\n          : (/^https?:\\/\\//i.test(e) &&\n              /^\\//.test(t) &&\n              (e = e.replace(/(^https?:\\/\\/[^\\/]+).*/i, \"$1\")),\n            /^(https?:)?\\/\\//i.test(t) ||\n            /^data:.*,.*$/i.test(t) ||\n            /^blob:.*$/i.test(t)\n              ? t\n              : e + t);\n      }\n    }\n    class Nc extends En {\n      constructor() {\n        super(),\n          (this.type = \"InstancedBufferGeometry\"),\n          (this.instanceCount = 1 / 0);\n      }\n      copy(t) {\n        return super.copy(t), (this.instanceCount = t.instanceCount), this;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      toJSON() {\n        const t = super.toJSON(this);\n        return (\n          (t.instanceCount = this.instanceCount),\n          (t.isInstancedBufferGeometry = !0),\n          t\n        );\n      }\n    }\n    Nc.prototype.isInstancedBufferGeometry = !0;\n    class zc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        const r = this,\n          s = new lc(r.manager);\n        s.setPath(r.path),\n          s.setRequestHeader(r.requestHeader),\n          s.setWithCredentials(r.withCredentials),\n          s.load(\n            t,\n            function (n) {\n              try {\n                e(r.parse(JSON.parse(n)));\n              } catch (e) {\n                i ? i(e) : console.error(e), r.manager.itemError(t);\n              }\n            },\n            n,\n            i\n          );\n      }\n      parse(t) {\n        const e = {},\n          n = {};\n        function i(t, i) {\n          if (void 0 !== e[i]) return e[i];\n          const r = t.interleavedBuffers[i],\n            s = (function (t, e) {\n              if (void 0 !== n[e]) return n[e];\n              const i = t.arrayBuffers[e],\n                r = new Uint32Array(i).buffer;\n              return (n[e] = r), r;\n            })(t, r.buffer),\n            a = bt(r.type, s),\n            o = new na(a, r.stride);\n          return (o.uuid = r.uuid), (e[i] = o), o;\n        }\n        const r = t.isInstancedBufferGeometry ? new Nc() : new En(),\n          s = t.data.index;\n        if (void 0 !== s) {\n          const t = bt(s.type, s.array);\n          r.setIndex(new ln(t, 1));\n        }\n        const a = t.data.attributes;\n        for (const e in a) {\n          const n = a[e];\n          let s;\n          if (n.isInterleavedBufferAttribute) {\n            const e = i(t.data, n.data);\n            s = new ra(e, n.itemSize, n.offset, n.normalized);\n          } else {\n            const t = bt(n.type, n.array);\n            s = new (n.isInstancedBufferAttribute ? za : ln)(\n              t,\n              n.itemSize,\n              n.normalized\n            );\n          }\n          void 0 !== n.name && (s.name = n.name),\n            void 0 !== n.usage && s.setUsage(n.usage),\n            void 0 !== n.updateRange &&\n              ((s.updateRange.offset = n.updateRange.offset),\n              (s.updateRange.count = n.updateRange.count)),\n            r.setAttribute(e, s);\n        }\n        const o = t.data.morphAttributes;\n        if (o)\n          for (const e in o) {\n            const n = o[e],\n              s = [];\n            for (let e = 0, r = n.length; e < r; e++) {\n              const r = n[e];\n              let a;\n              if (r.isInterleavedBufferAttribute) {\n                const e = i(t.data, r.data);\n                a = new ra(e, r.itemSize, r.offset, r.normalized);\n              } else {\n                const t = bt(r.type, r.array);\n                a = new ln(t, r.itemSize, r.normalized);\n              }\n              void 0 !== r.name && (a.name = r.name), s.push(a);\n            }\n            r.morphAttributes[e] = s;\n          }\n        t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);\n        const l = t.data.groups || t.data.drawcalls || t.data.offsets;\n        if (void 0 !== l)\n          for (let t = 0, e = l.length; t !== e; ++t) {\n            const e = l[t];\n            r.addGroup(e.start, e.count, e.materialIndex);\n          }\n        const c = t.data.boundingSphere;\n        if (void 0 !== c) {\n          const t = new zt();\n          void 0 !== c.center && t.fromArray(c.center),\n            (r.boundingSphere = new ie(t, c.radius));\n        }\n        return (\n          t.name && (r.name = t.name),\n          t.userData && (r.userData = t.userData),\n          r\n        );\n      }\n    }\n    const Bc = {\n        UVMapping: i,\n        CubeReflectionMapping: r,\n        CubeRefractionMapping: s,\n        EquirectangularReflectionMapping: a,\n        EquirectangularRefractionMapping: o,\n        CubeUVReflectionMapping: l,\n        CubeUVRefractionMapping: c,\n      },\n      Fc = {\n        RepeatWrapping: h,\n        ClampToEdgeWrapping: u,\n        MirroredRepeatWrapping: d,\n      },\n      Oc = {\n        NearestFilter: p,\n        NearestMipmapNearestFilter: m,\n        NearestMipmapLinearFilter: f,\n        LinearFilter: g,\n        LinearMipmapNearestFilter: v,\n        LinearMipmapLinearFilter: y,\n      };\n    class Uc extends ac {\n      constructor(t) {\n        super(t),\n          \"undefined\" == typeof createImageBitmap &&\n            console.warn(\n              \"THREE.ImageBitmapLoader: createImageBitmap() not supported.\"\n            ),\n          \"undefined\" == typeof fetch &&\n            console.warn(\"THREE.ImageBitmapLoader: fetch() not supported.\"),\n          (this.options = { premultiplyAlpha: \"none\" });\n      }\n      setOptions(t) {\n        return (this.options = t), this;\n      }\n      load(t, e, n, i) {\n        void 0 === t && (t = \"\"),\n          void 0 !== this.path && (t = this.path + t),\n          (t = this.manager.resolveURL(t));\n        const r = this,\n          s = ic.get(t);\n        if (void 0 !== s)\n          return (\n            r.manager.itemStart(t),\n            setTimeout(function () {\n              e && e(s), r.manager.itemEnd(t);\n            }, 0),\n            s\n          );\n        const a = {};\n        (a.credentials =\n          \"anonymous\" === this.crossOrigin ? \"same-origin\" : \"include\"),\n          (a.headers = this.requestHeader),\n          fetch(t, a)\n            .then(function (t) {\n              return t.blob();\n            })\n            .then(function (t) {\n              return createImageBitmap(\n                t,\n                Object.assign(r.options, { colorSpaceConversion: \"none\" })\n              );\n            })\n            .then(function (n) {\n              ic.add(t, n), e && e(n), r.manager.itemEnd(t);\n            })\n            .catch(function (e) {\n              i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);\n            }),\n          r.manager.itemStart(t);\n      }\n    }\n    let Hc;\n    Uc.prototype.isImageBitmapLoader = !0;\n    const Gc = {\n      getContext: function () {\n        return (\n          void 0 === Hc &&\n            (Hc = new (window.AudioContext || window.webkitAudioContext)()),\n          Hc\n        );\n      },\n      setContext: function (t) {\n        Hc = t;\n      },\n    };\n    class kc extends ac {\n      constructor(t) {\n        super(t);\n      }\n      load(t, e, n, i) {\n        const r = this,\n          s = new lc(this.manager);\n        s.setResponseType(\"arraybuffer\"),\n          s.setPath(this.path),\n          s.setRequestHeader(this.requestHeader),\n          s.setWithCredentials(this.withCredentials),\n          s.load(\n            t,\n            function (n) {\n              try {\n                const t = n.slice(0);\n                Gc.getContext().decodeAudioData(t, function (t) {\n                  e(t);\n                });\n              } catch (e) {\n                i ? i(e) : console.error(e), r.manager.itemError(t);\n              }\n            },\n            n,\n            i\n          );\n      }\n    }\n    class Vc extends Pc {\n      constructor(t, e, n = 1) {\n        super(void 0, n);\n        const i = new rn().set(t),\n          r = new rn().set(e),\n          s = new zt(i.r, i.g, i.b),\n          a = new zt(r.r, r.g, r.b),\n          o = Math.sqrt(Math.PI),\n          l = o * Math.sqrt(0.75);\n        this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),\n          this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);\n      }\n    }\n    Vc.prototype.isHemisphereLightProbe = !0;\n    class Wc extends Pc {\n      constructor(t, e = 1) {\n        super(void 0, e);\n        const n = new rn().set(t);\n        this.sh.coefficients[0]\n          .set(n.r, n.g, n.b)\n          .multiplyScalar(2 * Math.sqrt(Math.PI));\n      }\n    }\n    Wc.prototype.isAmbientLightProbe = !0;\n    const jc = new de(),\n      qc = new de();\n    class Xc {\n      constructor(t = !0) {\n        (this.autoStart = t),\n          (this.startTime = 0),\n          (this.oldTime = 0),\n          (this.elapsedTime = 0),\n          (this.running = !1);\n      }\n      start() {\n        (this.startTime = Yc()),\n          (this.oldTime = this.startTime),\n          (this.elapsedTime = 0),\n          (this.running = !0);\n      }\n      stop() {\n        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);\n      }\n      getElapsedTime() {\n        return this.getDelta(), this.elapsedTime;\n      }\n      getDelta() {\n        let t = 0;\n        if (this.autoStart && !this.running) return this.start(), 0;\n        if (this.running) {\n          const e = Yc();\n          (t = (e - this.oldTime) / 1e3),\n            (this.oldTime = e),\n            (this.elapsedTime += t);\n        }\n        return t;\n      }\n    }\n    function Yc() {\n      return (\"undefined\" == typeof performance ? Date : performance).now();\n    }\n    const Jc = new zt(),\n      Zc = new Nt(),\n      Qc = new zt(),\n      Kc = new zt();\n    class $c extends Fe {\n      constructor(t) {\n        super(),\n          (this.type = \"Audio\"),\n          (this.listener = t),\n          (this.context = t.context),\n          (this.gain = this.context.createGain()),\n          this.gain.connect(t.getInput()),\n          (this.autoplay = !1),\n          (this.buffer = null),\n          (this.detune = 0),\n          (this.loop = !1),\n          (this.loopStart = 0),\n          (this.loopEnd = 0),\n          (this.offset = 0),\n          (this.duration = void 0),\n          (this.playbackRate = 1),\n          (this.isPlaying = !1),\n          (this.hasPlaybackControl = !0),\n          (this.source = null),\n          (this.sourceType = \"empty\"),\n          (this._startedAt = 0),\n          (this._progress = 0),\n          (this._connected = !1),\n          (this.filters = []);\n      }\n      getOutput() {\n        return this.gain;\n      }\n      setNodeSource(t) {\n        return (\n          (this.hasPlaybackControl = !1),\n          (this.sourceType = \"audioNode\"),\n          (this.source = t),\n          this.connect(),\n          this\n        );\n      }\n      setMediaElementSource(t) {\n        return (\n          (this.hasPlaybackControl = !1),\n          (this.sourceType = \"mediaNode\"),\n          (this.source = this.context.createMediaElementSource(t)),\n          this.connect(),\n          this\n        );\n      }\n      setMediaStreamSource(t) {\n        return (\n          (this.hasPlaybackControl = !1),\n          (this.sourceType = \"mediaStreamNode\"),\n          (this.source = this.context.createMediaStreamSource(t)),\n          this.connect(),\n          this\n        );\n      }\n      setBuffer(t) {\n        return (\n          (this.buffer = t),\n          (this.sourceType = \"buffer\"),\n          this.autoplay && this.play(),\n          this\n        );\n      }\n      play(t = 0) {\n        if (!0 === this.isPlaying)\n          return void console.warn(\"THREE.Audio: Audio is already playing.\");\n        if (!1 === this.hasPlaybackControl)\n          return void console.warn(\n            \"THREE.Audio: this Audio has no playback control.\"\n          );\n        this._startedAt = this.context.currentTime + t;\n        const e = this.context.createBufferSource();\n        return (\n          (e.buffer = this.buffer),\n          (e.loop = this.loop),\n          (e.loopStart = this.loopStart),\n          (e.loopEnd = this.loopEnd),\n          (e.onended = this.onEnded.bind(this)),\n          e.start(this._startedAt, this._progress + this.offset, this.duration),\n          (this.isPlaying = !0),\n          (this.source = e),\n          this.setDetune(this.detune),\n          this.setPlaybackRate(this.playbackRate),\n          this.connect()\n        );\n      }\n      pause() {\n        if (!1 !== this.hasPlaybackControl)\n          return (\n            !0 === this.isPlaying &&\n              ((this._progress +=\n                Math.max(this.context.currentTime - this._startedAt, 0) *\n                this.playbackRate),\n              !0 === this.loop &&\n                (this._progress =\n                  this._progress % (this.duration || this.buffer.duration)),\n              this.source.stop(),\n              (this.source.onended = null),\n              (this.isPlaying = !1)),\n            this\n          );\n        console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      }\n      stop() {\n        if (!1 !== this.hasPlaybackControl)\n          return (\n            (this._progress = 0),\n            this.source.stop(),\n            (this.source.onended = null),\n            (this.isPlaying = !1),\n            this\n          );\n        console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      }\n      connect() {\n        if (this.filters.length > 0) {\n          this.source.connect(this.filters[0]);\n          for (let t = 1, e = this.filters.length; t < e; t++)\n            this.filters[t - 1].connect(this.filters[t]);\n          this.filters[this.filters.length - 1].connect(this.getOutput());\n        } else this.source.connect(this.getOutput());\n        return (this._connected = !0), this;\n      }\n      disconnect() {\n        if (this.filters.length > 0) {\n          this.source.disconnect(this.filters[0]);\n          for (let t = 1, e = this.filters.length; t < e; t++)\n            this.filters[t - 1].disconnect(this.filters[t]);\n          this.filters[this.filters.length - 1].disconnect(this.getOutput());\n        } else this.source.disconnect(this.getOutput());\n        return (this._connected = !1), this;\n      }\n      getFilters() {\n        return this.filters;\n      }\n      setFilters(t) {\n        return (\n          t || (t = []),\n          !0 === this._connected\n            ? (this.disconnect(), (this.filters = t.slice()), this.connect())\n            : (this.filters = t.slice()),\n          this\n        );\n      }\n      setDetune(t) {\n        if (((this.detune = t), void 0 !== this.source.detune))\n          return (\n            !0 === this.isPlaying &&\n              this.source.detune.setTargetAtTime(\n                this.detune,\n                this.context.currentTime,\n                0.01\n              ),\n            this\n          );\n      }\n      getDetune() {\n        return this.detune;\n      }\n      getFilter() {\n        return this.getFilters()[0];\n      }\n      setFilter(t) {\n        return this.setFilters(t ? [t] : []);\n      }\n      setPlaybackRate(t) {\n        if (!1 !== this.hasPlaybackControl)\n          return (\n            (this.playbackRate = t),\n            !0 === this.isPlaying &&\n              this.source.playbackRate.setTargetAtTime(\n                this.playbackRate,\n                this.context.currentTime,\n                0.01\n              ),\n            this\n          );\n        console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      }\n      getPlaybackRate() {\n        return this.playbackRate;\n      }\n      onEnded() {\n        this.isPlaying = !1;\n      }\n      getLoop() {\n        return !1 === this.hasPlaybackControl\n          ? (console.warn(\"THREE.Audio: this Audio has no playback control.\"),\n            !1)\n          : this.loop;\n      }\n      setLoop(t) {\n        if (!1 !== this.hasPlaybackControl)\n          return (\n            (this.loop = t),\n            !0 === this.isPlaying && (this.source.loop = this.loop),\n            this\n          );\n        console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      }\n      setLoopStart(t) {\n        return (this.loopStart = t), this;\n      }\n      setLoopEnd(t) {\n        return (this.loopEnd = t), this;\n      }\n      getVolume() {\n        return this.gain.gain.value;\n      }\n      setVolume(t) {\n        return (\n          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),\n          this\n        );\n      }\n    }\n    const th = new zt(),\n      eh = new Nt(),\n      nh = new zt(),\n      ih = new zt();\n    class rh {\n      constructor(t, e = 2048) {\n        (this.analyser = t.context.createAnalyser()),\n          (this.analyser.fftSize = e),\n          (this.data = new Uint8Array(this.analyser.frequencyBinCount)),\n          t.getOutput().connect(this.analyser);\n      }\n      getFrequencyData() {\n        return this.analyser.getByteFrequencyData(this.data), this.data;\n      }\n      getAverageFrequency() {\n        let t = 0;\n        const e = this.getFrequencyData();\n        for (let n = 0; n < e.length; n++) t += e[n];\n        return t / e.length;\n      }\n    }\n    class sh {\n      constructor(t, e, n) {\n        let i, r, s;\n        switch (((this.binding = t), (this.valueSize = n), e)) {\n          case \"quaternion\":\n            (i = this._slerp),\n              (r = this._slerpAdditive),\n              (s = this._setAdditiveIdentityQuaternion),\n              (this.buffer = new Float64Array(6 * n)),\n              (this._workIndex = 5);\n            break;\n          case \"string\":\n          case \"bool\":\n            (i = this._select),\n              (r = this._select),\n              (s = this._setAdditiveIdentityOther),\n              (this.buffer = new Array(5 * n));\n            break;\n          default:\n            (i = this._lerp),\n              (r = this._lerpAdditive),\n              (s = this._setAdditiveIdentityNumeric),\n              (this.buffer = new Float64Array(5 * n));\n        }\n        (this._mixBufferRegion = i),\n          (this._mixBufferRegionAdditive = r),\n          (this._setIdentity = s),\n          (this._origIndex = 3),\n          (this._addIndex = 4),\n          (this.cumulativeWeight = 0),\n          (this.cumulativeWeightAdditive = 0),\n          (this.useCount = 0),\n          (this.referenceCount = 0);\n      }\n      accumulate(t, e) {\n        const n = this.buffer,\n          i = this.valueSize,\n          r = t * i + i;\n        let s = this.cumulativeWeight;\n        if (0 === s) {\n          for (let t = 0; t !== i; ++t) n[r + t] = n[t];\n          s = e;\n        } else {\n          s += e;\n          const t = e / s;\n          this._mixBufferRegion(n, r, 0, t, i);\n        }\n        this.cumulativeWeight = s;\n      }\n      accumulateAdditive(t) {\n        const e = this.buffer,\n          n = this.valueSize,\n          i = n * this._addIndex;\n        0 === this.cumulativeWeightAdditive && this._setIdentity(),\n          this._mixBufferRegionAdditive(e, i, 0, t, n),\n          (this.cumulativeWeightAdditive += t);\n      }\n      apply(t) {\n        const e = this.valueSize,\n          n = this.buffer,\n          i = t * e + e,\n          r = this.cumulativeWeight,\n          s = this.cumulativeWeightAdditive,\n          a = this.binding;\n        if (\n          ((this.cumulativeWeight = 0),\n          (this.cumulativeWeightAdditive = 0),\n          r < 1)\n        ) {\n          const t = e * this._origIndex;\n          this._mixBufferRegion(n, i, t, 1 - r, e);\n        }\n        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);\n        for (let t = e, r = e + e; t !== r; ++t)\n          if (n[t] !== n[t + e]) {\n            a.setValue(n, i);\n            break;\n          }\n      }\n      saveOriginalState() {\n        const t = this.binding,\n          e = this.buffer,\n          n = this.valueSize,\n          i = n * this._origIndex;\n        t.getValue(e, i);\n        for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];\n        this._setIdentity(),\n          (this.cumulativeWeight = 0),\n          (this.cumulativeWeightAdditive = 0);\n      }\n      restoreOriginalState() {\n        const t = 3 * this.valueSize;\n        this.binding.setValue(this.buffer, t);\n      }\n      _setAdditiveIdentityNumeric() {\n        const t = this._addIndex * this.valueSize,\n          e = t + this.valueSize;\n        for (let n = t; n < e; n++) this.buffer[n] = 0;\n      }\n      _setAdditiveIdentityQuaternion() {\n        this._setAdditiveIdentityNumeric(),\n          (this.buffer[this._addIndex * this.valueSize + 3] = 1);\n      }\n      _setAdditiveIdentityOther() {\n        const t = this._origIndex * this.valueSize,\n          e = this._addIndex * this.valueSize;\n        for (let n = 0; n < this.valueSize; n++)\n          this.buffer[e + n] = this.buffer[t + n];\n      }\n      _select(t, e, n, i, r) {\n        if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];\n      }\n      _slerp(t, e, n, i) {\n        Nt.slerpFlat(t, e, t, e, t, n, i);\n      }\n      _slerpAdditive(t, e, n, i, r) {\n        const s = this._workIndex * r;\n        Nt.multiplyQuaternionsFlat(t, s, t, e, t, n),\n          Nt.slerpFlat(t, e, t, e, t, s, i);\n      }\n      _lerp(t, e, n, i, r) {\n        const s = 1 - i;\n        for (let a = 0; a !== r; ++a) {\n          const r = e + a;\n          t[r] = t[r] * s + t[n + a] * i;\n        }\n      }\n      _lerpAdditive(t, e, n, i, r) {\n        for (let s = 0; s !== r; ++s) {\n          const r = e + s;\n          t[r] = t[r] + t[n + s] * i;\n        }\n      }\n    }\n    const ah = \"\\\\[\\\\]\\\\.:\\\\/\",\n      oh = new RegExp(\"[\\\\[\\\\]\\\\.:\\\\/]\", \"g\"),\n      lh = \"[^\\\\[\\\\]\\\\.:\\\\/]\",\n      ch = \"[^\" + ah.replace(\"\\\\.\", \"\") + \"]\",\n      hh = /((?:WC+[\\/:])*)/.source.replace(\"WC\", lh),\n      uh = /(WCOD+)?/.source.replace(\"WCOD\", ch),\n      dh = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\", lh),\n      ph = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\", lh),\n      mh = new RegExp(\"^\" + hh + uh + dh + ph + \"$\"),\n      fh = [\"material\", \"materials\", \"bones\"];\n    class gh {\n      constructor(t, e, n) {\n        (this.path = e),\n          (this.parsedPath = n || gh.parseTrackName(e)),\n          (this.node = gh.findNode(t, this.parsedPath.nodeName) || t),\n          (this.rootNode = t),\n          (this.getValue = this._getValue_unbound),\n          (this.setValue = this._setValue_unbound);\n      }\n      static create(t, e, n) {\n        return t && t.isAnimationObjectGroup\n          ? new gh.Composite(t, e, n)\n          : new gh(t, e, n);\n      }\n      static sanitizeNodeName(t) {\n        return t.replace(/\\s/g, \"_\").replace(oh, \"\");\n      }\n      static parseTrackName(t) {\n        const e = mh.exec(t);\n        if (!e)\n          throw new Error(\"PropertyBinding: Cannot parse trackName: \" + t);\n        const n = {\n            nodeName: e[2],\n            objectName: e[3],\n            objectIndex: e[4],\n            propertyName: e[5],\n            propertyIndex: e[6],\n          },\n          i = n.nodeName && n.nodeName.lastIndexOf(\".\");\n        if (void 0 !== i && -1 !== i) {\n          const t = n.nodeName.substring(i + 1);\n          -1 !== fh.indexOf(t) &&\n            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));\n        }\n        if (null === n.propertyName || 0 === n.propertyName.length)\n          throw new Error(\n            \"PropertyBinding: can not parse propertyName from trackName: \" + t\n          );\n        return n;\n      }\n      static findNode(t, e) {\n        if (\n          !e ||\n          \"\" === e ||\n          \".\" === e ||\n          -1 === e ||\n          e === t.name ||\n          e === t.uuid\n        )\n          return t;\n        if (t.skeleton) {\n          const n = t.skeleton.getBoneByName(e);\n          if (void 0 !== n) return n;\n        }\n        if (t.children) {\n          const n = function (t) {\n              for (let i = 0; i < t.length; i++) {\n                const r = t[i];\n                if (r.name === e || r.uuid === e) return r;\n                const s = n(r.children);\n                if (s) return s;\n              }\n              return null;\n            },\n            i = n(t.children);\n          if (i) return i;\n        }\n        return null;\n      }\n      _getValue_unavailable() {}\n      _setValue_unavailable() {}\n      _getValue_direct(t, e) {\n        t[e] = this.targetObject[this.propertyName];\n      }\n      _getValue_array(t, e) {\n        const n = this.resolvedProperty;\n        for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];\n      }\n      _getValue_arrayElement(t, e) {\n        t[e] = this.resolvedProperty[this.propertyIndex];\n      }\n      _getValue_toArray(t, e) {\n        this.resolvedProperty.toArray(t, e);\n      }\n      _setValue_direct(t, e) {\n        this.targetObject[this.propertyName] = t[e];\n      }\n      _setValue_direct_setNeedsUpdate(t, e) {\n        (this.targetObject[this.propertyName] = t[e]),\n          (this.targetObject.needsUpdate = !0);\n      }\n      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {\n        (this.targetObject[this.propertyName] = t[e]),\n          (this.targetObject.matrixWorldNeedsUpdate = !0);\n      }\n      _setValue_array(t, e) {\n        const n = this.resolvedProperty;\n        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];\n      }\n      _setValue_array_setNeedsUpdate(t, e) {\n        const n = this.resolvedProperty;\n        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];\n        this.targetObject.needsUpdate = !0;\n      }\n      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {\n        const n = this.resolvedProperty;\n        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];\n        this.targetObject.matrixWorldNeedsUpdate = !0;\n      }\n      _setValue_arrayElement(t, e) {\n        this.resolvedProperty[this.propertyIndex] = t[e];\n      }\n      _setValue_arrayElement_setNeedsUpdate(t, e) {\n        (this.resolvedProperty[this.propertyIndex] = t[e]),\n          (this.targetObject.needsUpdate = !0);\n      }\n      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {\n        (this.resolvedProperty[this.propertyIndex] = t[e]),\n          (this.targetObject.matrixWorldNeedsUpdate = !0);\n      }\n      _setValue_fromArray(t, e) {\n        this.resolvedProperty.fromArray(t, e);\n      }\n      _setValue_fromArray_setNeedsUpdate(t, e) {\n        this.resolvedProperty.fromArray(t, e),\n          (this.targetObject.needsUpdate = !0);\n      }\n      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {\n        this.resolvedProperty.fromArray(t, e),\n          (this.targetObject.matrixWorldNeedsUpdate = !0);\n      }\n      _getValue_unbound(t, e) {\n        this.bind(), this.getValue(t, e);\n      }\n      _setValue_unbound(t, e) {\n        this.bind(), this.setValue(t, e);\n      }\n      bind() {\n        let t = this.node;\n        const e = this.parsedPath,\n          n = e.objectName,\n          i = e.propertyName;\n        let r = e.propertyIndex;\n        if (\n          (t ||\n            ((t = gh.findNode(this.rootNode, e.nodeName) || this.rootNode),\n            (this.node = t)),\n          (this.getValue = this._getValue_unavailable),\n          (this.setValue = this._setValue_unavailable),\n          !t)\n        )\n          return void console.error(\n            \"THREE.PropertyBinding: Trying to update node for track: \" +\n              this.path +\n              \" but it wasn't found.\"\n          );\n        if (n) {\n          let i = e.objectIndex;\n          switch (n) {\n            case \"materials\":\n              if (!t.material)\n                return void console.error(\n                  \"THREE.PropertyBinding: Can not bind to material as node does not have a material.\",\n                  this\n                );\n              if (!t.material.materials)\n                return void console.error(\n                  \"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.\",\n                  this\n                );\n              t = t.material.materials;\n              break;\n            case \"bones\":\n              if (!t.skeleton)\n                return void console.error(\n                  \"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.\",\n                  this\n                );\n              t = t.skeleton.bones;\n              for (let e = 0; e < t.length; e++)\n                if (t[e].name === i) {\n                  i = e;\n                  break;\n                }\n              break;\n            default:\n              if (void 0 === t[n])\n                return void console.error(\n                  \"THREE.PropertyBinding: Can not bind to objectName of node undefined.\",\n                  this\n                );\n              t = t[n];\n          }\n          if (void 0 !== i) {\n            if (void 0 === t[i])\n              return void console.error(\n                \"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.\",\n                this,\n                t\n              );\n            t = t[i];\n          }\n        }\n        const s = t[i];\n        if (void 0 === s) {\n          const n = e.nodeName;\n          return void console.error(\n            \"THREE.PropertyBinding: Trying to update property for track: \" +\n              n +\n              \".\" +\n              i +\n              \" but it wasn't found.\",\n            t\n          );\n        }\n        let a = this.Versioning.None;\n        (this.targetObject = t),\n          void 0 !== t.needsUpdate\n            ? (a = this.Versioning.NeedsUpdate)\n            : void 0 !== t.matrixWorldNeedsUpdate &&\n              (a = this.Versioning.MatrixWorldNeedsUpdate);\n        let o = this.BindingType.Direct;\n        if (void 0 !== r) {\n          if (\"morphTargetInfluences\" === i) {\n            if (!t.geometry)\n              return void console.error(\n                \"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.\",\n                this\n              );\n            if (!t.geometry.isBufferGeometry)\n              return void console.error(\n                \"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.\",\n                this\n              );\n            if (!t.geometry.morphAttributes)\n              return void console.error(\n                \"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.\",\n                this\n              );\n            void 0 !== t.morphTargetDictionary[r] &&\n              (r = t.morphTargetDictionary[r]);\n          }\n          (o = this.BindingType.ArrayElement),\n            (this.resolvedProperty = s),\n            (this.propertyIndex = r);\n        } else void 0 !== s.fromArray && void 0 !== s.toArray ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s)) : Array.isArray(s) ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s)) : (this.propertyName = i);\n        (this.getValue = this.GetterByBindingType[o]),\n          (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);\n      }\n      unbind() {\n        (this.node = null),\n          (this.getValue = this._getValue_unbound),\n          (this.setValue = this._setValue_unbound);\n      }\n    }\n    (gh.Composite = class {\n      constructor(t, e, n) {\n        const i = n || gh.parseTrackName(e);\n        (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));\n      }\n      getValue(t, e) {\n        this.bind();\n        const n = this._targetGroup.nCachedObjects_,\n          i = this._bindings[n];\n        void 0 !== i && i.getValue(t, e);\n      }\n      setValue(t, e) {\n        const n = this._bindings;\n        for (\n          let i = this._targetGroup.nCachedObjects_, r = n.length;\n          i !== r;\n          ++i\n        )\n          n[i].setValue(t, e);\n      }\n      bind() {\n        const t = this._bindings;\n        for (\n          let e = this._targetGroup.nCachedObjects_, n = t.length;\n          e !== n;\n          ++e\n        )\n          t[e].bind();\n      }\n      unbind() {\n        const t = this._bindings;\n        for (\n          let e = this._targetGroup.nCachedObjects_, n = t.length;\n          e !== n;\n          ++e\n        )\n          t[e].unbind();\n      }\n    }),\n      (gh.prototype.BindingType = {\n        Direct: 0,\n        EntireArray: 1,\n        ArrayElement: 2,\n        HasFromToArray: 3,\n      }),\n      (gh.prototype.Versioning = {\n        None: 0,\n        NeedsUpdate: 1,\n        MatrixWorldNeedsUpdate: 2,\n      }),\n      (gh.prototype.GetterByBindingType = [\n        gh.prototype._getValue_direct,\n        gh.prototype._getValue_array,\n        gh.prototype._getValue_arrayElement,\n        gh.prototype._getValue_toArray,\n      ]),\n      (gh.prototype.SetterByBindingTypeAndVersioning = [\n        [\n          gh.prototype._setValue_direct,\n          gh.prototype._setValue_direct_setNeedsUpdate,\n          gh.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n        ],\n        [\n          gh.prototype._setValue_array,\n          gh.prototype._setValue_array_setNeedsUpdate,\n          gh.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n        ],\n        [\n          gh.prototype._setValue_arrayElement,\n          gh.prototype._setValue_arrayElement_setNeedsUpdate,\n          gh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n        ],\n        [\n          gh.prototype._setValue_fromArray,\n          gh.prototype._setValue_fromArray_setNeedsUpdate,\n          gh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n        ],\n      ]);\n    class vh {\n      constructor() {\n        (this.uuid = ht()),\n          (this._objects = Array.prototype.slice.call(arguments)),\n          (this.nCachedObjects_ = 0);\n        const t = {};\n        this._indicesByUUID = t;\n        for (let e = 0, n = arguments.length; e !== n; ++e)\n          t[arguments[e].uuid] = e;\n        (this._paths = []),\n          (this._parsedPaths = []),\n          (this._bindings = []),\n          (this._bindingsIndicesByPath = {});\n        const e = this;\n        this.stats = {\n          objects: {\n            get total() {\n              return e._objects.length;\n            },\n            get inUse() {\n              return this.total - e.nCachedObjects_;\n            },\n          },\n          get bindingsPerObject() {\n            return e._bindings.length;\n          },\n        };\n      }\n      add() {\n        const t = this._objects,\n          e = this._indicesByUUID,\n          n = this._paths,\n          i = this._parsedPaths,\n          r = this._bindings,\n          s = r.length;\n        let a,\n          o = t.length,\n          l = this.nCachedObjects_;\n        for (let c = 0, h = arguments.length; c !== h; ++c) {\n          const h = arguments[c],\n            u = h.uuid;\n          let d = e[u];\n          if (void 0 === d) {\n            (d = o++), (e[u] = d), t.push(h);\n            for (let t = 0, e = s; t !== e; ++t)\n              r[t].push(new gh(h, n[t], i[t]));\n          } else if (d < l) {\n            a = t[d];\n            const o = --l,\n              c = t[o];\n            (e[c.uuid] = d), (t[d] = c), (e[u] = o), (t[o] = h);\n            for (let t = 0, e = s; t !== e; ++t) {\n              const e = r[t],\n                s = e[o];\n              let a = e[d];\n              (e[d] = s),\n                void 0 === a && (a = new gh(h, n[t], i[t])),\n                (e[o] = a);\n            }\n          } else\n            t[d] !== a &&\n              console.error(\n                \"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.\"\n              );\n        }\n        this.nCachedObjects_ = l;\n      }\n      remove() {\n        const t = this._objects,\n          e = this._indicesByUUID,\n          n = this._bindings,\n          i = n.length;\n        let r = this.nCachedObjects_;\n        for (let s = 0, a = arguments.length; s !== a; ++s) {\n          const a = arguments[s],\n            o = a.uuid,\n            l = e[o];\n          if (void 0 !== l && l >= r) {\n            const s = r++,\n              c = t[s];\n            (e[c.uuid] = l), (t[l] = c), (e[o] = s), (t[s] = a);\n            for (let t = 0, e = i; t !== e; ++t) {\n              const e = n[t],\n                i = e[s],\n                r = e[l];\n              (e[l] = i), (e[s] = r);\n            }\n          }\n        }\n        this.nCachedObjects_ = r;\n      }\n      uncache() {\n        const t = this._objects,\n          e = this._indicesByUUID,\n          n = this._bindings,\n          i = n.length;\n        let r = this.nCachedObjects_,\n          s = t.length;\n        for (let a = 0, o = arguments.length; a !== o; ++a) {\n          const o = arguments[a].uuid,\n            l = e[o];\n          if (void 0 !== l)\n            if ((delete e[o], l < r)) {\n              const a = --r,\n                o = t[a],\n                c = --s,\n                h = t[c];\n              (e[o.uuid] = l), (t[l] = o), (e[h.uuid] = a), (t[a] = h), t.pop();\n              for (let t = 0, e = i; t !== e; ++t) {\n                const e = n[t],\n                  i = e[a],\n                  r = e[c];\n                (e[l] = i), (e[a] = r), e.pop();\n              }\n            } else {\n              const r = --s,\n                a = t[r];\n              r > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();\n              for (let t = 0, e = i; t !== e; ++t) {\n                const e = n[t];\n                (e[l] = e[r]), e.pop();\n              }\n            }\n        }\n        this.nCachedObjects_ = r;\n      }\n      subscribe_(t, e) {\n        const n = this._bindingsIndicesByPath;\n        let i = n[t];\n        const r = this._bindings;\n        if (void 0 !== i) return r[i];\n        const s = this._paths,\n          a = this._parsedPaths,\n          o = this._objects,\n          l = o.length,\n          c = this.nCachedObjects_,\n          h = new Array(l);\n        (i = r.length), (n[t] = i), s.push(t), a.push(e), r.push(h);\n        for (let n = c, i = o.length; n !== i; ++n) {\n          const i = o[n];\n          h[n] = new gh(i, t, e);\n        }\n        return h;\n      }\n      unsubscribe_(t) {\n        const e = this._bindingsIndicesByPath,\n          n = e[t];\n        if (void 0 !== n) {\n          const i = this._paths,\n            r = this._parsedPaths,\n            s = this._bindings,\n            a = s.length - 1,\n            o = s[a];\n          (e[t[a]] = n),\n            (s[n] = o),\n            s.pop(),\n            (r[n] = r[a]),\n            r.pop(),\n            (i[n] = i[a]),\n            i.pop();\n        }\n      }\n    }\n    vh.prototype.isAnimationObjectGroup = !0;\n    class yh {\n      constructor(t, e, n = null, i = e.blendMode) {\n        (this._mixer = t),\n          (this._clip = e),\n          (this._localRoot = n),\n          (this.blendMode = i);\n        const r = e.tracks,\n          s = r.length,\n          a = new Array(s),\n          o = { endingStart: k, endingEnd: k };\n        for (let t = 0; t !== s; ++t) {\n          const e = r[t].createInterpolant(null);\n          (a[t] = e), (e.settings = o);\n        }\n        (this._interpolantSettings = o),\n          (this._interpolants = a),\n          (this._propertyBindings = new Array(s)),\n          (this._cacheIndex = null),\n          (this._byClipCacheIndex = null),\n          (this._timeScaleInterpolant = null),\n          (this._weightInterpolant = null),\n          (this.loop = 2201),\n          (this._loopCount = -1),\n          (this._startTime = null),\n          (this.time = 0),\n          (this.timeScale = 1),\n          (this._effectiveTimeScale = 1),\n          (this.weight = 1),\n          (this._effectiveWeight = 1),\n          (this.repetitions = 1 / 0),\n          (this.paused = !1),\n          (this.enabled = !0),\n          (this.clampWhenFinished = !1),\n          (this.zeroSlopeAtStart = !0),\n          (this.zeroSlopeAtEnd = !0);\n      }\n      play() {\n        return this._mixer._activateAction(this), this;\n      }\n      stop() {\n        return this._mixer._deactivateAction(this), this.reset();\n      }\n      reset() {\n        return (\n          (this.paused = !1),\n          (this.enabled = !0),\n          (this.time = 0),\n          (this._loopCount = -1),\n          (this._startTime = null),\n          this.stopFading().stopWarping()\n        );\n      }\n      isRunning() {\n        return (\n          this.enabled &&\n          !this.paused &&\n          0 !== this.timeScale &&\n          null === this._startTime &&\n          this._mixer._isActiveAction(this)\n        );\n      }\n      isScheduled() {\n        return this._mixer._isActiveAction(this);\n      }\n      startAt(t) {\n        return (this._startTime = t), this;\n      }\n      setLoop(t, e) {\n        return (this.loop = t), (this.repetitions = e), this;\n      }\n      setEffectiveWeight(t) {\n        return (\n          (this.weight = t),\n          (this._effectiveWeight = this.enabled ? t : 0),\n          this.stopFading()\n        );\n      }\n      getEffectiveWeight() {\n        return this._effectiveWeight;\n      }\n      fadeIn(t) {\n        return this._scheduleFading(t, 0, 1);\n      }\n      fadeOut(t) {\n        return this._scheduleFading(t, 1, 0);\n      }\n      crossFadeFrom(t, e, n) {\n        if ((t.fadeOut(e), this.fadeIn(e), n)) {\n          const n = this._clip.duration,\n            i = t._clip.duration,\n            r = i / n,\n            s = n / i;\n          t.warp(1, r, e), this.warp(s, 1, e);\n        }\n        return this;\n      }\n      crossFadeTo(t, e, n) {\n        return t.crossFadeFrom(this, e, n);\n      }\n      stopFading() {\n        const t = this._weightInterpolant;\n        return (\n          null !== t &&\n            ((this._weightInterpolant = null),\n            this._mixer._takeBackControlInterpolant(t)),\n          this\n        );\n      }\n      setEffectiveTimeScale(t) {\n        return (\n          (this.timeScale = t),\n          (this._effectiveTimeScale = this.paused ? 0 : t),\n          this.stopWarping()\n        );\n      }\n      getEffectiveTimeScale() {\n        return this._effectiveTimeScale;\n      }\n      setDuration(t) {\n        return (this.timeScale = this._clip.duration / t), this.stopWarping();\n      }\n      syncWith(t) {\n        return (\n          (this.time = t.time),\n          (this.timeScale = t.timeScale),\n          this.stopWarping()\n        );\n      }\n      halt(t) {\n        return this.warp(this._effectiveTimeScale, 0, t);\n      }\n      warp(t, e, n) {\n        const i = this._mixer,\n          r = i.time,\n          s = this.timeScale;\n        let a = this._timeScaleInterpolant;\n        null === a &&\n          ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));\n        const o = a.parameterPositions,\n          l = a.sampleValues;\n        return (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this;\n      }\n      stopWarping() {\n        const t = this._timeScaleInterpolant;\n        return (\n          null !== t &&\n            ((this._timeScaleInterpolant = null),\n            this._mixer._takeBackControlInterpolant(t)),\n          this\n        );\n      }\n      getMixer() {\n        return this._mixer;\n      }\n      getClip() {\n        return this._clip;\n      }\n      getRoot() {\n        return this._localRoot || this._mixer._root;\n      }\n      _update(t, e, n, i) {\n        if (!this.enabled) return void this._updateWeight(t);\n        const r = this._startTime;\n        if (null !== r) {\n          const i = (t - r) * n;\n          if (i < 0 || 0 === n) return;\n          (this._startTime = null), (e = n * i);\n        }\n        e *= this._updateTimeScale(t);\n        const s = this._updateTime(e),\n          a = this._updateWeight(t);\n        if (a > 0) {\n          const t = this._interpolants,\n            e = this._propertyBindings;\n          if (this.blendMode === q)\n            for (let n = 0, i = t.length; n !== i; ++n)\n              t[n].evaluate(s), e[n].accumulateAdditive(a);\n          else\n            for (let n = 0, r = t.length; n !== r; ++n)\n              t[n].evaluate(s), e[n].accumulate(i, a);\n        }\n      }\n      _updateWeight(t) {\n        let e = 0;\n        if (this.enabled) {\n          e = this.weight;\n          const n = this._weightInterpolant;\n          if (null !== n) {\n            const i = n.evaluate(t)[0];\n            (e *= i),\n              t > n.parameterPositions[1] &&\n                (this.stopFading(), 0 === i && (this.enabled = !1));\n          }\n        }\n        return (this._effectiveWeight = e), e;\n      }\n      _updateTimeScale(t) {\n        let e = 0;\n        if (!this.paused) {\n          e = this.timeScale;\n          const n = this._timeScaleInterpolant;\n          if (null !== n) {\n            (e *= n.evaluate(t)[0]),\n              t > n.parameterPositions[1] &&\n                (this.stopWarping(),\n                0 === e ? (this.paused = !0) : (this.timeScale = e));\n          }\n        }\n        return (this._effectiveTimeScale = e), e;\n      }\n      _updateTime(t) {\n        const e = this._clip.duration,\n          n = this.loop;\n        let i = this.time + t,\n          r = this._loopCount;\n        const s = 2202 === n;\n        if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;\n        if (2200 === n) {\n          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));\n          t: {\n            if (i >= e) i = e;\n            else {\n              if (!(i < 0)) {\n                this.time = i;\n                break t;\n              }\n              i = 0;\n            }\n            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),\n              (this.time = i),\n              this._mixer.dispatchEvent({\n                type: \"finished\",\n                action: this,\n                direction: t < 0 ? -1 : 1,\n              });\n          }\n        } else {\n          if (\n            (-1 === r &&\n              (t >= 0\n                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))\n                : this._setEndings(0 === this.repetitions, !0, s)),\n            i >= e || i < 0)\n          ) {\n            const n = Math.floor(i / e);\n            (i -= e * n), (r += Math.abs(n));\n            const a = this.repetitions - r;\n            if (a <= 0)\n              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),\n                (i = t > 0 ? e : 0),\n                (this.time = i),\n                this._mixer.dispatchEvent({\n                  type: \"finished\",\n                  action: this,\n                  direction: t > 0 ? 1 : -1,\n                });\n            else {\n              if (1 === a) {\n                const e = t < 0;\n                this._setEndings(e, !e, s);\n              } else this._setEndings(!1, !1, s);\n              (this._loopCount = r),\n                (this.time = i),\n                this._mixer.dispatchEvent({\n                  type: \"loop\",\n                  action: this,\n                  loopDelta: n,\n                });\n            }\n          } else this.time = i;\n          if (s && 1 == (1 & r)) return e - i;\n        }\n        return i;\n      }\n      _setEndings(t, e, n) {\n        const i = this._interpolantSettings;\n        n\n          ? ((i.endingStart = V), (i.endingEnd = V))\n          : ((i.endingStart = t ? (this.zeroSlopeAtStart ? V : k) : W),\n            (i.endingEnd = e ? (this.zeroSlopeAtEnd ? V : k) : W));\n      }\n      _scheduleFading(t, e, n) {\n        const i = this._mixer,\n          r = i.time;\n        let s = this._weightInterpolant;\n        null === s &&\n          ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));\n        const a = s.parameterPositions,\n          o = s.sampleValues;\n        return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;\n      }\n    }\n    class xh extends rt {\n      constructor(t) {\n        super(),\n          (this._root = t),\n          this._initMemoryManager(),\n          (this._accuIndex = 0),\n          (this.time = 0),\n          (this.timeScale = 1);\n      }\n      _bindAction(t, e) {\n        const n = t._localRoot || this._root,\n          i = t._clip.tracks,\n          r = i.length,\n          s = t._propertyBindings,\n          a = t._interpolants,\n          o = n.uuid,\n          l = this._bindingsByRootAndName;\n        let c = l[o];\n        void 0 === c && ((c = {}), (l[o] = c));\n        for (let t = 0; t !== r; ++t) {\n          const r = i[t],\n            l = r.name;\n          let h = c[l];\n          if (void 0 !== h) s[t] = h;\n          else {\n            if (((h = s[t]), void 0 !== h)) {\n              null === h._cacheIndex &&\n                (++h.referenceCount, this._addInactiveBinding(h, o, l));\n              continue;\n            }\n            const i = e && e._propertyBindings[t].binding.parsedPath;\n            (h = new sh(gh.create(n, l, i), r.ValueTypeName, r.getValueSize())),\n              ++h.referenceCount,\n              this._addInactiveBinding(h, o, l),\n              (s[t] = h);\n          }\n          a[t].resultBuffer = h.buffer;\n        }\n      }\n      _activateAction(t) {\n        if (!this._isActiveAction(t)) {\n          if (null === t._cacheIndex) {\n            const e = (t._localRoot || this._root).uuid,\n              n = t._clip.uuid,\n              i = this._actionsByClip[n];\n            this._bindAction(t, i && i.knownActions[0]),\n              this._addInactiveAction(t, n, e);\n          }\n          const e = t._propertyBindings;\n          for (let t = 0, n = e.length; t !== n; ++t) {\n            const n = e[t];\n            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());\n          }\n          this._lendAction(t);\n        }\n      }\n      _deactivateAction(t) {\n        if (this._isActiveAction(t)) {\n          const e = t._propertyBindings;\n          for (let t = 0, n = e.length; t !== n; ++t) {\n            const n = e[t];\n            0 == --n.useCount &&\n              (n.restoreOriginalState(), this._takeBackBinding(n));\n          }\n          this._takeBackAction(t);\n        }\n      }\n      _initMemoryManager() {\n        (this._actions = []),\n          (this._nActiveActions = 0),\n          (this._actionsByClip = {}),\n          (this._bindings = []),\n          (this._nActiveBindings = 0),\n          (this._bindingsByRootAndName = {}),\n          (this._controlInterpolants = []),\n          (this._nActiveControlInterpolants = 0);\n        const t = this;\n        this.stats = {\n          actions: {\n            get total() {\n              return t._actions.length;\n            },\n            get inUse() {\n              return t._nActiveActions;\n            },\n          },\n          bindings: {\n            get total() {\n              return t._bindings.length;\n            },\n            get inUse() {\n              return t._nActiveBindings;\n            },\n          },\n          controlInterpolants: {\n            get total() {\n              return t._controlInterpolants.length;\n            },\n            get inUse() {\n              return t._nActiveControlInterpolants;\n            },\n          },\n        };\n      }\n      _isActiveAction(t) {\n        const e = t._cacheIndex;\n        return null !== e && e < this._nActiveActions;\n      }\n      _addInactiveAction(t, e, n) {\n        const i = this._actions,\n          r = this._actionsByClip;\n        let s = r[e];\n        if (void 0 === s)\n          (s = { knownActions: [t], actionByRoot: {} }),\n            (t._byClipCacheIndex = 0),\n            (r[e] = s);\n        else {\n          const e = s.knownActions;\n          (t._byClipCacheIndex = e.length), e.push(t);\n        }\n        (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);\n      }\n      _removeInactiveAction(t) {\n        const e = this._actions,\n          n = e[e.length - 1],\n          i = t._cacheIndex;\n        (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);\n        const r = t._clip.uuid,\n          s = this._actionsByClip,\n          a = s[r],\n          o = a.knownActions,\n          l = o[o.length - 1],\n          c = t._byClipCacheIndex;\n        (l._byClipCacheIndex = c),\n          (o[c] = l),\n          o.pop(),\n          (t._byClipCacheIndex = null);\n        delete a.actionByRoot[(t._localRoot || this._root).uuid],\n          0 === o.length && delete s[r],\n          this._removeInactiveBindingsForAction(t);\n      }\n      _removeInactiveBindingsForAction(t) {\n        const e = t._propertyBindings;\n        for (let t = 0, n = e.length; t !== n; ++t) {\n          const n = e[t];\n          0 == --n.referenceCount && this._removeInactiveBinding(n);\n        }\n      }\n      _lendAction(t) {\n        const e = this._actions,\n          n = t._cacheIndex,\n          i = this._nActiveActions++,\n          r = e[i];\n        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);\n      }\n      _takeBackAction(t) {\n        const e = this._actions,\n          n = t._cacheIndex,\n          i = --this._nActiveActions,\n          r = e[i];\n        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);\n      }\n      _addInactiveBinding(t, e, n) {\n        const i = this._bindingsByRootAndName,\n          r = this._bindings;\n        let s = i[e];\n        void 0 === s && ((s = {}), (i[e] = s)),\n          (s[n] = t),\n          (t._cacheIndex = r.length),\n          r.push(t);\n      }\n      _removeInactiveBinding(t) {\n        const e = this._bindings,\n          n = t.binding,\n          i = n.rootNode.uuid,\n          r = n.path,\n          s = this._bindingsByRootAndName,\n          a = s[i],\n          o = e[e.length - 1],\n          l = t._cacheIndex;\n        (o._cacheIndex = l),\n          (e[l] = o),\n          e.pop(),\n          delete a[r],\n          0 === Object.keys(a).length && delete s[i];\n      }\n      _lendBinding(t) {\n        const e = this._bindings,\n          n = t._cacheIndex,\n          i = this._nActiveBindings++,\n          r = e[i];\n        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);\n      }\n      _takeBackBinding(t) {\n        const e = this._bindings,\n          n = t._cacheIndex,\n          i = --this._nActiveBindings,\n          r = e[i];\n        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);\n      }\n      _lendControlInterpolant() {\n        const t = this._controlInterpolants,\n          e = this._nActiveControlInterpolants++;\n        let n = t[e];\n        return (\n          void 0 === n &&\n            ((n = new jl(\n              new Float32Array(2),\n              new Float32Array(2),\n              1,\n              this._controlInterpolantsResultBuffer\n            )),\n            (n.__cacheIndex = e),\n            (t[e] = n)),\n          n\n        );\n      }\n      _takeBackControlInterpolant(t) {\n        const e = this._controlInterpolants,\n          n = t.__cacheIndex,\n          i = --this._nActiveControlInterpolants,\n          r = e[i];\n        (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);\n      }\n      clipAction(t, e, n) {\n        const i = e || this._root,\n          r = i.uuid;\n        let s = \"string\" == typeof t ? ec.findByName(i, t) : t;\n        const a = null !== s ? s.uuid : t,\n          o = this._actionsByClip[a];\n        let l = null;\n        if (\n          (void 0 === n && (n = null !== s ? s.blendMode : j), void 0 !== o)\n        ) {\n          const t = o.actionByRoot[r];\n          if (void 0 !== t && t.blendMode === n) return t;\n          (l = o.knownActions[0]), null === s && (s = l._clip);\n        }\n        if (null === s) return null;\n        const c = new yh(this, s, e, n);\n        return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;\n      }\n      existingAction(t, e) {\n        const n = e || this._root,\n          i = n.uuid,\n          r = \"string\" == typeof t ? ec.findByName(n, t) : t,\n          s = r ? r.uuid : t,\n          a = this._actionsByClip[s];\n        return (void 0 !== a && a.actionByRoot[i]) || null;\n      }\n      stopAllAction() {\n        const t = this._actions;\n        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();\n        return this;\n      }\n      update(t) {\n        t *= this.timeScale;\n        const e = this._actions,\n          n = this._nActiveActions,\n          i = (this.time += t),\n          r = Math.sign(t),\n          s = (this._accuIndex ^= 1);\n        for (let a = 0; a !== n; ++a) {\n          e[a]._update(i, t, r, s);\n        }\n        const a = this._bindings,\n          o = this._nActiveBindings;\n        for (let t = 0; t !== o; ++t) a[t].apply(s);\n        return this;\n      }\n      setTime(t) {\n        this.time = 0;\n        for (let t = 0; t < this._actions.length; t++)\n          this._actions[t].time = 0;\n        return this.update(t);\n      }\n      getRoot() {\n        return this._root;\n      }\n      uncacheClip(t) {\n        const e = this._actions,\n          n = t.uuid,\n          i = this._actionsByClip,\n          r = i[n];\n        if (void 0 !== r) {\n          const t = r.knownActions;\n          for (let n = 0, i = t.length; n !== i; ++n) {\n            const i = t[n];\n            this._deactivateAction(i);\n            const r = i._cacheIndex,\n              s = e[e.length - 1];\n            (i._cacheIndex = null),\n              (i._byClipCacheIndex = null),\n              (s._cacheIndex = r),\n              (e[r] = s),\n              e.pop(),\n              this._removeInactiveBindingsForAction(i);\n          }\n          delete i[n];\n        }\n      }\n      uncacheRoot(t) {\n        const e = t.uuid,\n          n = this._actionsByClip;\n        for (const t in n) {\n          const i = n[t].actionByRoot[e];\n          void 0 !== i &&\n            (this._deactivateAction(i), this._removeInactiveAction(i));\n        }\n        const i = this._bindingsByRootAndName[e];\n        if (void 0 !== i)\n          for (const t in i) {\n            const e = i[t];\n            e.restoreOriginalState(), this._removeInactiveBinding(e);\n          }\n      }\n      uncacheAction(t, e) {\n        const n = this.existingAction(t, e);\n        null !== n &&\n          (this._deactivateAction(n), this._removeInactiveAction(n));\n      }\n    }\n    xh.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n    class _h {\n      constructor(t) {\n        \"string\" == typeof t &&\n          (console.warn(\"THREE.Uniform: Type parameter is no longer needed.\"),\n          (t = arguments[1])),\n          (this.value = t);\n      }\n      clone() {\n        return new _h(\n          void 0 === this.value.clone ? this.value : this.value.clone()\n        );\n      }\n    }\n    class Mh extends na {\n      constructor(t, e, n = 1) {\n        super(t, e), (this.meshPerAttribute = n);\n      }\n      copy(t) {\n        return (\n          super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this\n        );\n      }\n      clone(t) {\n        const e = super.clone(t);\n        return (e.meshPerAttribute = this.meshPerAttribute), e;\n      }\n      toJSON(t) {\n        const e = super.toJSON(t);\n        return (\n          (e.isInstancedInterleavedBuffer = !0),\n          (e.meshPerAttribute = this.meshPerAttribute),\n          e\n        );\n      }\n    }\n    Mh.prototype.isInstancedInterleavedBuffer = !0;\n    class bh {\n      constructor(t, e, n, i, r) {\n        (this.buffer = t),\n          (this.type = e),\n          (this.itemSize = n),\n          (this.elementSize = i),\n          (this.count = r),\n          (this.version = 0);\n      }\n      set needsUpdate(t) {\n        !0 === t && this.version++;\n      }\n      setBuffer(t) {\n        return (this.buffer = t), this;\n      }\n      setType(t, e) {\n        return (this.type = t), (this.elementSize = e), this;\n      }\n      setItemSize(t) {\n        return (this.itemSize = t), this;\n      }\n      setCount(t) {\n        return (this.count = t), this;\n      }\n    }\n    bh.prototype.isGLBufferAttribute = !0;\n    function wh(t, e) {\n      return t.distance - e.distance;\n    }\n    function Sh(t, e, n, i) {\n      if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {\n        const i = t.children;\n        for (let t = 0, r = i.length; t < r; t++) Sh(i[t], e, n, !0);\n      }\n    }\n    const Th = new yt();\n    class Eh {\n      constructor(t = new yt(1 / 0, 1 / 0), e = new yt(-1 / 0, -1 / 0)) {\n        (this.min = t), (this.max = e);\n      }\n      set(t, e) {\n        return this.min.copy(t), this.max.copy(e), this;\n      }\n      setFromPoints(t) {\n        this.makeEmpty();\n        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);\n        return this;\n      }\n      setFromCenterAndSize(t, e) {\n        const n = Th.copy(e).multiplyScalar(0.5);\n        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n      copy(t) {\n        return this.min.copy(t.min), this.max.copy(t.max), this;\n      }\n      makeEmpty() {\n        return (\n          (this.min.x = this.min.y = 1 / 0),\n          (this.max.x = this.max.y = -1 / 0),\n          this\n        );\n      }\n      isEmpty() {\n        return this.max.x < this.min.x || this.max.y < this.min.y;\n      }\n      getCenter(t) {\n        return this.isEmpty()\n          ? t.set(0, 0)\n          : t.addVectors(this.min, this.max).multiplyScalar(0.5);\n      }\n      getSize(t) {\n        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);\n      }\n      expandByPoint(t) {\n        return this.min.min(t), this.max.max(t), this;\n      }\n      expandByVector(t) {\n        return this.min.sub(t), this.max.add(t), this;\n      }\n      expandByScalar(t) {\n        return this.min.addScalar(-t), this.max.addScalar(t), this;\n      }\n      containsPoint(t) {\n        return !(\n          t.x < this.min.x ||\n          t.x > this.max.x ||\n          t.y < this.min.y ||\n          t.y > this.max.y\n        );\n      }\n      containsBox(t) {\n        return (\n          this.min.x <= t.min.x &&\n          t.max.x <= this.max.x &&\n          this.min.y <= t.min.y &&\n          t.max.y <= this.max.y\n        );\n      }\n      getParameter(t, e) {\n        return e.set(\n          (t.x - this.min.x) / (this.max.x - this.min.x),\n          (t.y - this.min.y) / (this.max.y - this.min.y)\n        );\n      }\n      intersectsBox(t) {\n        return !(\n          t.max.x < this.min.x ||\n          t.min.x > this.max.x ||\n          t.max.y < this.min.y ||\n          t.min.y > this.max.y\n        );\n      }\n      clampPoint(t, e) {\n        return e.copy(t).clamp(this.min, this.max);\n      }\n      distanceToPoint(t) {\n        return Th.copy(t).clamp(this.min, this.max).sub(t).length();\n      }\n      intersect(t) {\n        return this.min.max(t.min), this.max.min(t.max), this;\n      }\n      union(t) {\n        return this.min.min(t.min), this.max.max(t.max), this;\n      }\n      translate(t) {\n        return this.min.add(t), this.max.add(t), this;\n      }\n      equals(t) {\n        return t.min.equals(this.min) && t.max.equals(this.max);\n      }\n    }\n    Eh.prototype.isBox2 = !0;\n    const Ah = new zt(),\n      Lh = new zt();\n    class Rh {\n      constructor(t = new zt(), e = new zt()) {\n        (this.start = t), (this.end = e);\n      }\n      set(t, e) {\n        return this.start.copy(t), this.end.copy(e), this;\n      }\n      copy(t) {\n        return this.start.copy(t.start), this.end.copy(t.end), this;\n      }\n      getCenter(t) {\n        return t.addVectors(this.start, this.end).multiplyScalar(0.5);\n      }\n      delta(t) {\n        return t.subVectors(this.end, this.start);\n      }\n      distanceSq() {\n        return this.start.distanceToSquared(this.end);\n      }\n      distance() {\n        return this.start.distanceTo(this.end);\n      }\n      at(t, e) {\n        return this.delta(e).multiplyScalar(t).add(this.start);\n      }\n      closestPointToPointParameter(t, e) {\n        Ah.subVectors(t, this.start), Lh.subVectors(this.end, this.start);\n        const n = Lh.dot(Lh);\n        let i = Lh.dot(Ah) / n;\n        return e && (i = ut(i, 0, 1)), i;\n      }\n      closestPointToPoint(t, e, n) {\n        const i = this.closestPointToPointParameter(t, e);\n        return this.delta(n).multiplyScalar(i).add(this.start);\n      }\n      applyMatrix4(t) {\n        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;\n      }\n      equals(t) {\n        return t.start.equals(this.start) && t.end.equals(this.end);\n      }\n      clone() {\n        return new this.constructor().copy(this);\n      }\n    }\n    const Ch = new zt();\n    const Ph = new zt(),\n      Ih = new de(),\n      Dh = new de();\n    class Nh extends Za {\n      constructor(t) {\n        const e = zh(t),\n          n = new En(),\n          i = [],\n          r = [],\n          s = new rn(0, 0, 1),\n          a = new rn(0, 1, 0);\n        for (let t = 0; t < e.length; t++) {\n          const n = e[t];\n          n.parent &&\n            n.parent.isBone &&\n            (i.push(0, 0, 0),\n            i.push(0, 0, 0),\n            r.push(s.r, s.g, s.b),\n            r.push(a.r, a.g, a.b));\n        }\n        n.setAttribute(\"position\", new vn(i, 3)),\n          n.setAttribute(\"color\", new vn(r, 3));\n        super(\n          n,\n          new Ga({\n            vertexColors: !0,\n            depthTest: !1,\n            depthWrite: !1,\n            toneMapped: !1,\n            transparent: !0,\n          })\n        ),\n          (this.type = \"SkeletonHelper\"),\n          (this.isSkeletonHelper = !0),\n          (this.root = t),\n          (this.bones = e),\n          (this.matrix = t.matrixWorld),\n          (this.matrixAutoUpdate = !1);\n      }\n      updateMatrixWorld(t) {\n        const e = this.bones,\n          n = this.geometry,\n          i = n.getAttribute(\"position\");\n        Dh.copy(this.root.matrixWorld).invert();\n        for (let t = 0, n = 0; t < e.length; t++) {\n          const r = e[t];\n          r.parent &&\n            r.parent.isBone &&\n            (Ih.multiplyMatrices(Dh, r.matrixWorld),\n            Ph.setFromMatrixPosition(Ih),\n            i.setXYZ(n, Ph.x, Ph.y, Ph.z),\n            Ih.multiplyMatrices(Dh, r.parent.matrixWorld),\n            Ph.setFromMatrixPosition(Ih),\n            i.setXYZ(n + 1, Ph.x, Ph.y, Ph.z),\n            (n += 2));\n        }\n        (n.getAttribute(\"position\").needsUpdate = !0),\n          super.updateMatrixWorld(t);\n      }\n    }\n    function zh(t) {\n      const e = [];\n      t && t.isBone && e.push(t);\n      for (let n = 0; n < t.children.length; n++)\n        e.push.apply(e, zh(t.children[n]));\n      return e;\n    }\n    const Bh = new zt(),\n      Fh = new rn(),\n      Oh = new rn();\n    class Uh extends Za {\n      constructor(t = 10, e = 10, n = 4473924, i = 8947848) {\n        (n = new rn(n)), (i = new rn(i));\n        const r = e / 2,\n          s = t / e,\n          a = t / 2,\n          o = [],\n          l = [];\n        for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {\n          o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);\n          const e = t === r ? n : i;\n          e.toArray(l, c),\n            (c += 3),\n            e.toArray(l, c),\n            (c += 3),\n            e.toArray(l, c),\n            (c += 3),\n            e.toArray(l, c),\n            (c += 3);\n        }\n        const c = new En();\n        c.setAttribute(\"position\", new vn(o, 3)),\n          c.setAttribute(\"color\", new vn(l, 3));\n        super(c, new Ga({ vertexColors: !0, toneMapped: !1 })),\n          (this.type = \"GridHelper\");\n      }\n    }\n    const Hh = new zt(),\n      Gh = new zt(),\n      kh = new zt();\n    const Vh = new zt(),\n      Wh = new Qn();\n    function jh(t, e, n, i, r, s, a) {\n      Vh.set(r, s, a).unproject(i);\n      const o = e[t];\n      if (void 0 !== o) {\n        const t = n.getAttribute(\"position\");\n        for (let e = 0, n = o.length; e < n; e++)\n          t.setXYZ(o[e], Vh.x, Vh.y, Vh.z);\n      }\n    }\n    const qh = new Ot();\n    class Xh extends Za {\n      constructor(t, e = 16776960) {\n        const n = new Uint16Array([\n            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,\n            7,\n          ]),\n          i = new Float32Array(24),\n          r = new En();\n        r.setIndex(new ln(n, 1)),\n          r.setAttribute(\"position\", new ln(i, 3)),\n          super(r, new Ga({ color: e, toneMapped: !1 })),\n          (this.object = t),\n          (this.type = \"BoxHelper\"),\n          (this.matrixAutoUpdate = !1),\n          this.update();\n      }\n      update(t) {\n        if (\n          (void 0 !== t &&\n            console.warn(\"THREE.BoxHelper: .update() has no longer arguments.\"),\n          void 0 !== this.object && qh.setFromObject(this.object),\n          qh.isEmpty())\n        )\n          return;\n        const e = qh.min,\n          n = qh.max,\n          i = this.geometry.attributes.position,\n          r = i.array;\n        (r[0] = n.x),\n          (r[1] = n.y),\n          (r[2] = n.z),\n          (r[3] = e.x),\n          (r[4] = n.y),\n          (r[5] = n.z),\n          (r[6] = e.x),\n          (r[7] = e.y),\n          (r[8] = n.z),\n          (r[9] = n.x),\n          (r[10] = e.y),\n          (r[11] = n.z),\n          (r[12] = n.x),\n          (r[13] = n.y),\n          (r[14] = e.z),\n          (r[15] = e.x),\n          (r[16] = n.y),\n          (r[17] = e.z),\n          (r[18] = e.x),\n          (r[19] = e.y),\n          (r[20] = e.z),\n          (r[21] = n.x),\n          (r[22] = e.y),\n          (r[23] = e.z),\n          (i.needsUpdate = !0),\n          this.geometry.computeBoundingSphere();\n      }\n      setFromObject(t) {\n        return (this.object = t), this.update(), this;\n      }\n      copy(t) {\n        return Za.prototype.copy.call(this, t), (this.object = t.object), this;\n      }\n    }\n    const Yh = new zt();\n    let Jh, Zh;\n    class Qh extends Za {\n      constructor(t = 1) {\n        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],\n          n = new En();\n        n.setAttribute(\"position\", new vn(e, 3)),\n          n.setAttribute(\n            \"color\",\n            new vn(\n              [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],\n              3\n            )\n          );\n        super(n, new Ga({ vertexColors: !0, toneMapped: !1 })),\n          (this.type = \"AxesHelper\");\n      }\n      setColors(t, e, n) {\n        const i = new rn(),\n          r = this.geometry.attributes.color.array;\n        return (\n          i.set(t),\n          i.toArray(r, 0),\n          i.toArray(r, 3),\n          i.set(e),\n          i.toArray(r, 6),\n          i.toArray(r, 9),\n          i.set(n),\n          i.toArray(r, 12),\n          i.toArray(r, 15),\n          (this.geometry.attributes.color.needsUpdate = !0),\n          this\n        );\n      }\n      dispose() {\n        this.geometry.dispose(), this.material.dispose();\n      }\n    }\n    const Kh = new Float32Array(1),\n      $h = new Int32Array(Kh.buffer);\n    (_o.create = function (t, e) {\n      return (\n        console.log(\"THREE.Curve.create() has been deprecated\"),\n        (t.prototype = Object.create(_o.prototype)),\n        (t.prototype.constructor = t),\n        (t.prototype.getPoint = e),\n        t\n      );\n    }),\n      (Go.prototype.fromPoints = function (t) {\n        return (\n          console.warn(\n            \"THREE.Path: .fromPoints() has been renamed to .setFromPoints().\"\n          ),\n          this.setFromPoints(t)\n        );\n      }),\n      (Uh.prototype.setColors = function () {\n        console.error(\n          \"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.\"\n        );\n      }),\n      (Nh.prototype.update = function () {\n        console.error(\n          \"THREE.SkeletonHelper: update() no longer needs to be called.\"\n        );\n      }),\n      (ac.prototype.extractUrlBase = function (t) {\n        return (\n          console.warn(\n            \"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.\"\n          ),\n          Dc.extractUrlBase(t)\n        );\n      }),\n      (ac.Handlers = {\n        add: function () {\n          console.error(\n            \"THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.\"\n          );\n        },\n        get: function () {\n          console.error(\n            \"THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.\"\n          );\n        },\n      }),\n      (Eh.prototype.center = function (t) {\n        return (\n          console.warn(\n            \"THREE.Box2: .center() has been renamed to .getCenter().\"\n          ),\n          this.getCenter(t)\n        );\n      }),\n      (Eh.prototype.empty = function () {\n        return (\n          console.warn(\"THREE.Box2: .empty() has been renamed to .isEmpty().\"),\n          this.isEmpty()\n        );\n      }),\n      (Eh.prototype.isIntersectionBox = function (t) {\n        return (\n          console.warn(\n            \"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().\"\n          ),\n          this.intersectsBox(t)\n        );\n      }),\n      (Eh.prototype.size = function (t) {\n        return (\n          console.warn(\"THREE.Box2: .size() has been renamed to .getSize().\"),\n          this.getSize(t)\n        );\n      }),\n      (Ot.prototype.center = function (t) {\n        return (\n          console.warn(\n            \"THREE.Box3: .center() has been renamed to .getCenter().\"\n          ),\n          this.getCenter(t)\n        );\n      }),\n      (Ot.prototype.empty = function () {\n        return (\n          console.warn(\"THREE.Box3: .empty() has been renamed to .isEmpty().\"),\n          this.isEmpty()\n        );\n      }),\n      (Ot.prototype.isIntersectionBox = function (t) {\n        return (\n          console.warn(\n            \"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().\"\n          ),\n          this.intersectsBox(t)\n        );\n      }),\n      (Ot.prototype.isIntersectionSphere = function (t) {\n        return (\n          console.warn(\n            \"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().\"\n          ),\n          this.intersectsSphere(t)\n        );\n      }),\n      (Ot.prototype.size = function (t) {\n        return (\n          console.warn(\"THREE.Box3: .size() has been renamed to .getSize().\"),\n          this.getSize(t)\n        );\n      }),\n      (ie.prototype.empty = function () {\n        return (\n          console.warn(\n            \"THREE.Sphere: .empty() has been renamed to .isEmpty().\"\n          ),\n          this.isEmpty()\n        );\n      }),\n      (ci.prototype.setFromMatrix = function (t) {\n        return (\n          console.warn(\n            \"THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().\"\n          ),\n          this.setFromProjectionMatrix(t)\n        );\n      }),\n      (Rh.prototype.center = function (t) {\n        return (\n          console.warn(\n            \"THREE.Line3: .center() has been renamed to .getCenter().\"\n          ),\n          this.getCenter(t)\n        );\n      }),\n      (xt.prototype.flattenToArrayOffset = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\"\n          ),\n          this.toArray(t, e)\n        );\n      }),\n      (xt.prototype.multiplyVector3 = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\"\n          ),\n          t.applyMatrix3(this)\n        );\n      }),\n      (xt.prototype.multiplyVector3Array = function () {\n        console.error(\n          \"THREE.Matrix3: .multiplyVector3Array() has been removed.\"\n        );\n      }),\n      (xt.prototype.applyToBufferAttribute = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.\"\n          ),\n          t.applyMatrix3(this)\n        );\n      }),\n      (xt.prototype.applyToVector3Array = function () {\n        console.error(\n          \"THREE.Matrix3: .applyToVector3Array() has been removed.\"\n        );\n      }),\n      (xt.prototype.getInverse = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.\"\n          ),\n          this.copy(t).invert()\n        );\n      }),\n      (de.prototype.extractPosition = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().\"\n          ),\n          this.copyPosition(t)\n        );\n      }),\n      (de.prototype.flattenToArrayOffset = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\"\n          ),\n          this.toArray(t, e)\n        );\n      }),\n      (de.prototype.getPosition = function () {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\"\n          ),\n          new zt().setFromMatrixColumn(this, 3)\n        );\n      }),\n      (de.prototype.setRotationFromQuaternion = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().\"\n          ),\n          this.makeRotationFromQuaternion(t)\n        );\n      }),\n      (de.prototype.multiplyToArray = function () {\n        console.warn(\"THREE.Matrix4: .multiplyToArray() has been removed.\");\n      }),\n      (de.prototype.multiplyVector3 = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.\"\n          ),\n          t.applyMatrix4(this)\n        );\n      }),\n      (de.prototype.multiplyVector4 = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\"\n          ),\n          t.applyMatrix4(this)\n        );\n      }),\n      (de.prototype.multiplyVector3Array = function () {\n        console.error(\n          \"THREE.Matrix4: .multiplyVector3Array() has been removed.\"\n        );\n      }),\n      (de.prototype.rotateAxis = function (t) {\n        console.warn(\n          \"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\"\n        ),\n          t.transformDirection(this);\n      }),\n      (de.prototype.crossVector = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\"\n          ),\n          t.applyMatrix4(this)\n        );\n      }),\n      (de.prototype.translate = function () {\n        console.error(\"THREE.Matrix4: .translate() has been removed.\");\n      }),\n      (de.prototype.rotateX = function () {\n        console.error(\"THREE.Matrix4: .rotateX() has been removed.\");\n      }),\n      (de.prototype.rotateY = function () {\n        console.error(\"THREE.Matrix4: .rotateY() has been removed.\");\n      }),\n      (de.prototype.rotateZ = function () {\n        console.error(\"THREE.Matrix4: .rotateZ() has been removed.\");\n      }),\n      (de.prototype.rotateByAxis = function () {\n        console.error(\"THREE.Matrix4: .rotateByAxis() has been removed.\");\n      }),\n      (de.prototype.applyToBufferAttribute = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.\"\n          ),\n          t.applyMatrix4(this)\n        );\n      }),\n      (de.prototype.applyToVector3Array = function () {\n        console.error(\n          \"THREE.Matrix4: .applyToVector3Array() has been removed.\"\n        );\n      }),\n      (de.prototype.makeFrustum = function (t, e, n, i, r, s) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.\"\n          ),\n          this.makePerspective(t, e, i, n, r, s)\n        );\n      }),\n      (de.prototype.getInverse = function (t) {\n        return (\n          console.warn(\n            \"THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.\"\n          ),\n          this.copy(t).invert()\n        );\n      }),\n      (ai.prototype.isIntersectionLine = function (t) {\n        return (\n          console.warn(\n            \"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().\"\n          ),\n          this.intersectsLine(t)\n        );\n      }),\n      (Nt.prototype.multiplyVector3 = function (t) {\n        return (\n          console.warn(\n            \"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\"\n          ),\n          t.applyQuaternion(this)\n        );\n      }),\n      (Nt.prototype.inverse = function () {\n        return (\n          console.warn(\n            \"THREE.Quaternion: .inverse() has been renamed to invert().\"\n          ),\n          this.invert()\n        );\n      }),\n      (ue.prototype.isIntersectionBox = function (t) {\n        return (\n          console.warn(\n            \"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().\"\n          ),\n          this.intersectsBox(t)\n        );\n      }),\n      (ue.prototype.isIntersectionPlane = function (t) {\n        return (\n          console.warn(\n            \"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().\"\n          ),\n          this.intersectsPlane(t)\n        );\n      }),\n      (ue.prototype.isIntersectionSphere = function (t) {\n        return (\n          console.warn(\n            \"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().\"\n          ),\n          this.intersectsSphere(t)\n        );\n      }),\n      (Ye.prototype.area = function () {\n        return (\n          console.warn(\n            \"THREE.Triangle: .area() has been renamed to .getArea().\"\n          ),\n          this.getArea()\n        );\n      }),\n      (Ye.prototype.barycoordFromPoint = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\"\n          ),\n          this.getBarycoord(t, e)\n        );\n      }),\n      (Ye.prototype.midpoint = function (t) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .midpoint() has been renamed to .getMidpoint().\"\n          ),\n          this.getMidpoint(t)\n        );\n      }),\n      (Ye.prototypenormal = function (t) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .normal() has been renamed to .getNormal().\"\n          ),\n          this.getNormal(t)\n        );\n      }),\n      (Ye.prototype.plane = function (t) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .plane() has been renamed to .getPlane().\"\n          ),\n          this.getPlane(t)\n        );\n      }),\n      (Ye.barycoordFromPoint = function (t, e, n, i, r) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\"\n          ),\n          Ye.getBarycoord(t, e, n, i, r)\n        );\n      }),\n      (Ye.normal = function (t, e, n, i) {\n        return (\n          console.warn(\n            \"THREE.Triangle: .normal() has been renamed to .getNormal().\"\n          ),\n          Ye.getNormal(t, e, n, i)\n        );\n      }),\n      (ko.prototype.extractAllPoints = function (t) {\n        return (\n          console.warn(\n            \"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.\"\n          ),\n          this.extractPoints(t)\n        );\n      }),\n      (ko.prototype.extrude = function (t) {\n        return (\n          console.warn(\n            \"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.\"\n          ),\n          new vl(this, t)\n        );\n      }),\n      (ko.prototype.makeGeometry = function (t) {\n        return (\n          console.warn(\n            \"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.\"\n          ),\n          new wl(this, t)\n        );\n      }),\n      (yt.prototype.fromAttribute = function (t, e, n) {\n        return (\n          console.warn(\n            \"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().\"\n          ),\n          this.fromBufferAttribute(t, e, n)\n        );\n      }),\n      (yt.prototype.distanceToManhattan = function (t) {\n        return (\n          console.warn(\n            \"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\"\n          ),\n          this.manhattanDistanceTo(t)\n        );\n      }),\n      (yt.prototype.lengthManhattan = function () {\n        return (\n          console.warn(\n            \"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().\"\n          ),\n          this.manhattanLength()\n        );\n      }),\n      (zt.prototype.setEulerFromRotationMatrix = function () {\n        console.error(\n          \"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.\"\n        );\n      }),\n      (zt.prototype.setEulerFromQuaternion = function () {\n        console.error(\n          \"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.\"\n        );\n      }),\n      (zt.prototype.getPositionFromMatrix = function (t) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().\"\n          ),\n          this.setFromMatrixPosition(t)\n        );\n      }),\n      (zt.prototype.getScaleFromMatrix = function (t) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().\"\n          ),\n          this.setFromMatrixScale(t)\n        );\n      }),\n      (zt.prototype.getColumnFromMatrix = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().\"\n          ),\n          this.setFromMatrixColumn(e, t)\n        );\n      }),\n      (zt.prototype.applyProjection = function (t) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.\"\n          ),\n          this.applyMatrix4(t)\n        );\n      }),\n      (zt.prototype.fromAttribute = function (t, e, n) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().\"\n          ),\n          this.fromBufferAttribute(t, e, n)\n        );\n      }),\n      (zt.prototype.distanceToManhattan = function (t) {\n        return (\n          console.warn(\n            \"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\"\n          ),\n          this.manhattanDistanceTo(t)\n        );\n      }),\n      (zt.prototype.lengthManhattan = function () {\n        return (\n          console.warn(\n            \"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().\"\n          ),\n          this.manhattanLength()\n        );\n      }),\n      (Ct.prototype.fromAttribute = function (t, e, n) {\n        return (\n          console.warn(\n            \"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().\"\n          ),\n          this.fromBufferAttribute(t, e, n)\n        );\n      }),\n      (Ct.prototype.lengthManhattan = function () {\n        return (\n          console.warn(\n            \"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().\"\n          ),\n          this.manhattanLength()\n        );\n      }),\n      (Fe.prototype.getChildByName = function (t) {\n        return (\n          console.warn(\n            \"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().\"\n          ),\n          this.getObjectByName(t)\n        );\n      }),\n      (Fe.prototype.renderDepth = function () {\n        console.warn(\n          \"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.\"\n        );\n      }),\n      (Fe.prototype.translate = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.\"\n          ),\n          this.translateOnAxis(e, t)\n        );\n      }),\n      (Fe.prototype.getWorldRotation = function () {\n        console.error(\n          \"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.\"\n        );\n      }),\n      (Fe.prototype.applyMatrix = function (t) {\n        return (\n          console.warn(\n            \"THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().\"\n          ),\n          this.applyMatrix4(t)\n        );\n      }),\n      Object.defineProperties(Fe.prototype, {\n        eulerOrder: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.Object3D: .eulerOrder is now .rotation.order.\"\n              ),\n              this.rotation.order\n            );\n          },\n          set: function (t) {\n            console.warn(\"THREE.Object3D: .eulerOrder is now .rotation.order.\"),\n              (this.rotation.order = t);\n          },\n        },\n        useQuaternion: {\n          get: function () {\n            console.warn(\n              \"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\"\n            );\n          },\n        },\n      }),\n      (Wn.prototype.setDrawMode = function () {\n        console.error(\n          \"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.\"\n        );\n      }),\n      Object.defineProperties(Wn.prototype, {\n        drawMode: {\n          get: function () {\n            return (\n              console.error(\n                \"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.\"\n              ),\n              0\n            );\n          },\n          set: function () {\n            console.error(\n              \"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.\"\n            );\n          },\n        },\n      }),\n      (Ra.prototype.initBones = function () {\n        console.error(\"THREE.SkinnedMesh: initBones() has been removed.\");\n      }),\n      (Kn.prototype.setLens = function (t, e) {\n        console.warn(\n          \"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.\"\n        ),\n          void 0 !== e && (this.filmGauge = e),\n          this.setFocalLength(t);\n      }),\n      Object.defineProperties(pc.prototype, {\n        onlyShadow: {\n          set: function () {\n            console.warn(\"THREE.Light: .onlyShadow has been removed.\");\n          },\n        },\n        shadowCameraFov: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraFov is now .shadow.camera.fov.\"\n            ),\n              (this.shadow.camera.fov = t);\n          },\n        },\n        shadowCameraLeft: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraLeft is now .shadow.camera.left.\"\n            ),\n              (this.shadow.camera.left = t);\n          },\n        },\n        shadowCameraRight: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraRight is now .shadow.camera.right.\"\n            ),\n              (this.shadow.camera.right = t);\n          },\n        },\n        shadowCameraTop: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraTop is now .shadow.camera.top.\"\n            ),\n              (this.shadow.camera.top = t);\n          },\n        },\n        shadowCameraBottom: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.\"\n            ),\n              (this.shadow.camera.bottom = t);\n          },\n        },\n        shadowCameraNear: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraNear is now .shadow.camera.near.\"\n            ),\n              (this.shadow.camera.near = t);\n          },\n        },\n        shadowCameraFar: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowCameraFar is now .shadow.camera.far.\"\n            ),\n              (this.shadow.camera.far = t);\n          },\n        },\n        shadowCameraVisible: {\n          set: function () {\n            console.warn(\n              \"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.\"\n            );\n          },\n        },\n        shadowBias: {\n          set: function (t) {\n            console.warn(\"THREE.Light: .shadowBias is now .shadow.bias.\"),\n              (this.shadow.bias = t);\n          },\n        },\n        shadowDarkness: {\n          set: function () {\n            console.warn(\"THREE.Light: .shadowDarkness has been removed.\");\n          },\n        },\n        shadowMapWidth: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.\"\n            ),\n              (this.shadow.mapSize.width = t);\n          },\n        },\n        shadowMapHeight: {\n          set: function (t) {\n            console.warn(\n              \"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.\"\n            ),\n              (this.shadow.mapSize.height = t);\n          },\n        },\n      }),\n      Object.defineProperties(ln.prototype, {\n        length: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.BufferAttribute: .length has been deprecated. Use .count instead.\"\n              ),\n              this.array.length\n            );\n          },\n        },\n        dynamic: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.\"\n              ),\n              this.usage === nt\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.\"\n            ),\n              this.setUsage(nt);\n          },\n        },\n      }),\n      (ln.prototype.setDynamic = function (t) {\n        return (\n          console.warn(\n            \"THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.\"\n          ),\n          this.setUsage(!0 === t ? nt : et),\n          this\n        );\n      }),\n      (ln.prototype.copyIndicesArray = function () {\n        console.error(\n          \"THREE.BufferAttribute: .copyIndicesArray() has been removed.\"\n        );\n      }),\n      (ln.prototype.setArray = function () {\n        console.error(\n          \"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers\"\n        );\n      }),\n      (En.prototype.addIndex = function (t) {\n        console.warn(\n          \"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().\"\n        ),\n          this.setIndex(t);\n      }),\n      (En.prototype.addAttribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().\"\n          ),\n          (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)\n            ? \"index\" === t\n              ? (console.warn(\n                  \"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.\"\n                ),\n                this.setIndex(e),\n                this)\n              : this.setAttribute(t, e)\n            : (console.warn(\n                \"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\"\n              ),\n              this.setAttribute(t, new ln(arguments[1], arguments[2])))\n        );\n      }),\n      (En.prototype.addDrawCall = function (t, e, n) {\n        void 0 !== n &&\n          console.warn(\n            \"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.\"\n          ),\n          console.warn(\n            \"THREE.BufferGeometry: .addDrawCall() is now .addGroup().\"\n          ),\n          this.addGroup(t, e);\n      }),\n      (En.prototype.clearDrawCalls = function () {\n        console.warn(\n          \"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().\"\n        ),\n          this.clearGroups();\n      }),\n      (En.prototype.computeOffsets = function () {\n        console.warn(\n          \"THREE.BufferGeometry: .computeOffsets() has been removed.\"\n        );\n      }),\n      (En.prototype.removeAttribute = function (t) {\n        return (\n          console.warn(\n            \"THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().\"\n          ),\n          this.deleteAttribute(t)\n        );\n      }),\n      (En.prototype.applyMatrix = function (t) {\n        return (\n          console.warn(\n            \"THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().\"\n          ),\n          this.applyMatrix4(t)\n        );\n      }),\n      Object.defineProperties(En.prototype, {\n        drawcalls: {\n          get: function () {\n            return (\n              console.error(\n                \"THREE.BufferGeometry: .drawcalls has been renamed to .groups.\"\n              ),\n              this.groups\n            );\n          },\n        },\n        offsets: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.BufferGeometry: .offsets has been renamed to .groups.\"\n              ),\n              this.groups\n            );\n          },\n        },\n      }),\n      (na.prototype.setDynamic = function (t) {\n        return (\n          console.warn(\n            \"THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.\"\n          ),\n          this.setUsage(!0 === t ? nt : et),\n          this\n        );\n      }),\n      (na.prototype.setArray = function () {\n        console.error(\n          \"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers\"\n        );\n      }),\n      (vl.prototype.getArrays = function () {\n        console.error(\"THREE.ExtrudeGeometry: .getArrays() has been removed.\");\n      }),\n      (vl.prototype.addShapeList = function () {\n        console.error(\n          \"THREE.ExtrudeGeometry: .addShapeList() has been removed.\"\n        );\n      }),\n      (vl.prototype.addShape = function () {\n        console.error(\"THREE.ExtrudeGeometry: .addShape() has been removed.\");\n      }),\n      (ea.prototype.dispose = function () {\n        console.error(\"THREE.Scene: .dispose() has been removed.\");\n      }),\n      (_h.prototype.onUpdate = function () {\n        return (\n          console.warn(\n            \"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.\"\n          ),\n          this\n        );\n      }),\n      Object.defineProperties(Ze.prototype, {\n        wrapAround: {\n          get: function () {\n            console.warn(\"THREE.Material: .wrapAround has been removed.\");\n          },\n          set: function () {\n            console.warn(\"THREE.Material: .wrapAround has been removed.\");\n          },\n        },\n        overdraw: {\n          get: function () {\n            console.warn(\"THREE.Material: .overdraw has been removed.\");\n          },\n          set: function () {\n            console.warn(\"THREE.Material: .overdraw has been removed.\");\n          },\n        },\n        wrapRGB: {\n          get: function () {\n            return (\n              console.warn(\"THREE.Material: .wrapRGB has been removed.\"),\n              new rn()\n            );\n          },\n        },\n        shading: {\n          get: function () {\n            console.error(\n              \"THREE.\" +\n                this.type +\n                \": .shading has been removed. Use the boolean .flatShading instead.\"\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.\" +\n                this.type +\n                \": .shading has been removed. Use the boolean .flatShading instead.\"\n            ),\n              (this.flatShading = 1 === t);\n          },\n        },\n        stencilMask: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.\" +\n                  this.type +\n                  \": .stencilMask has been removed. Use .stencilFuncMask instead.\"\n              ),\n              this.stencilFuncMask\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.\" +\n                this.type +\n                \": .stencilMask has been removed. Use .stencilFuncMask instead.\"\n            ),\n              (this.stencilFuncMask = t);\n          },\n        },\n        vertexTangents: {\n          get: function () {\n            console.warn(\n              \"THREE.\" + this.type + \": .vertexTangents has been removed.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.\" + this.type + \": .vertexTangents has been removed.\"\n            );\n          },\n        },\n      }),\n      Object.defineProperties(Zn.prototype, {\n        derivatives: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\"\n              ),\n              this.extensions.derivatives\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\"\n            ),\n              (this.extensions.derivatives = t);\n          },\n        },\n      }),\n      (Qs.prototype.clearTarget = function (t, e, n, i) {\n        console.warn(\n          \"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.\"\n        ),\n          this.setRenderTarget(t),\n          this.clear(e, n, i);\n      }),\n      (Qs.prototype.animate = function (t) {\n        console.warn(\n          \"THREE.WebGLRenderer: .animate() is now .setAnimationLoop().\"\n        ),\n          this.setAnimationLoop(t);\n      }),\n      (Qs.prototype.getCurrentRenderTarget = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().\"\n          ),\n          this.getRenderTarget()\n        );\n      }),\n      (Qs.prototype.getMaxAnisotropy = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().\"\n          ),\n          this.capabilities.getMaxAnisotropy()\n        );\n      }),\n      (Qs.prototype.getPrecision = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.\"\n          ),\n          this.capabilities.precision\n        );\n      }),\n      (Qs.prototype.resetGLState = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .resetGLState() is now .state.reset().\"\n          ),\n          this.state.reset()\n        );\n      }),\n      (Qs.prototype.supportsFloatTextures = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).\"\n          ),\n          this.extensions.get(\"OES_texture_float\")\n        );\n      }),\n      (Qs.prototype.supportsHalfFloatTextures = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).\"\n          ),\n          this.extensions.get(\"OES_texture_half_float\")\n        );\n      }),\n      (Qs.prototype.supportsStandardDerivatives = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).\"\n          ),\n          this.extensions.get(\"OES_standard_derivatives\")\n        );\n      }),\n      (Qs.prototype.supportsCompressedTextureS3TC = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).\"\n          ),\n          this.extensions.get(\"WEBGL_compressed_texture_s3tc\")\n        );\n      }),\n      (Qs.prototype.supportsCompressedTexturePVRTC = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).\"\n          ),\n          this.extensions.get(\"WEBGL_compressed_texture_pvrtc\")\n        );\n      }),\n      (Qs.prototype.supportsBlendMinMax = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).\"\n          ),\n          this.extensions.get(\"EXT_blend_minmax\")\n        );\n      }),\n      (Qs.prototype.supportsVertexTextures = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.\"\n          ),\n          this.capabilities.vertexTextures\n        );\n      }),\n      (Qs.prototype.supportsInstancedArrays = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).\"\n          ),\n          this.extensions.get(\"ANGLE_instanced_arrays\")\n        );\n      }),\n      (Qs.prototype.enableScissorTest = function (t) {\n        console.warn(\n          \"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().\"\n        ),\n          this.setScissorTest(t);\n      }),\n      (Qs.prototype.initMaterial = function () {\n        console.warn(\"THREE.WebGLRenderer: .initMaterial() has been removed.\");\n      }),\n      (Qs.prototype.addPrePlugin = function () {\n        console.warn(\"THREE.WebGLRenderer: .addPrePlugin() has been removed.\");\n      }),\n      (Qs.prototype.addPostPlugin = function () {\n        console.warn(\"THREE.WebGLRenderer: .addPostPlugin() has been removed.\");\n      }),\n      (Qs.prototype.updateShadowMap = function () {\n        console.warn(\n          \"THREE.WebGLRenderer: .updateShadowMap() has been removed.\"\n        );\n      }),\n      (Qs.prototype.setFaceCulling = function () {\n        console.warn(\n          \"THREE.WebGLRenderer: .setFaceCulling() has been removed.\"\n        );\n      }),\n      (Qs.prototype.allocTextureUnit = function () {\n        console.warn(\n          \"THREE.WebGLRenderer: .allocTextureUnit() has been removed.\"\n        );\n      }),\n      (Qs.prototype.setTexture = function () {\n        console.warn(\"THREE.WebGLRenderer: .setTexture() has been removed.\");\n      }),\n      (Qs.prototype.setTexture2D = function () {\n        console.warn(\"THREE.WebGLRenderer: .setTexture2D() has been removed.\");\n      }),\n      (Qs.prototype.setTextureCube = function () {\n        console.warn(\n          \"THREE.WebGLRenderer: .setTextureCube() has been removed.\"\n        );\n      }),\n      (Qs.prototype.getActiveMipMapLevel = function () {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().\"\n          ),\n          this.getActiveMipmapLevel()\n        );\n      }),\n      Object.defineProperties(Qs.prototype, {\n        shadowMapEnabled: {\n          get: function () {\n            return this.shadowMap.enabled;\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.\"\n            ),\n              (this.shadowMap.enabled = t);\n          },\n        },\n        shadowMapType: {\n          get: function () {\n            return this.shadowMap.type;\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.\"\n            ),\n              (this.shadowMap.type = t);\n          },\n        },\n        shadowMapCullFace: {\n          get: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n        },\n        context: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.\"\n              ),\n              this.getContext()\n            );\n          },\n        },\n        vr: {\n          get: function () {\n            return (\n              console.warn(\"THREE.WebGLRenderer: .vr has been renamed to .xr\"),\n              this.xr\n            );\n          },\n        },\n        gammaInput: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.\"\n              ),\n              !1\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.\"\n            );\n          },\n        },\n        gammaOutput: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.\"\n              ),\n              !1\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.\"\n            ),\n              (this.outputEncoding = !0 === t ? Y : X);\n          },\n        },\n        toneMappingWhitePoint: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.\"\n              ),\n              1\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.\"\n            );\n          },\n        },\n      }),\n      Object.defineProperties(Gs.prototype, {\n        cullFace: {\n          get: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n        },\n        renderReverseSided: {\n          get: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n        },\n        renderSingleSided: {\n          get: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n          set: function () {\n            console.warn(\n              \"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\"\n            );\n          },\n        },\n      }),\n      Object.defineProperties(Pt.prototype, {\n        wrapS: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\"\n              ),\n              this.texture.wrapS\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\"\n            ),\n              (this.texture.wrapS = t);\n          },\n        },\n        wrapT: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\"\n              ),\n              this.texture.wrapT\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\"\n            ),\n              (this.texture.wrapT = t);\n          },\n        },\n        magFilter: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\"\n              ),\n              this.texture.magFilter\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\"\n            ),\n              (this.texture.magFilter = t);\n          },\n        },\n        minFilter: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\"\n              ),\n              this.texture.minFilter\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\"\n            ),\n              (this.texture.minFilter = t);\n          },\n        },\n        anisotropy: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\"\n              ),\n              this.texture.anisotropy\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\"\n            ),\n              (this.texture.anisotropy = t);\n          },\n        },\n        offset: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .offset is now .texture.offset.\"\n              ),\n              this.texture.offset\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .offset is now .texture.offset.\"\n            ),\n              (this.texture.offset = t);\n          },\n        },\n        repeat: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\"\n              ),\n              this.texture.repeat\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\"\n            ),\n              (this.texture.repeat = t);\n          },\n        },\n        format: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .format is now .texture.format.\"\n              ),\n              this.texture.format\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .format is now .texture.format.\"\n            ),\n              (this.texture.format = t);\n          },\n        },\n        type: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .type is now .texture.type.\"\n              ),\n              this.texture.type\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .type is now .texture.type.\"\n            ),\n              (this.texture.type = t);\n          },\n        },\n        generateMipmaps: {\n          get: function () {\n            return (\n              console.warn(\n                \"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\"\n              ),\n              this.texture.generateMipmaps\n            );\n          },\n          set: function (t) {\n            console.warn(\n              \"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\"\n            ),\n              (this.texture.generateMipmaps = t);\n          },\n        },\n      }),\n      ($c.prototype.load = function (t) {\n        console.warn(\n          \"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.\"\n        );\n        const e = this;\n        return (\n          new kc().load(t, function (t) {\n            e.setBuffer(t);\n          }),\n          this\n        );\n      }),\n      (rh.prototype.getData = function () {\n        return (\n          console.warn(\n            \"THREE.AudioAnalyser: .getData() is now .getFrequencyData().\"\n          ),\n          this.getFrequencyData()\n        );\n      }),\n      (ti.prototype.updateCubeMap = function (t, e) {\n        return (\n          console.warn(\"THREE.CubeCamera: .updateCubeMap() is now .update().\"),\n          this.update(t, e)\n        );\n      }),\n      (ti.prototype.clear = function (t, e, n, i) {\n        return (\n          console.warn(\n            \"THREE.CubeCamera: .clear() is now .renderTarget.clear().\"\n          ),\n          this.renderTarget.clear(t, e, n, i)\n        );\n      }),\n      (Et.crossOrigin = void 0),\n      (Et.loadTexture = function (t, e, n, i) {\n        console.warn(\n          \"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.\"\n        );\n        const r = new dc();\n        r.setCrossOrigin(this.crossOrigin);\n        const s = r.load(t, n, void 0, i);\n        return e && (s.mapping = e), s;\n      }),\n      (Et.loadTextureCube = function (t, e, n, i) {\n        console.warn(\n          \"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.\"\n        );\n        const r = new hc();\n        r.setCrossOrigin(this.crossOrigin);\n        const s = r.load(t, n, void 0, i);\n        return e && (s.mapping = e), s;\n      }),\n      (Et.loadCompressedTexture = function () {\n        console.error(\n          \"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.\"\n        );\n      }),\n      (Et.loadCompressedTextureCube = function () {\n        console.error(\n          \"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.\"\n        );\n      });\n    const tu = {\n      createMultiMaterialObject: function () {\n        console.error(\n          \"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\"\n        );\n      },\n      detach: function () {\n        console.error(\n          \"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\"\n        );\n      },\n      attach: function () {\n        console.error(\n          \"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\"\n        );\n      },\n    };\n    \"undefined\" != typeof __THREE_DEVTOOLS__ &&\n      __THREE_DEVTOOLS__.dispatchEvent(\n        new CustomEvent(\"register\", { detail: { revision: e } })\n      ),\n      \"undefined\" != typeof window &&\n        (window.__THREE__\n          ? console.warn(\n              \"WARNING: Multiple instances of Three.js being imported.\"\n            )\n          : (window.__THREE__ = e)),\n      (t.ACESFilmicToneMapping = 4),\n      (t.AddEquation = n),\n      (t.AddOperation = 2),\n      (t.AdditiveAnimationBlendMode = q),\n      (t.AdditiveBlending = 2),\n      (t.AlphaFormat = 1021),\n      (t.AlwaysDepth = 1),\n      (t.AlwaysStencilFunc = 519),\n      (t.AmbientLight = Lc),\n      (t.AmbientLightProbe = Wc),\n      (t.AnimationClip = ec),\n      (t.AnimationLoader = class extends ac {\n        constructor(t) {\n          super(t);\n        }\n        load(t, e, n, i) {\n          const r = this,\n            s = new lc(this.manager);\n          s.setPath(this.path),\n            s.setRequestHeader(this.requestHeader),\n            s.setWithCredentials(this.withCredentials),\n            s.load(\n              t,\n              function (n) {\n                try {\n                  e(r.parse(JSON.parse(n)));\n                } catch (e) {\n                  i ? i(e) : console.error(e), r.manager.itemError(t);\n                }\n              },\n              n,\n              i\n            );\n        }\n        parse(t) {\n          const e = [];\n          for (let n = 0; n < t.length; n++) {\n            const i = ec.parse(t[n]);\n            e.push(i);\n          }\n          return e;\n        }\n      }),\n      (t.AnimationMixer = xh),\n      (t.AnimationObjectGroup = vh),\n      (t.AnimationUtils = kl),\n      (t.ArcCurve = bo),\n      (t.ArrayCamera = js),\n      (t.ArrowHelper = class extends Fe {\n        constructor(\n          t = new zt(0, 0, 1),\n          e = new zt(0, 0, 0),\n          n = 1,\n          i = 16776960,\n          r = 0.2 * n,\n          s = 0.2 * r\n        ) {\n          super(),\n            (this.type = \"ArrowHelper\"),\n            void 0 === Jh &&\n              ((Jh = new En()),\n              Jh.setAttribute(\"position\", new vn([0, 0, 0, 0, 1, 0], 3)),\n              (Zh = new ho(0, 0.5, 1, 5, 1)),\n              Zh.translate(0, -0.5, 0)),\n            this.position.copy(e),\n            (this.line = new Xa(Jh, new Ga({ color: i, toneMapped: !1 }))),\n            (this.line.matrixAutoUpdate = !1),\n            this.add(this.line),\n            (this.cone = new Wn(Zh, new sn({ color: i, toneMapped: !1 }))),\n            (this.cone.matrixAutoUpdate = !1),\n            this.add(this.cone),\n            this.setDirection(t),\n            this.setLength(n, r, s);\n        }\n        setDirection(t) {\n          if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);\n          else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);\n          else {\n            Yh.set(t.z, 0, -t.x).normalize();\n            const e = Math.acos(t.y);\n            this.quaternion.setFromAxisAngle(Yh, e);\n          }\n        }\n        setLength(t, e = 0.2 * t, n = 0.2 * e) {\n          this.line.scale.set(1, Math.max(1e-4, t - e), 1),\n            this.line.updateMatrix(),\n            this.cone.scale.set(n, e, n),\n            (this.cone.position.y = t),\n            this.cone.updateMatrix();\n        }\n        setColor(t) {\n          this.line.material.color.set(t), this.cone.material.color.set(t);\n        }\n        copy(t) {\n          return (\n            super.copy(t, !1),\n            this.line.copy(t.line),\n            this.cone.copy(t.cone),\n            this\n          );\n        }\n      }),\n      (t.Audio = $c),\n      (t.AudioAnalyser = rh),\n      (t.AudioContext = Gc),\n      (t.AudioListener = class extends Fe {\n        constructor() {\n          super(),\n            (this.type = \"AudioListener\"),\n            (this.context = Gc.getContext()),\n            (this.gain = this.context.createGain()),\n            this.gain.connect(this.context.destination),\n            (this.filter = null),\n            (this.timeDelta = 0),\n            (this._clock = new Xc());\n        }\n        getInput() {\n          return this.gain;\n        }\n        removeFilter() {\n          return (\n            null !== this.filter &&\n              (this.gain.disconnect(this.filter),\n              this.filter.disconnect(this.context.destination),\n              this.gain.connect(this.context.destination),\n              (this.filter = null)),\n            this\n          );\n        }\n        getFilter() {\n          return this.filter;\n        }\n        setFilter(t) {\n          return (\n            null !== this.filter\n              ? (this.gain.disconnect(this.filter),\n                this.filter.disconnect(this.context.destination))\n              : this.gain.disconnect(this.context.destination),\n            (this.filter = t),\n            this.gain.connect(this.filter),\n            this.filter.connect(this.context.destination),\n            this\n          );\n        }\n        getMasterVolume() {\n          return this.gain.gain.value;\n        }\n        setMasterVolume(t) {\n          return (\n            this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),\n            this\n          );\n        }\n        updateMatrixWorld(t) {\n          super.updateMatrixWorld(t);\n          const e = this.context.listener,\n            n = this.up;\n          if (\n            ((this.timeDelta = this._clock.getDelta()),\n            this.matrixWorld.decompose(Jc, Zc, Qc),\n            Kc.set(0, 0, -1).applyQuaternion(Zc),\n            e.positionX)\n          ) {\n            const t = this.context.currentTime + this.timeDelta;\n            e.positionX.linearRampToValueAtTime(Jc.x, t),\n              e.positionY.linearRampToValueAtTime(Jc.y, t),\n              e.positionZ.linearRampToValueAtTime(Jc.z, t),\n              e.forwardX.linearRampToValueAtTime(Kc.x, t),\n              e.forwardY.linearRampToValueAtTime(Kc.y, t),\n              e.forwardZ.linearRampToValueAtTime(Kc.z, t),\n              e.upX.linearRampToValueAtTime(n.x, t),\n              e.upY.linearRampToValueAtTime(n.y, t),\n              e.upZ.linearRampToValueAtTime(n.z, t);\n          } else\n            e.setPosition(Jc.x, Jc.y, Jc.z),\n              e.setOrientation(Kc.x, Kc.y, Kc.z, n.x, n.y, n.z);\n        }\n      }),\n      (t.AudioLoader = kc),\n      (t.AxesHelper = Qh),\n      (t.AxisHelper = function (t) {\n        return (\n          console.warn(\n            \"THREE.AxisHelper has been renamed to THREE.AxesHelper.\"\n          ),\n          new Qh(t)\n        );\n      }),\n      (t.BackSide = 1),\n      (t.BasicDepthPacking = 3200),\n      (t.BasicShadowMap = 0),\n      (t.BinaryTextureLoader = function (t) {\n        return (\n          console.warn(\n            \"THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.\"\n          ),\n          new uc(t)\n        );\n      }),\n      (t.Bone = Ca),\n      (t.BooleanKeyframeTrack = Yl),\n      (t.BoundingBoxHelper = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.\"\n          ),\n          new Xh(t, e)\n        );\n      }),\n      (t.Box2 = Eh),\n      (t.Box3 = Ot),\n      (t.Box3Helper = class extends Za {\n        constructor(t, e = 16776960) {\n          const n = new Uint16Array([\n              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,\n              3, 7,\n            ]),\n            i = new En();\n          i.setIndex(new ln(n, 1)),\n            i.setAttribute(\n              \"position\",\n              new vn(\n                [\n                  1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,\n                  -1, -1, -1, 1, -1, -1,\n                ],\n                3\n              )\n            ),\n            super(i, new Ga({ color: e, toneMapped: !1 })),\n            (this.box = t),\n            (this.type = \"Box3Helper\"),\n            this.geometry.computeBoundingSphere();\n        }\n        updateMatrixWorld(t) {\n          const e = this.box;\n          e.isEmpty() ||\n            (e.getCenter(this.position),\n            e.getSize(this.scale),\n            this.scale.multiplyScalar(0.5),\n            super.updateMatrixWorld(t));\n        }\n      }),\n      (t.BoxBufferGeometry = qn),\n      (t.BoxGeometry = qn),\n      (t.BoxHelper = Xh),\n      (t.BufferAttribute = ln),\n      (t.BufferGeometry = En),\n      (t.BufferGeometryLoader = zc),\n      (t.ByteType = 1010),\n      (t.Cache = ic),\n      (t.Camera = Qn),\n      (t.CameraHelper = class extends Za {\n        constructor(t) {\n          const e = new En(),\n            n = new Ga({ color: 16777215, vertexColors: !0, toneMapped: !1 }),\n            i = [],\n            r = [],\n            s = {},\n            a = new rn(16755200),\n            o = new rn(16711680),\n            l = new rn(43775),\n            c = new rn(16777215),\n            h = new rn(3355443);\n          function u(t, e, n) {\n            d(t, n), d(e, n);\n          }\n          function d(t, e) {\n            i.push(0, 0, 0),\n              r.push(e.r, e.g, e.b),\n              void 0 === s[t] && (s[t] = []),\n              s[t].push(i.length / 3 - 1);\n          }\n          u(\"n1\", \"n2\", a),\n            u(\"n2\", \"n4\", a),\n            u(\"n4\", \"n3\", a),\n            u(\"n3\", \"n1\", a),\n            u(\"f1\", \"f2\", a),\n            u(\"f2\", \"f4\", a),\n            u(\"f4\", \"f3\", a),\n            u(\"f3\", \"f1\", a),\n            u(\"n1\", \"f1\", a),\n            u(\"n2\", \"f2\", a),\n            u(\"n3\", \"f3\", a),\n            u(\"n4\", \"f4\", a),\n            u(\"p\", \"n1\", o),\n            u(\"p\", \"n2\", o),\n            u(\"p\", \"n3\", o),\n            u(\"p\", \"n4\", o),\n            u(\"u1\", \"u2\", l),\n            u(\"u2\", \"u3\", l),\n            u(\"u3\", \"u1\", l),\n            u(\"c\", \"t\", c),\n            u(\"p\", \"c\", h),\n            u(\"cn1\", \"cn2\", h),\n            u(\"cn3\", \"cn4\", h),\n            u(\"cf1\", \"cf2\", h),\n            u(\"cf3\", \"cf4\", h),\n            e.setAttribute(\"position\", new vn(i, 3)),\n            e.setAttribute(\"color\", new vn(r, 3)),\n            super(e, n),\n            (this.type = \"CameraHelper\"),\n            (this.camera = t),\n            this.camera.updateProjectionMatrix &&\n              this.camera.updateProjectionMatrix(),\n            (this.matrix = t.matrixWorld),\n            (this.matrixAutoUpdate = !1),\n            (this.pointMap = s),\n            this.update();\n        }\n        update() {\n          const t = this.geometry,\n            e = this.pointMap;\n          Wh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),\n            jh(\"c\", e, t, Wh, 0, 0, -1),\n            jh(\"t\", e, t, Wh, 0, 0, 1),\n            jh(\"n1\", e, t, Wh, -1, -1, -1),\n            jh(\"n2\", e, t, Wh, 1, -1, -1),\n            jh(\"n3\", e, t, Wh, -1, 1, -1),\n            jh(\"n4\", e, t, Wh, 1, 1, -1),\n            jh(\"f1\", e, t, Wh, -1, -1, 1),\n            jh(\"f2\", e, t, Wh, 1, -1, 1),\n            jh(\"f3\", e, t, Wh, -1, 1, 1),\n            jh(\"f4\", e, t, Wh, 1, 1, 1),\n            jh(\"u1\", e, t, Wh, 0.7, 1.1, -1),\n            jh(\"u2\", e, t, Wh, -0.7, 1.1, -1),\n            jh(\"u3\", e, t, Wh, 0, 2, -1),\n            jh(\"cf1\", e, t, Wh, -1, 0, 1),\n            jh(\"cf2\", e, t, Wh, 1, 0, 1),\n            jh(\"cf3\", e, t, Wh, 0, -1, 1),\n            jh(\"cf4\", e, t, Wh, 0, 1, 1),\n            jh(\"cn1\", e, t, Wh, -1, 0, -1),\n            jh(\"cn2\", e, t, Wh, 1, 0, -1),\n            jh(\"cn3\", e, t, Wh, 0, -1, -1),\n            jh(\"cn4\", e, t, Wh, 0, 1, -1),\n            (t.getAttribute(\"position\").needsUpdate = !0);\n        }\n        dispose() {\n          this.geometry.dispose(), this.material.dispose();\n        }\n      }),\n      (t.CanvasRenderer = function () {\n        console.error(\"THREE.CanvasRenderer has been removed\");\n      }),\n      (t.CanvasTexture = oo),\n      (t.CatmullRomCurve3 = Lo),\n      (t.CineonToneMapping = 3),\n      (t.CircleBufferGeometry = co),\n      (t.CircleGeometry = co),\n      (t.ClampToEdgeWrapping = u),\n      (t.Clock = Xc),\n      (t.Color = rn),\n      (t.ColorKeyframeTrack = Jl),\n      (t.CompressedTexture = ao),\n      (t.CompressedTextureLoader = class extends ac {\n        constructor(t) {\n          super(t);\n        }\n        load(t, e, n, i) {\n          const r = this,\n            s = [],\n            a = new ao(),\n            o = new lc(this.manager);\n          o.setPath(this.path),\n            o.setResponseType(\"arraybuffer\"),\n            o.setRequestHeader(this.requestHeader),\n            o.setWithCredentials(r.withCredentials);\n          let l = 0;\n          function c(c) {\n            o.load(\n              t[c],\n              function (t) {\n                const n = r.parse(t, !0);\n                (s[c] = {\n                  width: n.width,\n                  height: n.height,\n                  format: n.format,\n                  mipmaps: n.mipmaps,\n                }),\n                  (l += 1),\n                  6 === l &&\n                    (1 === n.mipmapCount && (a.minFilter = g),\n                    (a.image = s),\n                    (a.format = n.format),\n                    (a.needsUpdate = !0),\n                    e && e(a));\n              },\n              n,\n              i\n            );\n          }\n          if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) c(e);\n          else\n            o.load(\n              t,\n              function (t) {\n                const n = r.parse(t, !0);\n                if (n.isCubemap) {\n                  const t = n.mipmaps.length / n.mipmapCount;\n                  for (let e = 0; e < t; e++) {\n                    s[e] = { mipmaps: [] };\n                    for (let t = 0; t < n.mipmapCount; t++)\n                      s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),\n                        (s[e].format = n.format),\n                        (s[e].width = n.width),\n                        (s[e].height = n.height);\n                  }\n                  a.image = s;\n                } else\n                  (a.image.width = n.width),\n                    (a.image.height = n.height),\n                    (a.mipmaps = n.mipmaps);\n                1 === n.mipmapCount && (a.minFilter = g),\n                  (a.format = n.format),\n                  (a.needsUpdate = !0),\n                  e && e(a);\n              },\n              n,\n              i\n            );\n          return a;\n        }\n      }),\n      (t.ConeBufferGeometry = uo),\n      (t.ConeGeometry = uo),\n      (t.CubeCamera = ti),\n      (t.CubeReflectionMapping = r),\n      (t.CubeRefractionMapping = s),\n      (t.CubeTexture = ei),\n      (t.CubeTextureLoader = hc),\n      (t.CubeUVReflectionMapping = l),\n      (t.CubeUVRefractionMapping = c),\n      (t.CubicBezierCurve = Io),\n      (t.CubicBezierCurve3 = Do),\n      (t.CubicInterpolant = Wl),\n      (t.CullFaceBack = 1),\n      (t.CullFaceFront = 2),\n      (t.CullFaceFrontBack = 3),\n      (t.CullFaceNone = 0),\n      (t.Curve = _o),\n      (t.CurvePath = Ho),\n      (t.CustomBlending = 5),\n      (t.CustomToneMapping = 5),\n      (t.CylinderBufferGeometry = ho),\n      (t.CylinderGeometry = ho),\n      (t.Cylindrical = class {\n        constructor(t = 1, e = 0, n = 0) {\n          return (this.radius = t), (this.theta = e), (this.y = n), this;\n        }\n        set(t, e, n) {\n          return (this.radius = t), (this.theta = e), (this.y = n), this;\n        }\n        copy(t) {\n          return (\n            (this.radius = t.radius),\n            (this.theta = t.theta),\n            (this.y = t.y),\n            this\n          );\n        }\n        setFromVector3(t) {\n          return this.setFromCartesianCoords(t.x, t.y, t.z);\n        }\n        setFromCartesianCoords(t, e, n) {\n          return (\n            (this.radius = Math.sqrt(t * t + n * n)),\n            (this.theta = Math.atan2(t, n)),\n            (this.y = e),\n            this\n          );\n        }\n        clone() {\n          return new this.constructor().copy(this);\n        }\n      }),\n      (t.DataTexture = Pa),\n      (t.DataTexture2DArray = Ki),\n      (t.DataTexture3D = rr),\n      (t.DataTextureLoader = uc),\n      (t.DataUtils = class {\n        static toHalfFloat(t) {\n          t > 65504 &&\n            (console.warn(\n              \"THREE.DataUtils.toHalfFloat(): value exceeds 65504.\"\n            ),\n            (t = 65504)),\n            (Kh[0] = t);\n          const e = $h[0];\n          let n = (e >> 16) & 32768,\n            i = (e >> 12) & 2047;\n          const r = (e >> 23) & 255;\n          return r < 103\n            ? n\n            : r > 142\n            ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)\n            : r < 113\n            ? ((i |= 2048), (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)), n)\n            : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n);\n        }\n      }),\n      (t.DecrementStencilOp = 7683),\n      (t.DecrementWrapStencilOp = 34056),\n      (t.DefaultLoadingManager = sc),\n      (t.DepthFormat = A),\n      (t.DepthStencilFormat = L),\n      (t.DepthTexture = lo),\n      (t.DirectionalLight = Ac),\n      (t.DirectionalLightHelper = class extends Fe {\n        constructor(t, e, n) {\n          super(),\n            (this.light = t),\n            this.light.updateMatrixWorld(),\n            (this.matrix = t.matrixWorld),\n            (this.matrixAutoUpdate = !1),\n            (this.color = n),\n            void 0 === e && (e = 1);\n          let i = new En();\n          i.setAttribute(\n            \"position\",\n            new vn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)\n          );\n          const r = new Ga({ fog: !1, toneMapped: !1 });\n          (this.lightPlane = new Xa(i, r)),\n            this.add(this.lightPlane),\n            (i = new En()),\n            i.setAttribute(\"position\", new vn([0, 0, 0, 0, 0, 1], 3)),\n            (this.targetLine = new Xa(i, r)),\n            this.add(this.targetLine),\n            this.update();\n        }\n        dispose() {\n          this.lightPlane.geometry.dispose(),\n            this.lightPlane.material.dispose(),\n            this.targetLine.geometry.dispose(),\n            this.targetLine.material.dispose();\n        }\n        update() {\n          Hh.setFromMatrixPosition(this.light.matrixWorld),\n            Gh.setFromMatrixPosition(this.light.target.matrixWorld),\n            kh.subVectors(Gh, Hh),\n            this.lightPlane.lookAt(Gh),\n            void 0 !== this.color\n              ? (this.lightPlane.material.color.set(this.color),\n                this.targetLine.material.color.set(this.color))\n              : (this.lightPlane.material.color.copy(this.light.color),\n                this.targetLine.material.color.copy(this.light.color)),\n            this.targetLine.lookAt(Gh),\n            (this.targetLine.scale.z = kh.length());\n        }\n      }),\n      (t.DiscreteInterpolant = ql),\n      (t.DodecahedronBufferGeometry = mo),\n      (t.DodecahedronGeometry = mo),\n      (t.DoubleSide = 2),\n      (t.DstAlphaFactor = 206),\n      (t.DstColorFactor = 208),\n      (t.DynamicBufferAttribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.\"\n          ),\n          new ln(t, e).setUsage(nt)\n        );\n      }),\n      (t.DynamicCopyUsage = 35050),\n      (t.DynamicDrawUsage = nt),\n      (t.DynamicReadUsage = 35049),\n      (t.EdgesGeometry = xo),\n      (t.EdgesHelper = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.\"\n          ),\n          new Za(\n            new xo(t.geometry),\n            new Ga({ color: void 0 !== e ? e : 16777215 })\n          )\n        );\n      }),\n      (t.EllipseCurve = Mo),\n      (t.EqualDepth = 4),\n      (t.EqualStencilFunc = 514),\n      (t.EquirectangularReflectionMapping = a),\n      (t.EquirectangularRefractionMapping = o),\n      (t.Euler = be),\n      (t.EventDispatcher = rt),\n      (t.ExtrudeBufferGeometry = vl),\n      (t.ExtrudeGeometry = vl),\n      (t.FaceColors = 1),\n      (t.FileLoader = lc),\n      (t.FlatShading = 1),\n      (t.Float16BufferAttribute = gn),\n      (t.Float32Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.\"\n          ),\n          new vn(t, e)\n        );\n      }),\n      (t.Float32BufferAttribute = vn),\n      (t.Float64Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.\"\n          ),\n          new yn(t, e)\n        );\n      }),\n      (t.Float64BufferAttribute = yn),\n      (t.FloatType = b),\n      (t.Fog = ta),\n      (t.FogExp2 = $s),\n      (t.Font = function () {\n        console.error(\n          \"THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js\"\n        );\n      }),\n      (t.FontLoader = function () {\n        console.error(\n          \"THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js\"\n        );\n      }),\n      (t.FrontSide = 0),\n      (t.Frustum = ci),\n      (t.GLBufferAttribute = bh),\n      (t.GLSL1 = \"100\"),\n      (t.GLSL3 = it),\n      (t.GammaEncoding = J),\n      (t.GreaterDepth = 6),\n      (t.GreaterEqualDepth = 5),\n      (t.GreaterEqualStencilFunc = 518),\n      (t.GreaterStencilFunc = 516),\n      (t.GridHelper = Uh),\n      (t.Group = qs),\n      (t.HalfFloatType = w),\n      (t.HemisphereLight = mc),\n      (t.HemisphereLightHelper = class extends Fe {\n        constructor(t, e, n) {\n          super(),\n            (this.light = t),\n            this.light.updateMatrixWorld(),\n            (this.matrix = t.matrixWorld),\n            (this.matrixAutoUpdate = !1),\n            (this.color = n);\n          const i = new Ml(e);\n          i.rotateY(0.5 * Math.PI),\n            (this.material = new sn({\n              wireframe: !0,\n              fog: !1,\n              toneMapped: !1,\n            })),\n            void 0 === this.color && (this.material.vertexColors = !0);\n          const r = i.getAttribute(\"position\"),\n            s = new Float32Array(3 * r.count);\n          i.setAttribute(\"color\", new ln(s, 3)),\n            this.add(new Wn(i, this.material)),\n            this.update();\n        }\n        dispose() {\n          this.children[0].geometry.dispose(),\n            this.children[0].material.dispose();\n        }\n        update() {\n          const t = this.children[0];\n          if (void 0 !== this.color) this.material.color.set(this.color);\n          else {\n            const e = t.geometry.getAttribute(\"color\");\n            Fh.copy(this.light.color), Oh.copy(this.light.groundColor);\n            for (let t = 0, n = e.count; t < n; t++) {\n              const i = t < n / 2 ? Fh : Oh;\n              e.setXYZ(t, i.r, i.g, i.b);\n            }\n            e.needsUpdate = !0;\n          }\n          t.lookAt(Bh.setFromMatrixPosition(this.light.matrixWorld).negate());\n        }\n      }),\n      (t.HemisphereLightProbe = Vc),\n      (t.IcosahedronBufferGeometry = xl),\n      (t.IcosahedronGeometry = xl),\n      (t.ImageBitmapLoader = Uc),\n      (t.ImageLoader = cc),\n      (t.ImageUtils = Et),\n      (t.ImmediateRenderObject = function () {\n        console.error(\"THREE.ImmediateRenderObject has been removed.\");\n      }),\n      (t.IncrementStencilOp = 7682),\n      (t.IncrementWrapStencilOp = 34055),\n      (t.InstancedBufferAttribute = za),\n      (t.InstancedBufferGeometry = Nc),\n      (t.InstancedInterleavedBuffer = Mh),\n      (t.InstancedMesh = Ha),\n      (t.Int16Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.\"\n          ),\n          new dn(t, e)\n        );\n      }),\n      (t.Int16BufferAttribute = dn),\n      (t.Int32Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.\"\n          ),\n          new mn(t, e)\n        );\n      }),\n      (t.Int32BufferAttribute = mn),\n      (t.Int8Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.\"\n          ),\n          new cn(t, e)\n        );\n      }),\n      (t.Int8BufferAttribute = cn),\n      (t.IntType = 1013),\n      (t.InterleavedBuffer = na),\n      (t.InterleavedBufferAttribute = ra),\n      (t.Interpolant = Vl),\n      (t.InterpolateDiscrete = U),\n      (t.InterpolateLinear = H),\n      (t.InterpolateSmooth = G),\n      (t.InvertStencilOp = 5386),\n      (t.JSONLoader = function () {\n        console.error(\"THREE.JSONLoader has been removed.\");\n      }),\n      (t.KeepStencilOp = tt),\n      (t.KeyframeTrack = Xl),\n      (t.LOD = wa),\n      (t.LatheBufferGeometry = _l),\n      (t.LatheGeometry = _l),\n      (t.Layers = we),\n      (t.LensFlare = function () {\n        console.error(\n          \"THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js\"\n        );\n      }),\n      (t.LessDepth = 2),\n      (t.LessEqualDepth = 3),\n      (t.LessEqualStencilFunc = 515),\n      (t.LessStencilFunc = 513),\n      (t.Light = pc),\n      (t.LightProbe = Pc),\n      (t.Line = Xa),\n      (t.Line3 = Rh),\n      (t.LineBasicMaterial = Ga),\n      (t.LineCurve = No),\n      (t.LineCurve3 = zo),\n      (t.LineDashedMaterial = Hl),\n      (t.LineLoop = Qa),\n      (t.LinePieces = 1),\n      (t.LineSegments = Za),\n      (t.LineStrip = 0),\n      (t.LinearEncoding = X),\n      (t.LinearFilter = g),\n      (t.LinearInterpolant = jl),\n      (t.LinearMipMapLinearFilter = 1008),\n      (t.LinearMipMapNearestFilter = 1007),\n      (t.LinearMipmapLinearFilter = y),\n      (t.LinearMipmapNearestFilter = v),\n      (t.LinearToneMapping = 1),\n      (t.Loader = ac),\n      (t.LoaderUtils = Dc),\n      (t.LoadingManager = rc),\n      (t.LogLuvEncoding = 3003),\n      (t.LoopOnce = 2200),\n      (t.LoopPingPong = 2202),\n      (t.LoopRepeat = 2201),\n      (t.LuminanceAlphaFormat = 1025),\n      (t.LuminanceFormat = 1024),\n      (t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }),\n      (t.Material = Ze),\n      (t.MaterialLoader = Ic),\n      (t.Math = vt),\n      (t.MathUtils = vt),\n      (t.Matrix3 = xt),\n      (t.Matrix4 = de),\n      (t.MaxEquation = 104),\n      (t.Mesh = Wn),\n      (t.MeshBasicMaterial = sn),\n      (t.MeshDepthMaterial = Us),\n      (t.MeshDistanceMaterial = Hs),\n      (t.MeshFaceMaterial = function (t) {\n        return (\n          console.warn(\n            \"THREE.MeshFaceMaterial has been removed. Use an Array instead.\"\n          ),\n          t\n        );\n      }),\n      (t.MeshLambertMaterial = Ol),\n      (t.MeshMatcapMaterial = Ul),\n      (t.MeshNormalMaterial = Fl),\n      (t.MeshPhongMaterial = zl),\n      (t.MeshPhysicalMaterial = Nl),\n      (t.MeshStandardMaterial = Dl),\n      (t.MeshToonMaterial = Bl),\n      (t.MinEquation = 103),\n      (t.MirroredRepeatWrapping = d),\n      (t.MixOperation = 1),\n      (t.MultiMaterial = function (t = []) {\n        return (\n          console.warn(\n            \"THREE.MultiMaterial has been removed. Use an Array instead.\"\n          ),\n          (t.isMultiMaterial = !0),\n          (t.materials = t),\n          (t.clone = function () {\n            return t.slice();\n          }),\n          t\n        );\n      }),\n      (t.MultiplyBlending = 4),\n      (t.MultiplyOperation = 0),\n      (t.NearestFilter = p),\n      (t.NearestMipMapLinearFilter = 1005),\n      (t.NearestMipMapNearestFilter = 1004),\n      (t.NearestMipmapLinearFilter = f),\n      (t.NearestMipmapNearestFilter = m),\n      (t.NeverDepth = 0),\n      (t.NeverStencilFunc = 512),\n      (t.NoBlending = 0),\n      (t.NoColors = 0),\n      (t.NoToneMapping = 0),\n      (t.NormalAnimationBlendMode = j),\n      (t.NormalBlending = 1),\n      (t.NotEqualDepth = 7),\n      (t.NotEqualStencilFunc = 517),\n      (t.NumberKeyframeTrack = Zl),\n      (t.Object3D = Fe),\n      (t.ObjectLoader = class extends ac {\n        constructor(t) {\n          super(t);\n        }\n        load(t, e, n, i) {\n          const r = this,\n            s = \"\" === this.path ? Dc.extractUrlBase(t) : this.path;\n          this.resourcePath = this.resourcePath || s;\n          const a = new lc(this.manager);\n          a.setPath(this.path),\n            a.setRequestHeader(this.requestHeader),\n            a.setWithCredentials(this.withCredentials),\n            a.load(\n              t,\n              function (n) {\n                let s = null;\n                try {\n                  s = JSON.parse(n);\n                } catch (e) {\n                  return (\n                    void 0 !== i && i(e),\n                    void console.error(\n                      \"THREE:ObjectLoader: Can't parse \" + t + \".\",\n                      e.message\n                    )\n                  );\n                }\n                const a = s.metadata;\n                void 0 !== a &&\n                void 0 !== a.type &&\n                \"geometry\" !== a.type.toLowerCase()\n                  ? r.parse(s, e)\n                  : console.error(\"THREE.ObjectLoader: Can't load \" + t);\n              },\n              n,\n              i\n            );\n        }\n        async loadAsync(t, e) {\n          const n = \"\" === this.path ? Dc.extractUrlBase(t) : this.path;\n          this.resourcePath = this.resourcePath || n;\n          const i = new lc(this.manager);\n          i.setPath(this.path),\n            i.setRequestHeader(this.requestHeader),\n            i.setWithCredentials(this.withCredentials);\n          const r = await i.loadAsync(t, e),\n            s = JSON.parse(r),\n            a = s.metadata;\n          if (\n            void 0 === a ||\n            void 0 === a.type ||\n            \"geometry\" === a.type.toLowerCase()\n          )\n            throw new Error(\"THREE.ObjectLoader: Can't load \" + t);\n          return await this.parseAsync(s);\n        }\n        parse(t, e) {\n          const n = this.parseAnimations(t.animations),\n            i = this.parseShapes(t.shapes),\n            r = this.parseGeometries(t.geometries, i),\n            s = this.parseImages(t.images, function () {\n              void 0 !== e && e(l);\n            }),\n            a = this.parseTextures(t.textures, s),\n            o = this.parseMaterials(t.materials, a),\n            l = this.parseObject(t.object, r, o, a, n),\n            c = this.parseSkeletons(t.skeletons, l);\n          if ((this.bindSkeletons(l, c), void 0 !== e)) {\n            let t = !1;\n            for (const e in s)\n              if (s[e] instanceof HTMLImageElement) {\n                t = !0;\n                break;\n              }\n            !1 === t && e(l);\n          }\n          return l;\n        }\n        async parseAsync(t) {\n          const e = this.parseAnimations(t.animations),\n            n = this.parseShapes(t.shapes),\n            i = this.parseGeometries(t.geometries, n),\n            r = await this.parseImagesAsync(t.images),\n            s = this.parseTextures(t.textures, r),\n            a = this.parseMaterials(t.materials, s),\n            o = this.parseObject(t.object, i, a, s, e),\n            l = this.parseSkeletons(t.skeletons, o);\n          return this.bindSkeletons(o, l), o;\n        }\n        parseShapes(t) {\n          const e = {};\n          if (void 0 !== t)\n            for (let n = 0, i = t.length; n < i; n++) {\n              const i = new ko().fromJSON(t[n]);\n              e[i.uuid] = i;\n            }\n          return e;\n        }\n        parseSkeletons(t, e) {\n          const n = {},\n            i = {};\n          if (\n            (e.traverse(function (t) {\n              t.isBone && (i[t.uuid] = t);\n            }),\n            void 0 !== t)\n          )\n            for (let e = 0, r = t.length; e < r; e++) {\n              const r = new Na().fromJSON(t[e], i);\n              n[r.uuid] = r;\n            }\n          return n;\n        }\n        parseGeometries(t, e) {\n          const n = {};\n          if (void 0 !== t) {\n            const i = new zc();\n            for (let r = 0, s = t.length; r < s; r++) {\n              let s;\n              const a = t[r];\n              switch (a.type) {\n                case \"BufferGeometry\":\n                case \"InstancedBufferGeometry\":\n                  s = i.parse(a);\n                  break;\n                case \"Geometry\":\n                  console.error(\n                    \"THREE.ObjectLoader: The legacy Geometry type is no longer supported.\"\n                  );\n                  break;\n                default:\n                  a.type in Pl\n                    ? (s = Pl[a.type].fromJSON(a, e))\n                    : console.warn(\n                        `THREE.ObjectLoader: Unsupported geometry type \"${a.type}\"`\n                      );\n              }\n              (s.uuid = a.uuid),\n                void 0 !== a.name && (s.name = a.name),\n                !0 === s.isBufferGeometry &&\n                  void 0 !== a.userData &&\n                  (s.userData = a.userData),\n                (n[a.uuid] = s);\n            }\n          }\n          return n;\n        }\n        parseMaterials(t, e) {\n          const n = {},\n            i = {};\n          if (void 0 !== t) {\n            const r = new Ic();\n            r.setTextures(e);\n            for (let e = 0, s = t.length; e < s; e++) {\n              const s = t[e];\n              if (\"MultiMaterial\" === s.type) {\n                const t = [];\n                for (let e = 0; e < s.materials.length; e++) {\n                  const i = s.materials[e];\n                  void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),\n                    t.push(n[i.uuid]);\n                }\n                i[s.uuid] = t;\n              } else\n                void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),\n                  (i[s.uuid] = n[s.uuid]);\n            }\n          }\n          return i;\n        }\n        parseAnimations(t) {\n          const e = {};\n          if (void 0 !== t)\n            for (let n = 0; n < t.length; n++) {\n              const i = t[n],\n                r = ec.parse(i);\n              e[r.uuid] = r;\n            }\n          return e;\n        }\n        parseImages(t, e) {\n          const n = this,\n            i = {};\n          let r;\n          function s(t) {\n            if (\"string\" == typeof t) {\n              const e = t;\n              return (function (t) {\n                return (\n                  n.manager.itemStart(t),\n                  r.load(\n                    t,\n                    function () {\n                      n.manager.itemEnd(t);\n                    },\n                    void 0,\n                    function () {\n                      n.manager.itemError(t), n.manager.itemEnd(t);\n                    }\n                  )\n                );\n              })(/^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(e) ? e : n.resourcePath + e);\n            }\n            return t.data\n              ? { data: bt(t.type, t.data), width: t.width, height: t.height }\n              : null;\n          }\n          if (void 0 !== t && t.length > 0) {\n            const n = new rc(e);\n            (r = new cc(n)), r.setCrossOrigin(this.crossOrigin);\n            for (let e = 0, n = t.length; e < n; e++) {\n              const n = t[e],\n                r = n.url;\n              if (Array.isArray(r)) {\n                i[n.uuid] = [];\n                for (let t = 0, e = r.length; t < e; t++) {\n                  const e = s(r[t]);\n                  null !== e &&\n                    (e instanceof HTMLImageElement\n                      ? i[n.uuid].push(e)\n                      : i[n.uuid].push(new Pa(e.data, e.width, e.height)));\n                }\n              } else {\n                const t = s(n.url);\n                null !== t && (i[n.uuid] = t);\n              }\n            }\n          }\n          return i;\n        }\n        async parseImagesAsync(t) {\n          const e = this,\n            n = {};\n          let i;\n          async function r(t) {\n            if (\"string\" == typeof t) {\n              const n = t,\n                r = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(n)\n                  ? n\n                  : e.resourcePath + n;\n              return await i.loadAsync(r);\n            }\n            return t.data\n              ? { data: bt(t.type, t.data), width: t.width, height: t.height }\n              : null;\n          }\n          if (void 0 !== t && t.length > 0) {\n            (i = new cc(this.manager)), i.setCrossOrigin(this.crossOrigin);\n            for (let e = 0, i = t.length; e < i; e++) {\n              const i = t[e],\n                s = i.url;\n              if (Array.isArray(s)) {\n                n[i.uuid] = [];\n                for (let t = 0, e = s.length; t < e; t++) {\n                  const e = s[t],\n                    a = await r(e);\n                  null !== a &&\n                    (a instanceof HTMLImageElement\n                      ? n[i.uuid].push(a)\n                      : n[i.uuid].push(new Pa(a.data, a.width, a.height)));\n                }\n              } else {\n                const t = await r(i.url);\n                null !== t && (n[i.uuid] = t);\n              }\n            }\n          }\n          return n;\n        }\n        parseTextures(t, e) {\n          function n(t, e) {\n            return \"number\" == typeof t\n              ? t\n              : (console.warn(\n                  \"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.\",\n                  t\n                ),\n                e[t]);\n          }\n          const i = {};\n          if (void 0 !== t)\n            for (let r = 0, s = t.length; r < s; r++) {\n              const s = t[r];\n              let a;\n              void 0 === s.image &&\n                console.warn(\n                  'THREE.ObjectLoader: No \"image\" specified for',\n                  s.uuid\n                ),\n                void 0 === e[s.image] &&\n                  console.warn(\"THREE.ObjectLoader: Undefined image\", s.image);\n              const o = e[s.image];\n              Array.isArray(o)\n                ? ((a = new ei(o)), 6 === o.length && (a.needsUpdate = !0))\n                : ((a =\n                    o && o.data\n                      ? new Pa(o.data, o.width, o.height)\n                      : new Lt(o)),\n                  o && (a.needsUpdate = !0)),\n                (a.uuid = s.uuid),\n                void 0 !== s.name && (a.name = s.name),\n                void 0 !== s.mapping && (a.mapping = n(s.mapping, Bc)),\n                void 0 !== s.offset && a.offset.fromArray(s.offset),\n                void 0 !== s.repeat && a.repeat.fromArray(s.repeat),\n                void 0 !== s.center && a.center.fromArray(s.center),\n                void 0 !== s.rotation && (a.rotation = s.rotation),\n                void 0 !== s.wrap &&\n                  ((a.wrapS = n(s.wrap[0], Fc)), (a.wrapT = n(s.wrap[1], Fc))),\n                void 0 !== s.format && (a.format = s.format),\n                void 0 !== s.type && (a.type = s.type),\n                void 0 !== s.encoding && (a.encoding = s.encoding),\n                void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Oc)),\n                void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Oc)),\n                void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),\n                void 0 !== s.flipY && (a.flipY = s.flipY),\n                void 0 !== s.premultiplyAlpha &&\n                  (a.premultiplyAlpha = s.premultiplyAlpha),\n                void 0 !== s.unpackAlignment &&\n                  (a.unpackAlignment = s.unpackAlignment),\n                void 0 !== s.userData && (a.userData = s.userData),\n                (i[s.uuid] = a);\n            }\n          return i;\n        }\n        parseObject(t, e, n, i, r) {\n          let s, a, o;\n          function l(t) {\n            return (\n              void 0 === e[t] &&\n                console.warn(\"THREE.ObjectLoader: Undefined geometry\", t),\n              e[t]\n            );\n          }\n          function c(t) {\n            if (void 0 !== t) {\n              if (Array.isArray(t)) {\n                const e = [];\n                for (let i = 0, r = t.length; i < r; i++) {\n                  const r = t[i];\n                  void 0 === n[r] &&\n                    console.warn(\"THREE.ObjectLoader: Undefined material\", r),\n                    e.push(n[r]);\n                }\n                return e;\n              }\n              return (\n                void 0 === n[t] &&\n                  console.warn(\"THREE.ObjectLoader: Undefined material\", t),\n                n[t]\n              );\n            }\n          }\n          function h(t) {\n            return (\n              void 0 === i[t] &&\n                console.warn(\"THREE.ObjectLoader: Undefined texture\", t),\n              i[t]\n            );\n          }\n          switch (t.type) {\n            case \"Scene\":\n              (s = new ea()),\n                void 0 !== t.background &&\n                  (Number.isInteger(t.background)\n                    ? (s.background = new rn(t.background))\n                    : (s.background = h(t.background))),\n                void 0 !== t.environment && (s.environment = h(t.environment)),\n                void 0 !== t.fog &&\n                  (\"Fog\" === t.fog.type\n                    ? (s.fog = new ta(t.fog.color, t.fog.near, t.fog.far))\n                    : \"FogExp2\" === t.fog.type &&\n                      (s.fog = new $s(t.fog.color, t.fog.density)));\n              break;\n            case \"PerspectiveCamera\":\n              (s = new Kn(t.fov, t.aspect, t.near, t.far)),\n                void 0 !== t.focus && (s.focus = t.focus),\n                void 0 !== t.zoom && (s.zoom = t.zoom),\n                void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge),\n                void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset),\n                void 0 !== t.view && (s.view = Object.assign({}, t.view));\n              break;\n            case \"OrthographicCamera\":\n              (s = new bi(t.left, t.right, t.top, t.bottom, t.near, t.far)),\n                void 0 !== t.zoom && (s.zoom = t.zoom),\n                void 0 !== t.view && (s.view = Object.assign({}, t.view));\n              break;\n            case \"AmbientLight\":\n              s = new Lc(t.color, t.intensity);\n              break;\n            case \"DirectionalLight\":\n              s = new Ac(t.color, t.intensity);\n              break;\n            case \"PointLight\":\n              s = new Tc(t.color, t.intensity, t.distance, t.decay);\n              break;\n            case \"RectAreaLight\":\n              s = new Rc(t.color, t.intensity, t.width, t.height);\n              break;\n            case \"SpotLight\":\n              s = new _c(\n                t.color,\n                t.intensity,\n                t.distance,\n                t.angle,\n                t.penumbra,\n                t.decay\n              );\n              break;\n            case \"HemisphereLight\":\n              s = new mc(t.color, t.groundColor, t.intensity);\n              break;\n            case \"LightProbe\":\n              s = new Pc().fromJSON(t);\n              break;\n            case \"SkinnedMesh\":\n              (a = l(t.geometry)),\n                (o = c(t.material)),\n                (s = new Ra(a, o)),\n                void 0 !== t.bindMode && (s.bindMode = t.bindMode),\n                void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix),\n                void 0 !== t.skeleton && (s.skeleton = t.skeleton);\n              break;\n            case \"Mesh\":\n              (a = l(t.geometry)), (o = c(t.material)), (s = new Wn(a, o));\n              break;\n            case \"InstancedMesh\":\n              (a = l(t.geometry)), (o = c(t.material));\n              const e = t.count,\n                n = t.instanceMatrix,\n                i = t.instanceColor;\n              (s = new Ha(a, o, e)),\n                (s.instanceMatrix = new za(new Float32Array(n.array), 16)),\n                void 0 !== i &&\n                  (s.instanceColor = new za(\n                    new Float32Array(i.array),\n                    i.itemSize\n                  ));\n              break;\n            case \"LOD\":\n              s = new wa();\n              break;\n            case \"Line\":\n              s = new Xa(l(t.geometry), c(t.material));\n              break;\n            case \"LineLoop\":\n              s = new Qa(l(t.geometry), c(t.material));\n              break;\n            case \"LineSegments\":\n              s = new Za(l(t.geometry), c(t.material));\n              break;\n            case \"PointCloud\":\n            case \"Points\":\n              s = new io(l(t.geometry), c(t.material));\n              break;\n            case \"Sprite\":\n              s = new xa(c(t.material));\n              break;\n            case \"Group\":\n              s = new qs();\n              break;\n            case \"Bone\":\n              s = new Ca();\n              break;\n            default:\n              s = new Fe();\n          }\n          if (\n            ((s.uuid = t.uuid),\n            void 0 !== t.name && (s.name = t.name),\n            void 0 !== t.matrix\n              ? (s.matrix.fromArray(t.matrix),\n                void 0 !== t.matrixAutoUpdate &&\n                  (s.matrixAutoUpdate = t.matrixAutoUpdate),\n                s.matrixAutoUpdate &&\n                  s.matrix.decompose(s.position, s.quaternion, s.scale))\n              : (void 0 !== t.position && s.position.fromArray(t.position),\n                void 0 !== t.rotation && s.rotation.fromArray(t.rotation),\n                void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion),\n                void 0 !== t.scale && s.scale.fromArray(t.scale)),\n            void 0 !== t.castShadow && (s.castShadow = t.castShadow),\n            void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow),\n            t.shadow &&\n              (void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias),\n              void 0 !== t.shadow.normalBias &&\n                (s.shadow.normalBias = t.shadow.normalBias),\n              void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius),\n              void 0 !== t.shadow.mapSize &&\n                s.shadow.mapSize.fromArray(t.shadow.mapSize),\n              void 0 !== t.shadow.camera &&\n                (s.shadow.camera = this.parseObject(t.shadow.camera))),\n            void 0 !== t.visible && (s.visible = t.visible),\n            void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled),\n            void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder),\n            void 0 !== t.userData && (s.userData = t.userData),\n            void 0 !== t.layers && (s.layers.mask = t.layers),\n            void 0 !== t.children)\n          ) {\n            const a = t.children;\n            for (let t = 0; t < a.length; t++)\n              s.add(this.parseObject(a[t], e, n, i, r));\n          }\n          if (void 0 !== t.animations) {\n            const e = t.animations;\n            for (let t = 0; t < e.length; t++) {\n              const n = e[t];\n              s.animations.push(r[n]);\n            }\n          }\n          if (\"LOD\" === t.type) {\n            void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);\n            const e = t.levels;\n            for (let t = 0; t < e.length; t++) {\n              const n = e[t],\n                i = s.getObjectByProperty(\"uuid\", n.object);\n              void 0 !== i && s.addLevel(i, n.distance);\n            }\n          }\n          return s;\n        }\n        bindSkeletons(t, e) {\n          0 !== Object.keys(e).length &&\n            t.traverse(function (t) {\n              if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {\n                const n = e[t.skeleton];\n                void 0 === n\n                  ? console.warn(\n                      \"THREE.ObjectLoader: No skeleton found with UUID:\",\n                      t.skeleton\n                    )\n                  : t.bind(n, t.bindMatrix);\n              }\n            });\n        }\n        setTexturePath(t) {\n          return (\n            console.warn(\n              \"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().\"\n            ),\n            this.setResourcePath(t)\n          );\n        }\n      }),\n      (t.ObjectSpaceNormalMap = 1),\n      (t.OctahedronBufferGeometry = Ml),\n      (t.OctahedronGeometry = Ml),\n      (t.OneFactor = 201),\n      (t.OneMinusDstAlphaFactor = 207),\n      (t.OneMinusDstColorFactor = 209),\n      (t.OneMinusSrcAlphaFactor = 205),\n      (t.OneMinusSrcColorFactor = 203),\n      (t.OrthographicCamera = bi),\n      (t.PCFShadowMap = 1),\n      (t.PCFSoftShadowMap = 2),\n      (t.PMREMGenerator = Oi),\n      (t.ParametricGeometry = function () {\n        return (\n          console.error(\n            \"THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js\"\n          ),\n          new En()\n        );\n      }),\n      (t.Particle = function (t) {\n        return (\n          console.warn(\"THREE.Particle has been renamed to THREE.Sprite.\"),\n          new xa(t)\n        );\n      }),\n      (t.ParticleBasicMaterial = function (t) {\n        return (\n          console.warn(\n            \"THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.\"\n          ),\n          new Ka(t)\n        );\n      }),\n      (t.ParticleSystem = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.ParticleSystem has been renamed to THREE.Points.\"\n          ),\n          new io(t, e)\n        );\n      }),\n      (t.ParticleSystemMaterial = function (t) {\n        return (\n          console.warn(\n            \"THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.\"\n          ),\n          new Ka(t)\n        );\n      }),\n      (t.Path = Go),\n      (t.PerspectiveCamera = Kn),\n      (t.Plane = ai),\n      (t.PlaneBufferGeometry = di),\n      (t.PlaneGeometry = di),\n      (t.PlaneHelper = class extends Xa {\n        constructor(t, e = 1, n = 16776960) {\n          const i = n,\n            r = new En();\n          r.setAttribute(\n            \"position\",\n            new vn(\n              [\n                1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,\n                -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,\n              ],\n              3\n            )\n          ),\n            r.computeBoundingSphere(),\n            super(r, new Ga({ color: i, toneMapped: !1 })),\n            (this.type = \"PlaneHelper\"),\n            (this.plane = t),\n            (this.size = e);\n          const s = new En();\n          s.setAttribute(\n            \"position\",\n            new vn(\n              [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],\n              3\n            )\n          ),\n            s.computeBoundingSphere(),\n            this.add(\n              new Wn(\n                s,\n                new sn({\n                  color: i,\n                  opacity: 0.2,\n                  transparent: !0,\n                  depthWrite: !1,\n                  toneMapped: !1,\n                })\n              )\n            );\n        }\n        updateMatrixWorld(t) {\n          let e = -this.plane.constant;\n          Math.abs(e) < 1e-8 && (e = 1e-8),\n            this.scale.set(0.5 * this.size, 0.5 * this.size, e),\n            (this.children[0].material.side = e < 0 ? 1 : 0),\n            this.lookAt(this.plane.normal),\n            super.updateMatrixWorld(t);\n        }\n      }),\n      (t.PointCloud = function (t, e) {\n        return (\n          console.warn(\"THREE.PointCloud has been renamed to THREE.Points.\"),\n          new io(t, e)\n        );\n      }),\n      (t.PointCloudMaterial = function (t) {\n        return (\n          console.warn(\n            \"THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.\"\n          ),\n          new Ka(t)\n        );\n      }),\n      (t.PointLight = Tc),\n      (t.PointLightHelper = class extends Wn {\n        constructor(t, e, n) {\n          super(\n            new Sl(e, 4, 2),\n            new sn({ wireframe: !0, fog: !1, toneMapped: !1 })\n          ),\n            (this.light = t),\n            this.light.updateMatrixWorld(),\n            (this.color = n),\n            (this.type = \"PointLightHelper\"),\n            (this.matrix = this.light.matrixWorld),\n            (this.matrixAutoUpdate = !1),\n            this.update();\n        }\n        dispose() {\n          this.geometry.dispose(), this.material.dispose();\n        }\n        update() {\n          void 0 !== this.color\n            ? this.material.color.set(this.color)\n            : this.material.color.copy(this.light.color);\n        }\n      }),\n      (t.Points = io),\n      (t.PointsMaterial = Ka),\n      (t.PolarGridHelper = class extends Za {\n        constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, s = 8947848) {\n          (r = new rn(r)), (s = new rn(s));\n          const a = [],\n            o = [];\n          for (let n = 0; n <= e; n++) {\n            const i = (n / e) * (2 * Math.PI),\n              l = Math.sin(i) * t,\n              c = Math.cos(i) * t;\n            a.push(0, 0, 0), a.push(l, 0, c);\n            const h = 1 & n ? r : s;\n            o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b);\n          }\n          for (let e = 0; e <= n; e++) {\n            const l = 1 & e ? r : s,\n              c = t - (t / n) * e;\n            for (let t = 0; t < i; t++) {\n              let e = (t / i) * (2 * Math.PI),\n                n = Math.sin(e) * c,\n                r = Math.cos(e) * c;\n              a.push(n, 0, r),\n                o.push(l.r, l.g, l.b),\n                (e = ((t + 1) / i) * (2 * Math.PI)),\n                (n = Math.sin(e) * c),\n                (r = Math.cos(e) * c),\n                a.push(n, 0, r),\n                o.push(l.r, l.g, l.b);\n            }\n          }\n          const l = new En();\n          l.setAttribute(\"position\", new vn(a, 3)),\n            l.setAttribute(\"color\", new vn(o, 3));\n          super(l, new Ga({ vertexColors: !0, toneMapped: !1 })),\n            (this.type = \"PolarGridHelper\");\n        }\n      }),\n      (t.PolyhedronBufferGeometry = po),\n      (t.PolyhedronGeometry = po),\n      (t.PositionalAudio = class extends $c {\n        constructor(t) {\n          super(t),\n            (this.panner = this.context.createPanner()),\n            (this.panner.panningModel = \"HRTF\"),\n            this.panner.connect(this.gain);\n        }\n        getOutput() {\n          return this.panner;\n        }\n        getRefDistance() {\n          return this.panner.refDistance;\n        }\n        setRefDistance(t) {\n          return (this.panner.refDistance = t), this;\n        }\n        getRolloffFactor() {\n          return this.panner.rolloffFactor;\n        }\n        setRolloffFactor(t) {\n          return (this.panner.rolloffFactor = t), this;\n        }\n        getDistanceModel() {\n          return this.panner.distanceModel;\n        }\n        setDistanceModel(t) {\n          return (this.panner.distanceModel = t), this;\n        }\n        getMaxDistance() {\n          return this.panner.maxDistance;\n        }\n        setMaxDistance(t) {\n          return (this.panner.maxDistance = t), this;\n        }\n        setDirectionalCone(t, e, n) {\n          return (\n            (this.panner.coneInnerAngle = t),\n            (this.panner.coneOuterAngle = e),\n            (this.panner.coneOuterGain = n),\n            this\n          );\n        }\n        updateMatrixWorld(t) {\n          if (\n            (super.updateMatrixWorld(t),\n            !0 === this.hasPlaybackControl && !1 === this.isPlaying)\n          )\n            return;\n          this.matrixWorld.decompose(th, eh, nh),\n            ih.set(0, 0, 1).applyQuaternion(eh);\n          const e = this.panner;\n          if (e.positionX) {\n            const t = this.context.currentTime + this.listener.timeDelta;\n            e.positionX.linearRampToValueAtTime(th.x, t),\n              e.positionY.linearRampToValueAtTime(th.y, t),\n              e.positionZ.linearRampToValueAtTime(th.z, t),\n              e.orientationX.linearRampToValueAtTime(ih.x, t),\n              e.orientationY.linearRampToValueAtTime(ih.y, t),\n              e.orientationZ.linearRampToValueAtTime(ih.z, t);\n          } else\n            e.setPosition(th.x, th.y, th.z), e.setOrientation(ih.x, ih.y, ih.z);\n        }\n      }),\n      (t.PropertyBinding = gh),\n      (t.PropertyMixer = sh),\n      (t.QuadraticBezierCurve = Bo),\n      (t.QuadraticBezierCurve3 = Fo),\n      (t.Quaternion = Nt),\n      (t.QuaternionKeyframeTrack = Kl),\n      (t.QuaternionLinearInterpolant = Ql),\n      (t.REVISION = e),\n      (t.RGBADepthPacking = 3201),\n      (t.RGBAFormat = E),\n      (t.RGBAIntegerFormat = 1033),\n      (t.RGBA_ASTC_10x10_Format = 37819),\n      (t.RGBA_ASTC_10x5_Format = 37816),\n      (t.RGBA_ASTC_10x6_Format = 37817),\n      (t.RGBA_ASTC_10x8_Format = 37818),\n      (t.RGBA_ASTC_12x10_Format = 37820),\n      (t.RGBA_ASTC_12x12_Format = 37821),\n      (t.RGBA_ASTC_4x4_Format = 37808),\n      (t.RGBA_ASTC_5x4_Format = 37809),\n      (t.RGBA_ASTC_5x5_Format = 37810),\n      (t.RGBA_ASTC_6x5_Format = 37811),\n      (t.RGBA_ASTC_6x6_Format = 37812),\n      (t.RGBA_ASTC_8x5_Format = 37813),\n      (t.RGBA_ASTC_8x6_Format = 37814),\n      (t.RGBA_ASTC_8x8_Format = 37815),\n      (t.RGBA_BPTC_Format = 36492),\n      (t.RGBA_ETC2_EAC_Format = O),\n      (t.RGBA_PVRTC_2BPPV1_Format = B),\n      (t.RGBA_PVRTC_4BPPV1_Format = z),\n      (t.RGBA_S3TC_DXT1_Format = C),\n      (t.RGBA_S3TC_DXT3_Format = P),\n      (t.RGBA_S3TC_DXT5_Format = I),\n      (t.RGBDEncoding = $),\n      (t.RGBEEncoding = Z),\n      (t.RGBEFormat = 1023),\n      (t.RGBFormat = T),\n      (t.RGBIntegerFormat = 1032),\n      (t.RGBM16Encoding = K),\n      (t.RGBM7Encoding = Q),\n      (t.RGB_ETC1_Format = 36196),\n      (t.RGB_ETC2_Format = F),\n      (t.RGB_PVRTC_2BPPV1_Format = N),\n      (t.RGB_PVRTC_4BPPV1_Format = D),\n      (t.RGB_S3TC_DXT1_Format = R),\n      (t.RGFormat = 1030),\n      (t.RGIntegerFormat = 1031),\n      (t.RawShaderMaterial = wi),\n      (t.Ray = ue),\n      (t.Raycaster = class {\n        constructor(t, e, n = 0, i = 1 / 0) {\n          (this.ray = new ue(t, e)),\n            (this.near = n),\n            (this.far = i),\n            (this.camera = null),\n            (this.layers = new we()),\n            (this.params = {\n              Mesh: {},\n              Line: { threshold: 1 },\n              LOD: {},\n              Points: { threshold: 1 },\n              Sprite: {},\n            });\n        }\n        set(t, e) {\n          this.ray.set(t, e);\n        }\n        setFromCamera(t, e) {\n          e && e.isPerspectiveCamera\n            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),\n              this.ray.direction\n                .set(t.x, t.y, 0.5)\n                .unproject(e)\n                .sub(this.ray.origin)\n                .normalize(),\n              (this.camera = e))\n            : e && e.isOrthographicCamera\n            ? (this.ray.origin\n                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))\n                .unproject(e),\n              this.ray.direction\n                .set(0, 0, -1)\n                .transformDirection(e.matrixWorld),\n              (this.camera = e))\n            : console.error(\n                \"THREE.Raycaster: Unsupported camera type: \" + e.type\n              );\n        }\n        intersectObject(t, e = !0, n = []) {\n          return Sh(t, this, n, e), n.sort(wh), n;\n        }\n        intersectObjects(t, e = !0, n = []) {\n          for (let i = 0, r = t.length; i < r; i++) Sh(t[i], this, n, e);\n          return n.sort(wh), n;\n        }\n      }),\n      (t.RectAreaLight = Rc),\n      (t.RedFormat = 1028),\n      (t.RedIntegerFormat = 1029),\n      (t.ReinhardToneMapping = 2),\n      (t.RepeatWrapping = h),\n      (t.ReplaceStencilOp = 7681),\n      (t.ReverseSubtractEquation = 102),\n      (t.RingBufferGeometry = bl),\n      (t.RingGeometry = bl),\n      (t.SRGB8_ALPHA8_ASTC_10x10_Format = 37851),\n      (t.SRGB8_ALPHA8_ASTC_10x5_Format = 37848),\n      (t.SRGB8_ALPHA8_ASTC_10x6_Format = 37849),\n      (t.SRGB8_ALPHA8_ASTC_10x8_Format = 37850),\n      (t.SRGB8_ALPHA8_ASTC_12x10_Format = 37852),\n      (t.SRGB8_ALPHA8_ASTC_12x12_Format = 37853),\n      (t.SRGB8_ALPHA8_ASTC_4x4_Format = 37840),\n      (t.SRGB8_ALPHA8_ASTC_5x4_Format = 37841),\n      (t.SRGB8_ALPHA8_ASTC_5x5_Format = 37842),\n      (t.SRGB8_ALPHA8_ASTC_6x5_Format = 37843),\n      (t.SRGB8_ALPHA8_ASTC_6x6_Format = 37844),\n      (t.SRGB8_ALPHA8_ASTC_8x5_Format = 37845),\n      (t.SRGB8_ALPHA8_ASTC_8x6_Format = 37846),\n      (t.SRGB8_ALPHA8_ASTC_8x8_Format = 37847),\n      (t.Scene = ea),\n      (t.SceneUtils = tu),\n      (t.ShaderChunk = pi),\n      (t.ShaderLib = fi),\n      (t.ShaderMaterial = Zn),\n      (t.ShadowMaterial = Il),\n      (t.Shape = ko),\n      (t.ShapeBufferGeometry = wl),\n      (t.ShapeGeometry = wl),\n      (t.ShapePath = class {\n        constructor() {\n          (this.type = \"ShapePath\"),\n            (this.color = new rn()),\n            (this.subPaths = []),\n            (this.currentPath = null);\n        }\n        moveTo(t, e) {\n          return (\n            (this.currentPath = new Go()),\n            this.subPaths.push(this.currentPath),\n            this.currentPath.moveTo(t, e),\n            this\n          );\n        }\n        lineTo(t, e) {\n          return this.currentPath.lineTo(t, e), this;\n        }\n        quadraticCurveTo(t, e, n, i) {\n          return this.currentPath.quadraticCurveTo(t, e, n, i), this;\n        }\n        bezierCurveTo(t, e, n, i, r, s) {\n          return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;\n        }\n        splineThru(t) {\n          return this.currentPath.splineThru(t), this;\n        }\n        toShapes(t, e) {\n          function n(t) {\n            const e = [];\n            for (let n = 0, i = t.length; n < i; n++) {\n              const i = t[n],\n                r = new ko();\n              (r.curves = i.curves), e.push(r);\n            }\n            return e;\n          }\n          function i(t, e) {\n            const n = e.length;\n            let i = !1;\n            for (let r = n - 1, s = 0; s < n; r = s++) {\n              let n = e[r],\n                a = e[s],\n                o = a.x - n.x,\n                l = a.y - n.y;\n              if (Math.abs(l) > Number.EPSILON) {\n                if (\n                  (l < 0 && ((n = e[s]), (o = -o), (a = e[r]), (l = -l)),\n                  t.y < n.y || t.y > a.y)\n                )\n                  continue;\n                if (t.y === n.y) {\n                  if (t.x === n.x) return !0;\n                } else {\n                  const e = l * (t.x - n.x) - o * (t.y - n.y);\n                  if (0 === e) return !0;\n                  if (e < 0) continue;\n                  i = !i;\n                }\n              } else {\n                if (t.y !== n.y) continue;\n                if ((a.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= a.x))\n                  return !0;\n              }\n            }\n            return i;\n          }\n          const r = ml.isClockWise,\n            s = this.subPaths;\n          if (0 === s.length) return [];\n          if (!0 === e) return n(s);\n          let a, o, l;\n          const c = [];\n          if (1 === s.length)\n            return (\n              (o = s[0]), (l = new ko()), (l.curves = o.curves), c.push(l), c\n            );\n          let h = !r(s[0].getPoints());\n          h = t ? !h : h;\n          const u = [],\n            d = [];\n          let p,\n            m,\n            f = [],\n            g = 0;\n          (d[g] = void 0), (f[g] = []);\n          for (let e = 0, n = s.length; e < n; e++)\n            (o = s[e]),\n              (p = o.getPoints()),\n              (a = r(p)),\n              (a = t ? !a : a),\n              a\n                ? (!h && d[g] && g++,\n                  (d[g] = { s: new ko(), p: p }),\n                  (d[g].s.curves = o.curves),\n                  h && g++,\n                  (f[g] = []))\n                : f[g].push({ h: o, p: p[0] });\n          if (!d[0]) return n(s);\n          if (d.length > 1) {\n            let t = !1;\n            const e = [];\n            for (let t = 0, e = d.length; t < e; t++) u[t] = [];\n            for (let n = 0, r = d.length; n < r; n++) {\n              const r = f[n];\n              for (let s = 0; s < r.length; s++) {\n                const a = r[s];\n                let o = !0;\n                for (let r = 0; r < d.length; r++)\n                  i(a.p, d[r].p) &&\n                    (n !== r && e.push({ froms: n, tos: r, hole: s }),\n                    o ? ((o = !1), u[r].push(a)) : (t = !0));\n                o && u[n].push(a);\n              }\n            }\n            e.length > 0 && (t || (f = u));\n          }\n          for (let t = 0, e = d.length; t < e; t++) {\n            (l = d[t].s), c.push(l), (m = f[t]);\n            for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h);\n          }\n          return c;\n        }\n      }),\n      (t.ShapeUtils = ml),\n      (t.ShortType = 1011),\n      (t.Skeleton = Na),\n      (t.SkeletonHelper = Nh),\n      (t.SkinnedMesh = Ra),\n      (t.SmoothShading = 2),\n      (t.Sphere = ie),\n      (t.SphereBufferGeometry = Sl),\n      (t.SphereGeometry = Sl),\n      (t.Spherical = class {\n        constructor(t = 1, e = 0, n = 0) {\n          return (this.radius = t), (this.phi = e), (this.theta = n), this;\n        }\n        set(t, e, n) {\n          return (this.radius = t), (this.phi = e), (this.theta = n), this;\n        }\n        copy(t) {\n          return (\n            (this.radius = t.radius),\n            (this.phi = t.phi),\n            (this.theta = t.theta),\n            this\n          );\n        }\n        makeSafe() {\n          const t = 1e-6;\n          return (\n            (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this\n          );\n        }\n        setFromVector3(t) {\n          return this.setFromCartesianCoords(t.x, t.y, t.z);\n        }\n        setFromCartesianCoords(t, e, n) {\n          return (\n            (this.radius = Math.sqrt(t * t + e * e + n * n)),\n            0 === this.radius\n              ? ((this.theta = 0), (this.phi = 0))\n              : ((this.theta = Math.atan2(t, n)),\n                (this.phi = Math.acos(ut(e / this.radius, -1, 1)))),\n            this\n          );\n        }\n        clone() {\n          return new this.constructor().copy(this);\n        }\n      }),\n      (t.SphericalHarmonics3 = Cc),\n      (t.SplineCurve = Oo),\n      (t.SpotLight = _c),\n      (t.SpotLightHelper = class extends Fe {\n        constructor(t, e) {\n          super(),\n            (this.light = t),\n            this.light.updateMatrixWorld(),\n            (this.matrix = t.matrixWorld),\n            (this.matrixAutoUpdate = !1),\n            (this.color = e);\n          const n = new En(),\n            i = [\n              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,\n              1, 1, 0, 0, 0, 0, -1, 1,\n            ];\n          for (let t = 0, e = 1, n = 32; t < n; t++, e++) {\n            const r = (t / n) * Math.PI * 2,\n              s = (e / n) * Math.PI * 2;\n            i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1);\n          }\n          n.setAttribute(\"position\", new vn(i, 3));\n          const r = new Ga({ fog: !1, toneMapped: !1 });\n          (this.cone = new Za(n, r)), this.add(this.cone), this.update();\n        }\n        dispose() {\n          this.cone.geometry.dispose(), this.cone.material.dispose();\n        }\n        update() {\n          this.light.updateMatrixWorld();\n          const t = this.light.distance ? this.light.distance : 1e3,\n            e = t * Math.tan(this.light.angle);\n          this.cone.scale.set(e, e, t),\n            Ch.setFromMatrixPosition(this.light.target.matrixWorld),\n            this.cone.lookAt(Ch),\n            void 0 !== this.color\n              ? this.cone.material.color.set(this.color)\n              : this.cone.material.color.copy(this.light.color);\n        }\n      }),\n      (t.Sprite = xa),\n      (t.SpriteMaterial = sa),\n      (t.SrcAlphaFactor = 204),\n      (t.SrcAlphaSaturateFactor = 210),\n      (t.SrcColorFactor = 202),\n      (t.StaticCopyUsage = 35046),\n      (t.StaticDrawUsage = et),\n      (t.StaticReadUsage = 35045),\n      (t.StereoCamera = class {\n        constructor() {\n          (this.type = \"StereoCamera\"),\n            (this.aspect = 1),\n            (this.eyeSep = 0.064),\n            (this.cameraL = new Kn()),\n            this.cameraL.layers.enable(1),\n            (this.cameraL.matrixAutoUpdate = !1),\n            (this.cameraR = new Kn()),\n            this.cameraR.layers.enable(2),\n            (this.cameraR.matrixAutoUpdate = !1),\n            (this._cache = {\n              focus: null,\n              fov: null,\n              aspect: null,\n              near: null,\n              far: null,\n              zoom: null,\n              eyeSep: null,\n            });\n        }\n        update(t) {\n          const e = this._cache;\n          if (\n            e.focus !== t.focus ||\n            e.fov !== t.fov ||\n            e.aspect !== t.aspect * this.aspect ||\n            e.near !== t.near ||\n            e.far !== t.far ||\n            e.zoom !== t.zoom ||\n            e.eyeSep !== this.eyeSep\n          ) {\n            (e.focus = t.focus),\n              (e.fov = t.fov),\n              (e.aspect = t.aspect * this.aspect),\n              (e.near = t.near),\n              (e.far = t.far),\n              (e.zoom = t.zoom),\n              (e.eyeSep = this.eyeSep);\n            const n = t.projectionMatrix.clone(),\n              i = e.eyeSep / 2,\n              r = (i * e.near) / e.focus,\n              s = (e.near * Math.tan(at * e.fov * 0.5)) / e.zoom;\n            let a, o;\n            (qc.elements[12] = -i),\n              (jc.elements[12] = i),\n              (a = -s * e.aspect + r),\n              (o = s * e.aspect + r),\n              (n.elements[0] = (2 * e.near) / (o - a)),\n              (n.elements[8] = (o + a) / (o - a)),\n              this.cameraL.projectionMatrix.copy(n),\n              (a = -s * e.aspect - r),\n              (o = s * e.aspect - r),\n              (n.elements[0] = (2 * e.near) / (o - a)),\n              (n.elements[8] = (o + a) / (o - a)),\n              this.cameraR.projectionMatrix.copy(n);\n          }\n          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(qc),\n            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(jc);\n        }\n      }),\n      (t.StreamCopyUsage = 35042),\n      (t.StreamDrawUsage = 35040),\n      (t.StreamReadUsage = 35041),\n      (t.StringKeyframeTrack = $l),\n      (t.SubtractEquation = 101),\n      (t.SubtractiveBlending = 3),\n      (t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }),\n      (t.TangentSpaceNormalMap = 0),\n      (t.TetrahedronBufferGeometry = Tl),\n      (t.TetrahedronGeometry = Tl),\n      (t.TextGeometry = function () {\n        return (\n          console.error(\n            \"THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js\"\n          ),\n          new En()\n        );\n      }),\n      (t.Texture = Lt),\n      (t.TextureLoader = dc),\n      (t.TorusBufferGeometry = El),\n      (t.TorusGeometry = El),\n      (t.TorusKnotBufferGeometry = Al),\n      (t.TorusKnotGeometry = Al),\n      (t.Triangle = Ye),\n      (t.TriangleFanDrawMode = 2),\n      (t.TriangleStripDrawMode = 1),\n      (t.TrianglesDrawMode = 0),\n      (t.TubeBufferGeometry = Ll),\n      (t.TubeGeometry = Ll),\n      (t.UVMapping = i),\n      (t.Uint16Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.\"\n          ),\n          new pn(t, e)\n        );\n      }),\n      (t.Uint16BufferAttribute = pn),\n      (t.Uint32Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.\"\n          ),\n          new fn(t, e)\n        );\n      }),\n      (t.Uint32BufferAttribute = fn),\n      (t.Uint8Attribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.\"\n          ),\n          new hn(t, e)\n        );\n      }),\n      (t.Uint8BufferAttribute = hn),\n      (t.Uint8ClampedAttribute = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.\"\n          ),\n          new un(t, e)\n        );\n      }),\n      (t.Uint8ClampedBufferAttribute = un),\n      (t.Uniform = _h),\n      (t.UniformsLib = mi),\n      (t.UniformsUtils = Jn),\n      (t.UnsignedByteType = x),\n      (t.UnsignedInt248Type = S),\n      (t.UnsignedIntType = M),\n      (t.UnsignedShort4444Type = 1017),\n      (t.UnsignedShort5551Type = 1018),\n      (t.UnsignedShort565Type = 1019),\n      (t.UnsignedShortType = _),\n      (t.VSMShadowMap = 3),\n      (t.Vector2 = yt),\n      (t.Vector3 = zt),\n      (t.Vector4 = Ct),\n      (t.VectorKeyframeTrack = tc),\n      (t.Vertex = function (t, e, n) {\n        return (\n          console.warn(\n            \"THREE.Vertex has been removed. Use THREE.Vector3 instead.\"\n          ),\n          new zt(t, e, n)\n        );\n      }),\n      (t.VertexColors = 2),\n      (t.VideoTexture = so),\n      (t.WebGL1Renderer = Ks),\n      (t.WebGLCubeRenderTarget = ni),\n      (t.WebGLMultipleRenderTargets = It),\n      (t.WebGLMultisampleRenderTarget = Dt),\n      (t.WebGLRenderTarget = Pt),\n      (t.WebGLRenderTargetCube = function (t, e, n) {\n        return (\n          console.warn(\n            \"THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).\"\n          ),\n          new ni(t, n)\n        );\n      }),\n      (t.WebGLRenderer = Qs),\n      (t.WebGLUtils = Ws),\n      (t.WireframeGeometry = Rl),\n      (t.WireframeHelper = function (t, e) {\n        return (\n          console.warn(\n            \"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.\"\n          ),\n          new Za(\n            new Rl(t.geometry),\n            new Ga({ color: void 0 !== e ? e : 16777215 })\n          )\n        );\n      }),\n      (t.WrapAroundEnding = W),\n      (t.XHRLoader = function (t) {\n        return (\n          console.warn(\"THREE.XHRLoader has been renamed to THREE.FileLoader.\"),\n          new lc(t)\n        );\n      }),\n      (t.ZeroCurvatureEnding = k),\n      (t.ZeroFactor = 200),\n      (t.ZeroSlopeEnding = V),\n      (t.ZeroStencilOp = 0),\n      (t.sRGBEncoding = Y),\n      Object.defineProperty(t, \"__esModule\", { value: !0 });\n  });\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (three);\n\n\n//# sourceURL=webpack://gulp-2022/./src/js/modules/three.min.js?");

/***/ }),

/***/ "./src/js/modules/vanta.waves.min.js":
/*!*******************************************!*\
  !*** ./src/js/modules/vanta.waves.min.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst vantaWawes = () => {\r\n  !(function (t, e) {\r\n    \"object\" == typeof exports && \"object\" == typeof module\r\n      ? (module.exports = e())\r\n      : \"function\" == typeof define && define.amd\r\n      ? define([], e)\r\n      : \"object\" == typeof exports\r\n      ? (exports._vantaEffect = e())\r\n      : (t._vantaEffect = e());\r\n  })(\"undefined\" != typeof self ? self : undefined, () =>\r\n    (() => {\r\n      \"use strict\";\r\n      var t = {\r\n          d: (e, i) => {\r\n            for (var s in i)\r\n              t.o(i, s) &&\r\n                !t.o(e, s) &&\r\n                Object.defineProperty(e, s, { enumerable: !0, get: i[s] });\r\n          },\r\n          o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),\r\n          r: (t) => {\r\n            \"undefined\" != typeof Symbol &&\r\n              Symbol.toStringTag &&\r\n              Object.defineProperty(t, Symbol.toStringTag, { value: \"Module\" }),\r\n              Object.defineProperty(t, \"__esModule\", { value: !0 });\r\n          },\r\n        },\r\n        e = {};\r\n      function i(t, e) {\r\n        return (\r\n          null == t && (t = 0),\r\n          null == e && (e = 1),\r\n          Math.floor(t + Math.random() * (e - t + 1))\r\n        );\r\n      }\r\n      t.r(e),\r\n        t.d(e, { default: () => c }),\r\n        (Number.prototype.clamp = function (t, e) {\r\n          return Math.min(Math.max(this, t), e);\r\n        });\r\n      function s(t) {\r\n        for (; t.children && t.children.length > 0; )\r\n          s(t.children[0]), t.remove(t.children[0]);\r\n        t.geometry && t.geometry.dispose(),\r\n          t.material &&\r\n            (Object.keys(t.material).forEach((e) => {\r\n              t.material[e] &&\r\n                null !== t.material[e] &&\r\n                \"function\" == typeof t.material[e].dispose &&\r\n                t.material[e].dispose();\r\n            }),\r\n            t.material.dispose());\r\n      }\r\n      const o = \"object\" == typeof window;\r\n      let n = (o && window.THREE) || {};\r\n      o && !window.VANTA && (window.VANTA = {});\r\n      const r = (o && window.VANTA) || {};\r\n      (r.register = (t, e) => (r[t] = (t) => new e(t))), (r.version = \"0.5.24\");\r\n      const h = function () {\r\n        return (\r\n          Array.prototype.unshift.call(arguments, \"[VANTA]\"),\r\n          console.error.apply(this, arguments)\r\n        );\r\n      };\r\n      r.VantaBase = class {\r\n        constructor(t = {}) {\r\n          if (!o) return !1;\r\n          (r.current = this),\r\n            (this.windowMouseMoveWrapper =\r\n              this.windowMouseMoveWrapper.bind(this)),\r\n            (this.windowTouchWrapper = this.windowTouchWrapper.bind(this)),\r\n            (this.windowGyroWrapper = this.windowGyroWrapper.bind(this)),\r\n            (this.resize = this.resize.bind(this)),\r\n            (this.animationLoop = this.animationLoop.bind(this)),\r\n            (this.restart = this.restart.bind(this));\r\n          const e =\r\n            \"function\" == typeof this.getDefaultOptions\r\n              ? this.getDefaultOptions()\r\n              : this.defaultOptions;\r\n          if (\r\n            ((this.options = Object.assign(\r\n              {\r\n                mouseControls: !0,\r\n                touchControls: !0,\r\n                gyroControls: !1,\r\n                minHeight: 200,\r\n                minWidth: 200,\r\n                scale: 1,\r\n                scaleMobile: 1,\r\n              },\r\n              e\r\n            )),\r\n            (t instanceof HTMLElement || \"string\" == typeof t) &&\r\n              (t = { el: t }),\r\n            Object.assign(this.options, t),\r\n            this.options.THREE && (n = this.options.THREE),\r\n            (this.el = this.options.el),\r\n            null == this.el)\r\n          )\r\n            h('Instance needs \"el\" param!');\r\n          else if (!(this.options.el instanceof HTMLElement)) {\r\n            const t = this.el;\r\n            if (((this.el = ((i = t), document.querySelector(i))), !this.el))\r\n              return void h(\"Cannot find element\", t);\r\n          }\r\n          var i, s;\r\n          this.prepareEl(), this.initThree(), this.setSize();\r\n          try {\r\n            this.init();\r\n          } catch (t) {\r\n            return (\r\n              h(\"Init error\", t),\r\n              this.renderer &&\r\n                this.renderer.domElement &&\r\n                this.el.removeChild(this.renderer.domElement),\r\n              void (\r\n                this.options.backgroundColor &&\r\n                (console.log(\"[VANTA] Falling back to backgroundColor\"),\r\n                (this.el.style.background =\r\n                  ((s = this.options.backgroundColor),\r\n                  \"number\" == typeof s\r\n                    ? \"#\" + (\"00000\" + s.toString(16)).slice(-6)\r\n                    : s)))\r\n              )\r\n            );\r\n          }\r\n          this.initMouse(), this.resize(), this.animationLoop();\r\n          const a = window.addEventListener;\r\n          a(\"resize\", this.resize),\r\n            window.requestAnimationFrame(this.resize),\r\n            this.options.mouseControls &&\r\n              (a(\"scroll\", this.windowMouseMoveWrapper),\r\n              a(\"mousemove\", this.windowMouseMoveWrapper)),\r\n            this.options.touchControls &&\r\n              (a(\"touchstart\", this.windowTouchWrapper),\r\n              a(\"touchmove\", this.windowTouchWrapper)),\r\n            this.options.gyroControls &&\r\n              a(\"deviceorientation\", this.windowGyroWrapper);\r\n        }\r\n        setOptions(t = {}) {\r\n          Object.assign(this.options, t), this.triggerMouseMove();\r\n        }\r\n        prepareEl() {\r\n          let t, e;\r\n          if (\"undefined\" != typeof Node && Node.TEXT_NODE)\r\n            for (t = 0; t < this.el.childNodes.length; t++) {\r\n              const e = this.el.childNodes[t];\r\n              if (e.nodeType === Node.TEXT_NODE) {\r\n                const t = document.createElement(\"span\");\r\n                (t.textContent = e.textContent),\r\n                  e.parentElement.insertBefore(t, e),\r\n                  e.remove();\r\n              }\r\n            }\r\n          for (t = 0; t < this.el.children.length; t++)\r\n            (e = this.el.children[t]),\r\n              \"static\" === getComputedStyle(e).position &&\r\n                (e.style.position = \"relative\"),\r\n              \"auto\" === getComputedStyle(e).zIndex && (e.style.zIndex = 1);\r\n          \"static\" === getComputedStyle(this.el).position &&\r\n            (this.el.style.position = \"relative\");\r\n        }\r\n        applyCanvasStyles(t, e = {}) {\r\n          Object.assign(t.style, {\r\n            position: \"absolute\",\r\n            zIndex: 0,\r\n            top: 0,\r\n            left: 0,\r\n            background: \"\",\r\n          }),\r\n            Object.assign(t.style, e),\r\n            t.classList.add(\"vanta-canvas\");\r\n        }\r\n        initThree() {\r\n          n.WebGLRenderer\r\n            ? ((this.renderer = new n.WebGLRenderer({\r\n                alpha: !0,\r\n                antialias: !0,\r\n              })),\r\n              this.el.appendChild(this.renderer.domElement),\r\n              this.applyCanvasStyles(this.renderer.domElement),\r\n              isNaN(this.options.backgroundAlpha) &&\r\n                (this.options.backgroundAlpha = 1),\r\n              (this.scene = new n.Scene()))\r\n            : console.warn(\"[VANTA] No THREE defined on window\");\r\n        }\r\n        getCanvasElement() {\r\n          return this.renderer\r\n            ? this.renderer.domElement\r\n            : this.p5renderer\r\n            ? this.p5renderer.canvas\r\n            : void 0;\r\n        }\r\n        getCanvasRect() {\r\n          const t = this.getCanvasElement();\r\n          return !!t && t.getBoundingClientRect();\r\n        }\r\n        windowMouseMoveWrapper(t) {\r\n          const e = this.getCanvasRect();\r\n          if (!e) return !1;\r\n          const i = t.clientX - e.left,\r\n            s = t.clientY - e.top;\r\n          i >= 0 &&\r\n            s >= 0 &&\r\n            i <= e.width &&\r\n            s <= e.height &&\r\n            ((this.mouseX = i),\r\n            (this.mouseY = s),\r\n            this.options.mouseEase || this.triggerMouseMove(i, s));\r\n        }\r\n        windowTouchWrapper(t) {\r\n          const e = this.getCanvasRect();\r\n          if (!e) return !1;\r\n          if (1 === t.touches.length) {\r\n            const i = t.touches[0].clientX - e.left,\r\n              s = t.touches[0].clientY - e.top;\r\n            i >= 0 &&\r\n              s >= 0 &&\r\n              i <= e.width &&\r\n              s <= e.height &&\r\n              ((this.mouseX = i),\r\n              (this.mouseY = s),\r\n              this.options.mouseEase || this.triggerMouseMove(i, s));\r\n          }\r\n        }\r\n        windowGyroWrapper(t) {\r\n          const e = this.getCanvasRect();\r\n          if (!e) return !1;\r\n          const i = Math.round(2 * t.alpha) - e.left,\r\n            s = Math.round(2 * t.beta) - e.top;\r\n          i >= 0 &&\r\n            s >= 0 &&\r\n            i <= e.width &&\r\n            s <= e.height &&\r\n            ((this.mouseX = i),\r\n            (this.mouseY = s),\r\n            this.options.mouseEase || this.triggerMouseMove(i, s));\r\n        }\r\n        triggerMouseMove(t, e) {\r\n          void 0 === t &&\r\n            void 0 === e &&\r\n            (this.options.mouseEase\r\n              ? ((t = this.mouseEaseX), (e = this.mouseEaseY))\r\n              : ((t = this.mouseX), (e = this.mouseY))),\r\n            this.uniforms &&\r\n              ((this.uniforms.iMouse.value.x = t / this.scale),\r\n              (this.uniforms.iMouse.value.y = e / this.scale));\r\n          const i = t / this.width,\r\n            s = e / this.height;\r\n          \"function\" == typeof this.onMouseMove && this.onMouseMove(i, s);\r\n        }\r\n        setSize() {\r\n          this.scale || (this.scale = 1),\r\n            \"undefined\" != typeof navigator &&\r\n            (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n              navigator.userAgent\r\n            ) ||\r\n              window.innerWidth < 600) &&\r\n            this.options.scaleMobile\r\n              ? (this.scale = this.options.scaleMobile)\r\n              : this.options.scale && (this.scale = this.options.scale),\r\n            (this.width = Math.max(this.el.offsetWidth, this.options.minWidth)),\r\n            (this.height = Math.max(\r\n              this.el.offsetHeight,\r\n              this.options.minHeight\r\n            ));\r\n        }\r\n        initMouse() {\r\n          ((!this.mouseX && !this.mouseY) ||\r\n            (this.mouseX === this.options.minWidth / 2 &&\r\n              this.mouseY === this.options.minHeight / 2)) &&\r\n            ((this.mouseX = this.width / 2),\r\n            (this.mouseY = this.height / 2),\r\n            this.triggerMouseMove(this.mouseX, this.mouseY));\r\n        }\r\n        resize() {\r\n          this.setSize(),\r\n            this.camera &&\r\n              ((this.camera.aspect = this.width / this.height),\r\n              \"function\" == typeof this.camera.updateProjectionMatrix &&\r\n                this.camera.updateProjectionMatrix()),\r\n            this.renderer &&\r\n              (this.renderer.setSize(this.width, this.height),\r\n              this.renderer.setPixelRatio(\r\n                window.devicePixelRatio / this.scale\r\n              )),\r\n            \"function\" == typeof this.onResize && this.onResize();\r\n        }\r\n        isOnScreen() {\r\n          const t = this.el.offsetHeight,\r\n            e = this.el.getBoundingClientRect(),\r\n            i =\r\n              window.pageYOffset ||\r\n              (\r\n                document.documentElement ||\r\n                document.body.parentNode ||\r\n                document.body\r\n              ).scrollTop,\r\n            s = e.top + i;\r\n          return s - window.innerHeight <= i && i <= s + t;\r\n        }\r\n        animationLoop() {\r\n          this.t || (this.t = 0), this.t2 || (this.t2 = 0);\r\n          const t = performance.now();\r\n          if (this.prevNow) {\r\n            let e = (t - this.prevNow) / (1e3 / 60);\r\n            (e = Math.max(0.2, Math.min(e, 5))),\r\n              (this.t += e),\r\n              (this.t2 += (this.options.speed || 1) * e),\r\n              this.uniforms && (this.uniforms.iTime.value = 0.016667 * this.t2);\r\n          }\r\n          return (\r\n            (this.prevNow = t),\r\n            this.options.mouseEase &&\r\n              ((this.mouseEaseX = this.mouseEaseX || this.mouseX || 0),\r\n              (this.mouseEaseY = this.mouseEaseY || this.mouseY || 0),\r\n              Math.abs(this.mouseEaseX - this.mouseX) +\r\n                Math.abs(this.mouseEaseY - this.mouseY) >\r\n                0.1 &&\r\n                ((this.mouseEaseX += 0.05 * (this.mouseX - this.mouseEaseX)),\r\n                (this.mouseEaseY += 0.05 * (this.mouseY - this.mouseEaseY)),\r\n                this.triggerMouseMove(this.mouseEaseX, this.mouseEaseY))),\r\n            (this.isOnScreen() || this.options.forceAnimate) &&\r\n              (\"function\" == typeof this.onUpdate && this.onUpdate(),\r\n              this.scene &&\r\n                this.camera &&\r\n                (this.renderer.render(this.scene, this.camera),\r\n                this.renderer.setClearColor(\r\n                  this.options.backgroundColor,\r\n                  this.options.backgroundAlpha\r\n                )),\r\n              this.fps && this.fps.update && this.fps.update(),\r\n              \"function\" == typeof this.afterRender && this.afterRender()),\r\n            (this.req = window.requestAnimationFrame(this.animationLoop))\r\n          );\r\n        }\r\n        restart() {\r\n          if (this.scene)\r\n            for (; this.scene.children.length; )\r\n              this.scene.remove(this.scene.children[0]);\r\n          \"function\" == typeof this.onRestart && this.onRestart(), this.init();\r\n        }\r\n        init() {\r\n          \"function\" == typeof this.onInit && this.onInit();\r\n        }\r\n        destroy() {\r\n          \"function\" == typeof this.onDestroy && this.onDestroy();\r\n          const t = window.removeEventListener;\r\n          t(\"touchstart\", this.windowTouchWrapper),\r\n            t(\"touchmove\", this.windowTouchWrapper),\r\n            t(\"scroll\", this.windowMouseMoveWrapper),\r\n            t(\"mousemove\", this.windowMouseMoveWrapper),\r\n            t(\"deviceorientation\", this.windowGyroWrapper),\r\n            t(\"resize\", this.resize),\r\n            window.cancelAnimationFrame(this.req);\r\n          const e = this.scene;\r\n          e && e.children && s(e),\r\n            this.renderer &&\r\n              (this.renderer.domElement &&\r\n                this.el.removeChild(this.renderer.domElement),\r\n              (this.renderer = null),\r\n              (this.scene = null)),\r\n            r.current === this && (r.current = null);\r\n        }\r\n      };\r\n      const a = r.VantaBase;\r\n      let p = \"object\" == typeof window && window.THREE;\r\n      class l extends a {\r\n        static initClass() {\r\n          (this.prototype.ww = 100),\r\n            (this.prototype.hh = 80),\r\n            (this.prototype.waveNoise = 4);\r\n        }\r\n        constructor(t) {\r\n          (p = t.THREE || p), super(t);\r\n        }\r\n        getMaterial() {\r\n          const t = {\r\n            color: this.options.color,\r\n            shininess: this.options.shininess,\r\n            flatShading: !0,\r\n            side: p.DoubleSide,\r\n          };\r\n          return new p.MeshPhongMaterial(t);\r\n        }\r\n        onInit() {\r\n          let t, e;\r\n          const s = this.getMaterial(),\r\n            o = new p.BufferGeometry();\r\n          this.gg = [];\r\n          const n = [];\r\n          for (t = 0; t <= this.ww; t++)\r\n            for (this.gg[t] = [], e = 0; e <= this.hh; e++) {\r\n              const i = n.length,\r\n                s = new p.Vector3(\r\n                  18 * (t - 0.5 * this.ww),\r\n                  (null == (r = 0) && (r = 0),\r\n                  null == (h = this.waveNoise) && (h = 1),\r\n                  r + Math.random() * (h - r) - 10),\r\n                  18 * (0.5 * this.hh - e)\r\n                );\r\n              n.push(s), (this.gg[t][e] = i);\r\n            }\r\n          var r, h;\r\n          o.setFromPoints(n);\r\n          const a = [];\r\n          for (t = 1; t <= this.ww; t++)\r\n            for (e = 1; e <= this.hh; e++) {\r\n              let s, o;\r\n              const n = this.gg[t][e],\r\n                r = this.gg[t][e - 1],\r\n                h = this.gg[t - 1][e],\r\n                p = this.gg[t - 1][e - 1];\r\n              i(0, 1)\r\n                ? ((s = [p, r, h]), (o = [r, h, n]))\r\n                : ((s = [p, r, n]), (o = [p, h, n])),\r\n                a.push(...s, ...o);\r\n            }\r\n          o.setIndex(a),\r\n            (this.plane = new p.Mesh(o, s)),\r\n            this.scene.add(this.plane);\r\n          const l = new p.AmbientLight(16777215, 0.9);\r\n          this.scene.add(l);\r\n          const c = new p.PointLight(16777215, 0.9);\r\n          c.position.set(-100, 250, -100),\r\n            this.scene.add(c),\r\n            (this.camera = new p.PerspectiveCamera(\r\n              35,\r\n              this.width / this.height,\r\n              50,\r\n              1e4\r\n            )),\r\n            (this.cameraPosition = new p.Vector3(240, 200, 390)),\r\n            (this.cameraTarget = new p.Vector3(140, -30, 190)),\r\n            this.camera.position.copy(this.cameraPosition),\r\n            this.scene.add(this.camera);\r\n        }\r\n        onUpdate() {\r\n          let t;\r\n          this.plane.material.color.set(this.options.color),\r\n            (this.plane.material.shininess = this.options.shininess),\r\n            (this.camera.ox = this.cameraPosition.x / this.options.zoom),\r\n            (this.camera.oy = this.cameraPosition.y / this.options.zoom),\r\n            (this.camera.oz = this.cameraPosition.z / this.options.zoom),\r\n            null != this.controls && this.controls.update();\r\n          const e = this.camera;\r\n          Math.abs(e.tx - e.position.x) > 0.01 &&\r\n            ((t = e.tx - e.position.x), (e.position.x += 0.02 * t)),\r\n            Math.abs(e.ty - e.position.y) > 0.01 &&\r\n              ((t = e.ty - e.position.y), (e.position.y += 0.02 * t)),\r\n            Math.abs(e.tz - e.position.z) > 0.01 &&\r\n              ((t = e.tz - e.position.z), (e.position.z += 0.02 * t)),\r\n            e.lookAt(this.cameraTarget),\r\n            (this.oy = this.oy || {});\r\n          for (\r\n            let t = 0;\r\n            t < this.plane.geometry.attributes.position.array.length;\r\n            t += 3\r\n          ) {\r\n            const e = {\r\n              x: this.plane.geometry.attributes.position.array[t],\r\n              y: this.plane.geometry.attributes.position.array[t + 1],\r\n              z: this.plane.geometry.attributes.position.array[t + 2],\r\n              oy: this.oy[t],\r\n            };\r\n            if (e.oy) {\r\n              const i = this.options.waveSpeed,\r\n                s = Math.sqrt(i) * Math.cos(-e.x - 0.7 * e.z),\r\n                o = Math.sin(\r\n                  i * this.t * 0.02 - i * e.x * 0.025 + i * e.z * 0.015 + s\r\n                ),\r\n                n = Math.pow(o + 1, 2) / 4;\r\n              (e.y = e.oy + n * this.options.waveHeight),\r\n                (this.plane.geometry.attributes.position.array[t + 1] = e.y);\r\n            } else this.oy[t] = e.y;\r\n          }\r\n          this.plane.geometry.attributes.position.setUsage(p.DynamicDrawUsage),\r\n            this.plane.geometry.computeVertexNormals(),\r\n            (this.plane.geometry.attributes.position.needsUpdate = !0),\r\n            this.wireframe &&\r\n              (this.wireframe.geometry.fromGeometry(this.plane.geometry),\r\n              this.wireframe.geometry.computeFaceNormals());\r\n        }\r\n        onMouseMove(t, e) {\r\n          const i = this.camera;\r\n          return (\r\n            i.oy ||\r\n              ((i.oy = i.position.y),\r\n              (i.ox = i.position.x),\r\n              (i.oz = i.position.z)),\r\n            (i.tx = i.ox + (100 * (t - 0.5)) / this.options.zoom),\r\n            (i.ty = i.oy + (-100 * (e - 0.5)) / this.options.zoom),\r\n            (i.tz = i.oz + (-50 * (t - 0.5)) / this.options.zoom)\r\n          );\r\n        }\r\n      }\r\n      (l.prototype.defaultOptions = {\r\n        color: 21896,\r\n        shininess: 30,\r\n        waveHeight: 15,\r\n        waveSpeed: 1,\r\n        zoom: 1,\r\n      }),\r\n        l.initClass();\r\n      const c = r.register(\"WAVES\", l);\r\n      return e;\r\n    })()\r\n  );\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (vantaWawes);\r\n\n\n//# sourceURL=webpack://gulp-2022/./src/js/modules/vanta.waves.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;